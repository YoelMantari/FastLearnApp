ğŸ§  Pregunta 131

Â¿QuÃ© garantiza que una modificaciÃ³n mÃ­nima en el contenido de un archivo se propague hasta el hash del commit?

A. El uso de blobs compresos en packfiles
B. La propiedad determinista del algoritmo SHA
C. La estructura en Ã¡rbol de Merkle que conecta blobs, trees y commits
D. La ejecuciÃ³n de git gc despuÃ©s de cada commit

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El Ã¡rbol de Merkle propaga los cambios: un cambio en un blob modifica el tree que lo contiene, y eso cambia el commit asociado.

ğŸ§  Pregunta 132

En un entorno colaborativo con Git distribuido, Â¿cuÃ¡l de los siguientes escenarios refleja mejor una ventaja del modelo peer-to-peer?

A. Se requiere un servidor central para crear ramas locales
B. Es posible hacer push directo sin configurar remotos
C. Cada desarrollador puede trabajar y hacer commits sin conexiÃ³n a la red
D. Los commits deben validarse con un hook centralizado

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: En Git distribuido, cada clon contiene todo el historial; se puede trabajar localmente sin conexiÃ³n, y sincronizar despuÃ©s.

ğŸ§  Pregunta 133


HEAD â†’ C6
         |
        C5
       /
C1â”€C2â”€C3â”€C4
Si src/utils.py en C2 cambia y se vuelve a ejecutar git commit, Â¿quÃ© nodos del Ã¡rbol de Merkle tendrÃ¡n nuevo hash?

A. Solo el commit C2
B. C2, C3 y C6
C. C2 y el blob modificado
D. C2, su tree, y los commits descendientes (C3, C4, C5, C6)

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: El cambio en un blob altera el tree de C2, lo que cambia el hash de C2; como los commits siguientes dependen de Ã©l, todos deben cambiar.

ğŸ§  Pregunta 134

Â¿CuÃ¡l es el propÃ³sito de almacenar objetos Git como objects/aa/bb... en el sistema de archivos?

A. Aplicar SHA-1 solo a los blobs
B. Organizar el almacenamiento por tipo de archivo
C. Dividir los objetos en subdirectorios para evitar colisiones de nombres en un solo directorio
D. Agrupar commits y trees en directorios separados por fecha

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Git usa los primeros dos caracteres del hash como subdirectorio para evitar miles de archivos en una sola carpeta (objects/aa/bb...).

ğŸ§  Pregunta 135

Â¿QuÃ© operaciÃ³n interna ejecuta Git cuando haces un commit con git commit -m "mensaje"?

A. Aplica un fast-forward
B. Crea un nuevo objeto commit que apunta a un Ã¡rbol (tree), guarda su hash y actualiza HEAD
C. Crea una nueva rama y borra la anterior
D. Duplica el snapshot anterior si no hay cambios

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Git toma un snapshot del estado actual (tree), crea un nuevo commit que lo referencia, y actualiza HEAD a este nuevo commit.

ğŸ§  Pregunta 136

Â¿Por quÃ© Git puede detectar alteraciones incluso en commits antiguos, aunque los datos estÃ©n comprimidos en un packfile?

A. Porque los commits antiguos se eliminan automÃ¡ticamente
B. Porque cada objeto es cifrado con SHA-256
C. Porque la estructura de Merkle propaga cambios hacia arriba y cada objeto estÃ¡ indexado por su hash
D. Porque Git guarda una copia del objeto original en .git/tmp

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: En un Ã¡rbol de Merkle, si se altera un blob antiguo, el cambio propaga hashes hacia arriba; al verificar el commit, se detecta la inconsistencia.

ğŸ§  Pregunta 137

Â¿CuÃ¡l es la diferencia clave entre git fetch y git pull en un sistema distribuido?

A. fetch borra ramas remotas antiguas, pull no
B. fetch requiere internet, pull es local
C. fetch solo descarga los cambios, pull los descarga y fusiona
D. pull solo se puede ejecutar desde main

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: git fetch solo actualiza las referencias remotas en local; git pull incluye un fetch y un merge o rebase segÃºn configuraciÃ³n.

ğŸ§  Pregunta 138


C1â”€â”€C2â”€â”€C3
      \
       C4â”€â”€C5 (HEAD)
Â¿QuÃ© tipo de estructura representa este historial de Git?

A. Un Ã¡rbol AVL
B. Un DAG (grafo acÃ­clico dirigido)
C. Una lista enlazada circular
D. Una estructura hash lineal

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: En Git, el historial se representa como un DAG: cada commit apunta a sus padres, sin ciclos, permitiendo fusiones y ramificaciones.

ğŸ§  Pregunta 139

Â¿QuÃ© tipo de objeto Git contiene la siguiente cabecera comprimida: "tree 1234\0..."?

A. Commit
B. Blob
C. Tag
D. Tree

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: La cabecera "tree <size>\0" es la firma de un objeto tree, que representa la estructura de directorios de un commit.

ğŸ§  Pregunta 140

Si dos commits apuntan al mismo tree, pero tienen distinto author y mensaje, Â¿quÃ© afirmaciÃ³n es verdadera?

A. Ambos commits tienen el mismo hash
B. Ambos commits apuntan al mismo blob
C. Ambos commits tendrÃ¡n distinto hash, aunque el snapshot sea idÃ©ntico
D. Ambos deben estar en ramas diferentes

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El contenido del commit incluye autor, fecha y mensaje. Aunque el tree sea el mismo, el hash del commit cambiarÃ¡ si cambia algÃºn metadato.


ğŸ§  Pregunta 121

En un repositorio Git distribuido, Â¿quÃ© operaciÃ³n es totalmente local y por tanto no requiere conexiÃ³n a la red?

A. git push origin main
B. git fetch --all
C. git log --graph --oneline
D. git pull --rebase

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El historial completo estÃ¡ en el clon local; git log sÃ³lo lee objetos del directorio .git, sin conectarse al servidor.

ğŸ§  Pregunta 122

function verify_subgraph(root):
    if root in trusted_cache:
        return True
    for child in root.parents:
        if not verify_subgraph(child):
            return False
    return check_hash(root)
Â¿CuÃ¡l es la complejidad temporal en el peor caso, si el DAG tiene N commits y no hay entradas en trusted_cache?

A. O(1)
B. O(log N)
C. O(N)
D. O(NÂ²)

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La funciÃ³n visita cada nodo exactamente una vez (profundidad primero) y realiza una comprobaciÃ³n de hash constante por nodo â‡’ O(N).

ğŸ§  Pregunta 123

SupÃ³n que un blob cambia dentro de un subdirectorio profundo.
Â¿CuÃ¡l es la cadena correcta de propagaciÃ³n de hashes en el Ã¡rbol de Merkle de Git?

A. Commit â†’ Tree â†’ Blob
B. Blob â†’ Tree padre(s) â†’ Commit
C. Tree â†’ Blob â†’ Commit
D. Commit â†’ Blob â†’ Tree

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El cambio altera primero el blob, luego el tree que lo contiene, y finalmente el commit que referencia ese tree.

ğŸ§  Pregunta 124

Â¿Por quÃ© los packfiles mejoran la velocidad de clonaciÃ³n de repositorios grandes?

A. Evitan la propagaciÃ³n de hashes entre objetos
B. Agrupan y comprimen objetos, reduciendo el nÃºmero de transferencias y bytes enviados
C. Convierten SHA-1 a SHA-256 para acelerar el cÃ¡lculo
D. Eluden la creaciÃ³n de deltas entre versiones

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Un Ãºnico archivo comprimido con miles de objetos minimiza rondas de E/S y datos transmitidos, acelerando clone y fetch.

ğŸ§  Pregunta 125

Si dos entradas diferentes produjeran el mismo hash SHA-1 en Git, se hablarÃ­a de:

A. Propiedad de avalancha
B. Ciclo en el DAG
C. ColisiÃ³n criptogrÃ¡fica
D. Fast-forward automÃ¡tico

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Una colisiÃ³n ocurre cuando dos contenidos distintos generan el mismo hash; este riesgo motivÃ³ la migraciÃ³n hacia SHA-256.

ğŸ§  Pregunta 126

C1â”€â”€C2â”€â”€C3â”€â”€C4 (main)
      â”‚
      â–¼
     C5â”€â”€C6 (topic)
Si estando en topic se ejecuta git merge main y no existen conflictos, Â¿cuÃ¡ntos padres tendrÃ¡ el commit de merge resultante?

A. 0
B. 1
C. 2
D. 3

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Un merge normal crea un nuevo commit con dos referencias de padre: la punta de topic (C6) y la de main (C4).

ğŸ§  Pregunta 127

Â¿CuÃ¡l es la ventaja de almacenar objetos sueltos frente a usar sÃ³lo packfiles?

A. VerificaciÃ³n de integridad mÃ¡s robusta
B. Mayor velocidad para escribir commits recientes antes de la prÃ³xima compactaciÃ³n
C. Menor nÃºmero de inodos en disco
D. Transferencias de red mÃ¡s rÃ¡pidas

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Git escribe objetos nuevos como archivos sueltos para evitar descomprimir y reempacar constantemente; luego git gc los agrupa.

ğŸ§  Pregunta 128

Al ejecutar git fsck --full, Git recorre el historial y:

A. Calcula nuevamente cada hash para detectar corrupciÃ³n
B. Elimina ramas remotas sin tracking
C. Reescribe los blobs aplicando delta encoding
D. Convierten SHA-1 a SHA-256 automÃ¡ticamente

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: git fsck verifica la integridad recalculando hashes y asegurando que las referencias (pads, trees, commits) sean coherentes.

ğŸ§  Pregunta 129

Â¿QuÃ© caracterÃ­stica del DAG impide que se produzcan ciclos en el historial de Git?

A. Cada commit tiene un hash Ãºnico
B. Los merges requieren al menos tres ramas
C. Las aristas siempre apuntan del hijo al padre, garantizando una direcciÃ³n temporal Ãºnica
D. Los packfiles descartan commits duplicados

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El DAG es acÃ­clico porque los punteros de commit siempre miran a padres anteriores; nunca se permite un enlace que vuelva al futuro.

ğŸ§  Pregunta 130

Durante la transiciÃ³n gradual de SHA-1 a SHA-256, Git mantiene compatibilidad con repos antiguos.
Â¿CuÃ¡l es el mecanismo que mejor facilita esta coexistencia?

A. Almacenar ambos hashes dentro de un Ãºnico objeto Git
B. Mantener repos SHA-1 y SHA-256 en carpetas .git separadas
C. Registrar el algoritmo en el encabezado del commit y traducir en tiempo real cuando se intercambian objetos
D. Renombrar todas las ramas para indicar el tipo de hash

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Cada objeto contiene un header que especifica el algoritmo; al intercambiar datos, Git interpreta el tipo y puede convertir o verificar acorde.

ğŸ§  Pregunta 141

Â¿QuÃ© ocurre si un solo carÃ¡cter cambia en el contenido de un archivo versionado por Git?

A. Solo cambia el commit
B. Se cambia el blob, pero los trees y commits no se ven afectados
C. Se cambia el blob, los trees padres y todos los commits que lo referencian
D. Git ignora cambios triviales si son menores de 4 bytes

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Git recalcula el hash del blob afectado, lo que modifica el tree que lo contiene y cualquier commit que lo referencie, debido a la estructura de Merkle.

ğŸ§  Pregunta 142

Â¿CuÃ¡l de los siguientes es un beneficio directo del modelo distribuido de Git?

A. Los archivos se actualizan en tiempo real desde el servidor
B. No se requiere sincronizaciÃ³n entre ramas locales y remotas
C. Cada clon es autÃ³nomo y puede actuar como respaldo completo
D. Las ramas se bloquean para evitar conflictos entre usuarios

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: En Git distribuido, cada clon contiene todo el historial y estructura del repositorio, permitiendo restaurarlo incluso si el servidor original falla.

ğŸ§  Pregunta 143

Â¿CuÃ¡l es el impacto de usar hashes como identificadores Ãºnicos de objetos en Git?

A. Aumenta el tamaÃ±o del repositorio
B. Garantiza la trazabilidad y la integridad del historial
C. Permite que diferentes objetos compartan el mismo contenido
D. Obliga a usar un servidor central para validaciÃ³n

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Cada objeto (blob, tree, commit) es identificado por el hash de su contenido; cualquier alteraciÃ³n genera un hash distinto, asegurando integridad.

ğŸ§  Pregunta 144

Â¿QuÃ© comando de Git puede activar automÃ¡ticamente la creaciÃ³n de packfiles para optimizar almacenamiento?

A. git add
B. git pack
C. git gc
D. git prune

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: git gc (garbage collection) empaqueta objetos sueltos en packfiles, eliminando redundancias y optimizando espacio y acceso.

ğŸ§  Pregunta 145

Â¿QuÃ© ventaja aporta el uso de Merkle Trees en la base de datos interna de Git?

A. Permiten evitar la creaciÃ³n de ramas locales
B. Eliminan la necesidad de conflictos de merge
C. Aseguran que cualquier cambio en archivos se refleje en los objetos ascendentes
D. Facilitan la ejecuciÃ³n de git stash con cambios parciales

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: En un Ã¡rbol de Merkle, un cambio en un archivo se refleja en su blob, luego en el tree, y finalmente en el commit, permitiendo trazabilidad precisa.

ğŸ§  Pregunta 146

Â¿QuÃ© diferencia principal existe entre blobs y trees en Git?

A. Los blobs representan carpetas; los trees, commits
B. Los blobs son archivos individuales; los trees son estructuras de directorios
C. Los blobs contienen metadatos; los trees contienen contenido
D. Los blobs cambian con cada merge; los trees nunca cambian

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Un blob es un archivo (contenido plano), mientras que un tree representa una carpeta y contiene referencias a blobs y otros trees.

ğŸ§  Pregunta 147

Â¿Por quÃ© Git utiliza una estrategia de compresiÃ³n + delta encoding en los packfiles?

A. Para reducir el tamaÃ±o y evitar guardar versiones completas redundantes
B. Para proteger los objetos del acceso no autorizado
C. Para encriptar el contenido en trÃ¡nsito
D. Para forzar el uso de GitHub como servidor remoto

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: Git guarda solo las diferencias entre objetos similares (delta encoding) y luego los comprime (zlib), ahorrando espacio y ancho de banda.

ğŸ§  Pregunta 148

Si se cambia el algoritmo de hashing de un repositorio Git de SHA-1 a SHA-256, Â¿quÃ© se debe garantizar para mantener la compatibilidad?

A. Convertir todos los blobs a JSON
B. AÃ±adir un campo temporal a cada commit
C. Incluir en cada objeto el tipo de hash usado en su encabezado
D. Reescribir completamente el historial con filter-branch

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Git incluye el tipo de algoritmo en la cabecera del objeto para poder verificar su integridad, aunque se mezclen SHA-1 y SHA-256.

ğŸ§  Pregunta 149

En un DAG de Git, Â¿quÃ© representa una rama colgante?

A. Una rama sin commits
B. Una rama que no ha sido mergeada y no converge con otras
C. Un objeto corrupto sin referencia
D. Un blob con mÃºltiples trees

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Una rama colgante es una secuencia de commits sin conexiÃ³n a la lÃ­nea principal del historial (por ejemplo, ramas olvidadas o abandonadas).

ğŸ§  Pregunta 150

Â¿CuÃ¡l de los siguientes comandos permite recuperar la integridad del historial en un repositorio Git, tras un error del sistema de archivos?

A. git reset --hard
B. git stash apply
C. git fsck --full
D. git push --force

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: git fsck --full verifica todos los objetos del repositorio, recalculando hashes y alertando sobre corrupciÃ³n o enlaces rotos.

