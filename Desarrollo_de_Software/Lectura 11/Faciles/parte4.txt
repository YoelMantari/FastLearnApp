ğŸ§  Pregunta 1

Â¿CuÃ¡l es la principal ventaja de que Git sea un sistema de control de versiones "distribuido"?

A. Requiere de una conexiÃ³n constante a un servidor central para realizar la mayorÃ­a de las operaciones.

B. Permite que solo el servidor central tenga una copia completa del historial del proyecto.

C. Cada desarrollador tiene una copia completa del repositorio, incluyendo el historial, lo que permite trabajar offline y tener redundancia de datos.

D. Simplifica la gestiÃ³n de un Ãºnico flujo de trabajo lineal para todo el equipo.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El texto destaca que la naturaleza distribuida de Git implica que cada clon contiene el historial completo, permitiendo operaciones locales sin conexiÃ³n y ofreciendo mÃºltiples puntos de respaldo.

ğŸ§  Pregunta 2

Â¿QuÃ© distingue al modelo de funcionamiento de Git en comparaciÃ³n con sistemas de control de versiones centralizados como Subversion (SVN)?

A. Git depende de un servidor central para todas las operaciones, mientras que SVN permite operaciones locales.

B. En Git, cada desarrollador tiene una copia completa del repositorio, mientras que en SVN los desarrolladores trabajan directamente sobre el repositorio central.

C. SVN utiliza un modelo peer-to-peer, similar a una red de iguales, donde cada copia es autÃ³noma.

D. Git requiere una conexiÃ³n a internet activa para realizar commits y navegar por el historial, a diferencia de SVN.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: El texto explica claramente que Git sigue un modelo distribuido donde cada clon es una rÃ©plica completa, a diferencia del modelo centralizado de SVN donde se interactÃºa directamente con un servidor.

ğŸ§  Pregunta 3

Â¿CuÃ¡l es la funciÃ³n principal de un Grafo AcÃ­clico Dirigido (DAG) en la arquitectura interna de Git?

A. Almacenar el contenido de los archivos del proyecto en diferentes versiones.

B. Garantizar la integridad de los datos mediante la verificaciÃ³n de hashes.

C. Organizar el historial de commits, mostrando las relaciones de dependencia y la direcciÃ³n temporal de los cambios.

D. Comprimir los objetos del repositorio para ahorrar espacio en disco.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La lectura describe el DAG como la estructura que representa el historial de commits, con nodos para cada commit y flechas indicando las relaciones entre ellos, siempre en una direcciÃ³n temporal.

ğŸ§  Pregunta 4

Â¿De quÃ© manera los Ã¡rboles de Merkle contribuyen a la funcionalidad de Git?

A. Permiten la creaciÃ³n de ramas y la fusiÃ³n de cambios de manera eficiente.

B. Facilitan la comparaciÃ³n del contenido de diferentes versiones de los archivos.

C. Aseguran la integridad de los datos al calcular un hash Ãºnico para cada objeto (blob, tree, commit) y sus relaciones.

D. Optimizan el almacenamiento de datos al guardar solo las diferencias entre archivos.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El texto explica que los Ã¡rboles de Merkle, con su sistema de hashes encadenados, permiten a Git verificar la integridad del contenido del repositorio en cada punto del historial.

ğŸ§  Pregunta 5

Â¿QuÃ© propÃ³sito fundamental cumplen los algoritmos de hashing criptogrÃ¡fico, como SHA-1 (histÃ³ricamente) y SHA-256 (actualmente en transiciÃ³n), dentro de Git?

A. Facilitar la compresiÃ³n de los archivos del repositorio para reducir el espacio de almacenamiento.

B. Permitir la comunicaciÃ³n segura entre diferentes repositorios remotos.

C. Identificar de manera Ãºnica cada objeto (commit, archivo, directorio) basÃ¡ndose en su contenido y verificar su integridad.

D. Organizar la estructura de directorios y archivos dentro del repositorio.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La lectura detalla cÃ³mo los algoritmos de hash generan identificadores Ãºnicos para cada objeto, asegurando que cualquier cambio en el contenido se refleje en un hash diferente, lo que permite la verificaciÃ³n de la integridad.

ğŸ§  Pregunta 6

Â¿CuÃ¡l es el principal beneficio de utilizar "delta encoding" en Git?

A. Permite identificar y fusionar automÃ¡ticamente ramas con cambios conflictivos.

B. Reduce la necesidad de almacenar copias completas de archivos en cada versiÃ³n, guardando solo las diferencias entre ellas, lo que ahorra espacio.

C. Facilita la navegaciÃ³n a travÃ©s del historial de commits al mostrar solo los cambios significativos.

D. Mejora la seguridad del repositorio al cifrar el contenido de los archivos.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: El texto explica que el delta encoding optimiza el almacenamiento al guardar Ãºnicamente las modificaciones entre versiones de los archivos.

ğŸ§  Pregunta 7

Â¿QuÃ© es un "packfile" en Git y cuÃ¡l es su principal ventaja?

A. Es un archivo de texto que contiene los metadatos del repositorio, como las ramas y las etiquetas.

B. Es un archivo binario que agrupa mÃºltiples objetos del repositorio en un solo contenedor comprimido, facilitando la transferencia y el almacenamiento eficiente.

C. Es un registro de todos los comandos de Git ejecutados por los usuarios.

D. Es una copia de seguridad completa del repositorio que se crea periÃ³dicamente.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La lectura describe los packfiles como archivos comprimidos que contienen mÃºltiples objetos, lo que optimiza el almacenamiento y la velocidad de las operaciones.

ğŸ§  Pregunta 8

Â¿CuÃ¡l es el objetivo principal de la estrategia de fusiÃ³n "recursiva" (recursive merge) en Git?

A. Fusionar tres o mÃ¡s ramas simultÃ¡neamente en un solo commit.

B. Identificar el ancestro comÃºn entre dos ramas y combinar los cambios realizados en cada una desde ese punto.

C. Aplicar commits especÃ­ficos de una rama a otra sin fusionar la rama completa.

D. Reescribir el historial de una rama para que parezca que se desarrollÃ³ directamente desde otra.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: El texto explica que la fusiÃ³n recursiva compara los cambios en dos ramas desde su ancestro comÃºn para integrarlos.

ğŸ§  Pregunta 9

Â¿En quÃ© situaciÃ³n serÃ­a mÃ¡s apropiado utilizar la estrategia de fusiÃ³n "octopus" en Git?

A. Cuando se necesita integrar una rama de caracterÃ­sticas pequeÃ±a en la rama principal.

B. Cuando se deben fusionar dos ramas que tienen cambios conflictivos en las mismas lÃ­neas de cÃ³digo.

C. Cuando se quieren integrar mÃºltiples ramas de caracterÃ­sticas listas para ser unidas a una rama de desarrollo o en un release.

D. Cuando se desea limpiar el historial de commits de una rama antes de fusionarla.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La lectura indica que la fusiÃ³n octopus estÃ¡ diseÃ±ada para la integraciÃ³n simultÃ¡nea de varias ramas, especialmente en escenarios como la preparaciÃ³n de un release.

ğŸ§  Pregunta 10

Â¿QuÃ© utilidad ofrece el "rebase interactivo" (git rebase -i) en Git antes de fusionar una rama?

A. Permite deshacer commits ya realizados en la rama principal.

B. Facilita la resoluciÃ³n automÃ¡tica de conflictos de fusiÃ³n complejos.

C. Permite reordenar, editar mensajes, combinar o eliminar commits en una rama para mantener un historial mÃ¡s limpio y lÃ³gico.

D. Permite seleccionar commits especÃ­ficos de otra rama para integrarlos en la rama actual.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El texto describe el rebase interactivo como una herramienta para manipular el historial de una rama antes de la fusiÃ³n, con el objetivo de obtener un historial mÃ¡s claro.


ğŸ§  Pregunta 11

Â¿CuÃ¡l es una de las ventajas clave de que cada clon de Git sea un repositorio autÃ³nomo con el historial completo?

A. Requiere menos espacio de almacenamiento en las mÃ¡quinas individuales de los desarrolladores.

B. Permite que solo los usuarios con permisos especiales puedan ver el historial completo del proyecto.

C. Posibilita realizar operaciones como commits y visualizaciÃ³n del historial sin necesidad de conexiÃ³n a internet.

D. Asegura que todos los desarrolladores trabajen siempre sobre la misma copia del repositorio en tiempo real.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La naturaleza distribuida permite la independencia de la conexiÃ³n para muchas operaciones locales.

ğŸ§  Pregunta 12

En un modelo de control de versiones centralizado, Â¿quÃ© ocurre si el servidor central falla?

A. Los desarrolladores pueden seguir trabajando localmente sin ninguna interrupciÃ³n.

B. Se pierde el acceso al historial del proyecto y la capacidad de realizar nuevas operaciones hasta que se restaure el servidor.

C. Cada desarrollador puede designar su copia local como el nuevo servidor central.

D. El sistema automÃ¡ticamente replica el repositorio en las mÃ¡quinas de todos los desarrolladores.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La dependencia del servidor central es una vulnerabilidad de los sistemas centralizados.

ğŸ§  Pregunta 13

Â¿QuÃ© significa que el DAG en Git no tiene ciclos ("acÃ­clico")?

A. Que los commits siempre se organizan en una Ãºnica lÃ­nea temporal sin ramificaciones.

B. Que no es posible volver a un commit anterior siguiendo las relaciones de dependencia.

C. Que el historial de commits siempre avanza hacia adelante, sin bucles ni referencias circulares.

D. Que las fusiones de ramas siempre crean un nuevo commit sin alterar el historial de las ramas originales.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La propiedad acÃ­clica del DAG asegura una direcciÃ³n temporal clara y evita confusiones en el historial.

ğŸ§  Pregunta 14

Â¿CÃ³mo se relaciona el hash SHA-1 (o SHA-256) de un commit con el contenido del proyecto en ese momento?

A. El hash es independiente del contenido y se genera secuencialmente.

B. El hash se calcula basÃ¡ndose en el contenido de los archivos, los Ã¡rboles de directorios y el commit mismo, actuando como una huella digital.

C. El hash se utiliza Ãºnicamente para identificar al autor del commit.

D. El hash indica la fecha y hora exacta en que se realizÃ³ el commit.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: El hash se deriva del contenido, garantizando la integridad y la identificaciÃ³n Ãºnica del estado del proyecto.

ğŸ§  Pregunta 15

Â¿Por quÃ© la resistencia a colisiones es una propiedad importante de los algoritmos de hashing criptogrÃ¡fico utilizados por Git?

A. Asegura que la compresiÃ³n de los archivos sea mÃ¡s eficiente.

B. Permite que diferentes objetos en el repositorio tengan el mismo identificador sin causar problemas.

C. Hace extremadamente difÃ­cil encontrar dos entradas distintas (por ejemplo, dos versiones diferentes de un archivo) que produzcan el mismo hash, lo que podrÃ­a comprometer la integridad del sistema.

D. Facilita la bÃºsqueda rÃ¡pida de objetos dentro del repositorio.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La resistencia a colisiones es crucial para la seguridad y la integridad de la identificaciÃ³n Ãºnica de los objetos.

ğŸ§  Pregunta 16

Â¿CuÃ¡l es la principal razÃ³n por la que Git estÃ¡ migrando gradualmente de SHA-1 a SHA-256?

A. SHA-256 produce hashes mÃ¡s cortos y fÃ¡ciles de recordar.

B. SHA-256 es mÃ¡s rÃ¡pido en el cÃ¡lculo de hashes, mejorando el rendimiento de Git.

C. Se han descubierto vulnerabilidades teÃ³ricas y prÃ¡cticas en SHA-1 que podrÃ­an comprometer la seguridad.

D. SHA-256 es un estÃ¡ndar mÃ¡s antiguo y probado que SHA-1.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La migraciÃ³n se debe a las preocupaciones de seguridad relacionadas con las vulnerabilidades encontradas en SHA-1.

ğŸ§  Pregunta 17

Â¿CÃ³mo contribuye el uso de hashes a la capacidad de Git para detectar modificaciones no autorizadas o errores accidentales en los archivos?

A. Al cifrar el contenido de los archivos, impidiendo que sean alterados sin la clave correcta.

B. Al registrar la fecha y hora de la Ãºltima modificaciÃ³n de cada archivo.

C. Al calcular un hash Ãºnico basado en el contenido de cada archivo; cualquier cambio en el contenido alterarÃ¡ el hash, lo que Git puede detectar.

D. Al comparar el tamaÃ±o de los archivos entre diferentes versiones del repositorio.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La alteraciÃ³n del contenido siempre resulta en un hash diferente, lo que permite la detecciÃ³n de cambios.

ğŸ§  Pregunta 18

Â¿QuÃ© tipo de objetos se almacenan en un packfile de Git?

A. Solo las diferencias (deltas) entre las versiones de los archivos.

B. Solo las versiones completas de los archivos mÃ¡s recientes.

C. Una combinaciÃ³n de objetos completos (commits, blobs, trees, tags) y sus diferencias (deltas) para optimizar el almacenamiento.

D. Solo los metadatos del repositorio, como el historial de commits y las ramas.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: Los packfiles contienen tanto objetos completos como deltas para maximizar la eficiencia del almacenamiento.

ğŸ§  Pregunta 19

Â¿QuÃ© funciÃ³n cumple el archivo Ã­ndice (.idx) asociado a un packfile en Git?

A. Contiene la lista de todos los autores de los commits incluidos en el packfile.

B. Almacena la informaciÃ³n sobre la estructura de directorios del repositorio en el momento en que se creÃ³ el packfile.

C. Sirve como un Ã­ndice para localizar rÃ¡pidamente objetos dentro del packfile, mejorando el rendimiento de las operaciones de Git.

D. Contiene las instrucciones para descomprimir los objetos almacenados en el packfile.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El archivo .idx permite un acceso rÃ¡pido a los objetos dentro del packfile.

ğŸ§  Pregunta 20

Â¿En quÃ© situaciones Git podrÃ­a optar por almacenar un objeto completo en un packfile en lugar de un delta?

A. Cuando el objeto es muy pequeÃ±o.

B. Cuando el objeto es la primera versiÃ³n de un archivo y no tiene una versiÃ³n anterior para comparar.

C. Cuando el objeto ha sido modificado muchas veces y calcular el delta serÃ­a mÃ¡s costoso que almacenar el objeto completo.

D. Todas las anteriores.

âœ… Correcta: D

ğŸ§¾ ExplicaciÃ³n: Git evalÃºa la eficiencia y puede almacenar objetos completos en diversas situaciones.

ğŸ§  Pregunta 21

Â¿CuÃ¡l es el primer paso que realiza Git al intentar fusionar dos ramas utilizando la estrategia de fusiÃ³n recursiva?

A. Aplicar todos los commits de una rama sobre la otra de forma secuencial.

B. Identificar los commits que son Ãºnicos en cada una de las ramas.

C. Localizar el Ãºltimo commit que ambas ramas tienen en comÃºn, conocido como el ancestro comÃºn o merge base.

D. Comparar el nÃºmero total de commits en cada rama para determinar la estrategia de fusiÃ³n mÃ¡s adecuada.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: Encontrar el ancestro comÃºn es fundamental para determinar los cambios a fusionar.

ğŸ§  Pregunta 22

Â¿QuÃ© indica la presencia de marcadores como <<<<<<<, =======, y >>>>>>> en un archivo despuÃ©s de un intento de fusiÃ³n en Git?

A. Que la fusiÃ³n se ha completado exitosamente sin ningÃºn conflicto.

B. Que Git ha detectado cambios conflictivos en esa secciÃ³n del archivo que requieren resoluciÃ³n manual por parte del desarrollador.

C. Que el archivo ha sido marcado para su eliminaciÃ³n despuÃ©s de la fusiÃ³n.

D. Que Git estÃ¡ esperando la confirmaciÃ³n del usuario para aplicar los cambios fusionados.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Estos marcadores delimitan las secciones conflictivas que necesitan intervenciÃ³n manual.

ğŸ§  Pregunta 23

Â¿CuÃ¡l es una limitaciÃ³n importante del algoritmo de fusiÃ³n "octopus" al fusionar mÃºltiples ramas?

A. Solo puede fusionar un mÃ¡ximo de tres ramas a la vez.

B. No es capaz de manejar conflictos entre mÃ¡s de dos ramas de forma automÃ¡tica.

C. Requiere que todas las ramas a fusionar tengan un ancestro comÃºn directo.

D. Solo se puede utilizar en repositorios con un historial lineal sin ramificaciones previas.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La fusiÃ³n octopus no resuelve conflictos complejos entre mÃºltiples ramas automÃ¡ticamente.

ğŸ§  Pregunta 24

Â¿CuÃ¡l es el principal propÃ³sito de utilizar git rebase -i antes de fusionar una rama de caracterÃ­sticas a la rama principal?

A. Asegurarse de que la rama principal estÃ© actualizada con los Ãºltimos cambios de la rama de caracterÃ­sticas.

B. Integrar todos los commits de la rama principal en la rama de caracterÃ­sticas.

C. Manipular el historial de la rama de caracterÃ­sticas para que sea mÃ¡s limpio y lineal antes de integrarlo en la rama principal.

D. Eliminar permanentemente la rama de caracterÃ­sticas despuÃ©s de la fusiÃ³n.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El rebase interactivo se usa para limpiar y reorganizar el historial de la rama de caracterÃ­sticas.

ğŸ§  Pregunta 25

Â¿En quÃ© escenario serÃ­a mÃ¡s Ãºtil la herramienta git cherry-pick?

A. Para fusionar todas las ramas de un repositorio en una sola.

B. Para revertir un commit especÃ­fico en la rama actual.

C. Para aplicar un commit particular de otra rama a la rama actual sin necesidad de fusionar toda la rama.

D. Para comparar los cambios entre dos commits consecutivos en la misma rama.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: Cherry-pick permite seleccionar e integrar commits individuales.

ğŸ§  Pregunta 26

Â¿CuÃ¡l es la diferencia fundamental entre git revert y git reset?

A. git revert se utiliza para deshacer cambios en archivos individuales, mientras que git reset afecta a commits completos.

B. git revert crea un nuevo commit que anula los cambios de un commit anterior, preservando el historial, mientras que git reset mueve el HEAD a un commit anterior, potencialmente alterando el historial.

C. git revert solo se puede usar en ramas locales, mientras que git reset se utiliza para deshacer cambios en ramas remotas.

D. git revert requiere una conexiÃ³n a internet, mientras que git reset es una operaciÃ³n local.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Revert crea un nuevo commit para deshacer, mientras que reset modifica el historial.

ğŸ§  Pregunta 27

Â¿QuÃ© tipo de informaciÃ³n se puede visualizar y manipular utilizando herramientas de interfaz grÃ¡fica (GUIs) para Git al resolver conflictos de fusiÃ³n?

A. Solo el contenido textual de los archivos conflictivos.

B. Las diferencias entre las ramas en conflicto de forma visual, permitiendo elegir quÃ© cambios conservar de cada rama de manera mÃ¡s intuitiva.

C. El nÃºmero de lÃ­neas modificadas en cada rama y el autor de los cambios.

D. La fecha y hora exacta de cada modificaciÃ³n en las ramas conflictivas.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Las GUIs facilitan la comparaciÃ³n visual y la selecciÃ³n de los cambios deseados.

ğŸ§  Pregunta 28

Â¿CÃ³mo contribuye la estructura del DAG a la eficiencia de las operaciones de fusiÃ³n en Git?

A. Permite comprimir el historial de commits para acelerar la comparaciÃ³n de ramas.

B. Facilita la identificaciÃ³n rÃ¡pida del ancestro comÃºn entre las ramas que se van a fusionar.

C. Asegura que las fusiones siempre se realicen de forma automÃ¡tica sin necesidad de intervenciÃ³n manual.

D. Permite reordenar los commits de diferentes ramas antes de la fusiÃ³n para evitar conflictos.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: El DAG estructura el historial de manera que el ancestro comÃºn puede encontrarse eficientemente.

ğŸ§  Pregunta 29

Â¿De quÃ© manera el uso de packfiles puede mejorar el rendimiento de un git clone de un repositorio grande?

A. Al descargar los objetos de forma individual, permitiendo una descarga mÃ¡s granular.

B. Al comprimir y empaquetar todos los objetos en un solo archivo para su transferencia, reduciendo el nÃºmero de conexiones y el tamaÃ±o total de la descarga.

C. Al descargar solo las ramas mÃ¡s recientes del repositorio.

D. Al verificar la integridad de cada objeto individualmente antes de descargarlo.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Los packfiles optimizan la transferencia al consolidar y comprimir los objetos.

ğŸ§  Pregunta 30

Â¿CuÃ¡l es la implicaciÃ³n de que Git trate a cada commit como una instantÃ¡nea del proyecto en un momento dado?

A. Que cada commit contiene una copia completa de todos los archivos del proyecto en ese estado.

B. Que Git solo guarda las diferencias entre commits para ahorrar espacio de almacenamiento.

C. Que es imposible volver a un estado anterior del proyecto representado por un commit.

D. Que los commits no estÃ¡n relacionados entre sÃ­ y se pueden manipular de forma independiente sin afectar al resto del historial.

âœ… Correcta: A

ğŸ§¾ ExplicaciÃ³n: Cada commit representa un estado completo del proyecto en el momento de su creaciÃ³n.

ğŸ§  Pregunta 31

Â¿QuÃ© ventaja ofrece el modelo peer-to-peer de Git en tÃ©rminos de resiliencia y seguridad de los datos?

A. Depender de un Ãºnico servidor central asegura la consistencia de los datos.

B. La replicaciÃ³n completa del historial en mÃºltiples mÃ¡quinas permite la recuperaciÃ³n del proyecto si el servidor original falla.

C. La necesidad de una conexiÃ³n constante a internet protege el repositorio de accesos no autorizados.

D. La estructura jerÃ¡rquica del sistema facilita la gestiÃ³n de permisos y el control de acceso.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La distribuciÃ³n del repositorio en mÃºltiples clones proporciona redundancia y facilita la recuperaciÃ³n en caso de fallos.

ğŸ§  Pregunta 32

Â¿CÃ³mo influye la estructura del DAG en la capacidad de Git para realizar fusiones eficientes?

A. Permite comparar el contenido de los archivos lÃ­nea por lÃ­nea de forma mÃ¡s rÃ¡pida.

B. Facilita la identificaciÃ³n del ancestro comÃºn mÃ¡s reciente entre las ramas que se van a fusionar.

C. Asegura que los commits se fusionen en el orden cronolÃ³gico exacto en que fueron creados.

D. Permite comprimir los commits antes de la fusiÃ³n para reducir el tamaÃ±o del historial.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La estructura del DAG facilita la bÃºsqueda del punto de divergencia entre las ramas.

ğŸ§  Pregunta 33

Â¿QuÃ© implicaciÃ³n tiene el hecho de que los hashes en Git dependan del contenido de los objetos?

A. Que los hashes son predecibles y fÃ¡ciles de memorizar.

B. Que cualquier modificaciÃ³n en el contenido de un objeto resultarÃ¡ en un hash diferente, lo que permite la detecciÃ³n de cambios.

C. Que objetos diferentes siempre tendrÃ¡n el mismo hash si fueron creados por el mismo autor.

D. Que los hashes solo se utilizan internamente y no son relevantes para el usuario.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La dependencia del contenido asegura la integridad y la trazabilidad a travÃ©s de los hashes Ãºnicos.

ğŸ§  Pregunta 34

Â¿CuÃ¡l es el principal desafÃ­o que la transiciÃ³n de SHA-1 a SHA-256 presenta para el ecosistema de Git?

A. La necesidad de cambiar todos los hashes existentes en los repositorios antiguos.

B. Asegurar la compatibilidad y la interoperabilidad entre repositorios y herramientas que aÃºn utilizan SHA-1 y aquellos que han migrado a SHA-256.

C. El aumento significativo en el tamaÃ±o de los hashes, lo que requiere mÃ¡s espacio de almacenamiento.

D. La pÃ©rdida de la capacidad de identificar objetos duplicados en el repositorio.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La coexistencia de ambos algoritmos requiere una gestiÃ³n cuidadosa de la compatibilidad.

ğŸ§  Pregunta 35

Â¿CÃ³mo optimiza el delta encoding las transferencias de datos en operaciones como git fetch o git pull?

A. Al comprimir todos los objetos del repositorio en un Ãºnico archivo antes de la transferencia.

B. Al enviar solo las diferencias entre los objetos que el receptor ya tiene y las nuevas versiones, en lugar de enviar los objetos completos.

C. Al priorizar la descarga de los commits mÃ¡s recientes.

D. Al verificar la integridad de los datos antes de iniciar la transferencia.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Enviar solo las diferencias reduce la cantidad de datos que necesitan ser transferidos.

ğŸ§  Pregunta 36

Â¿QuÃ© sucede durante el proceso de creaciÃ³n de un packfile en Git?

A. Se eliminan los objetos redundantes del repositorio para liberar espacio.

B. Se organiza el historial de commits en un formato lineal y secuencial.

C. Se identifican los objetos necesarios, se calculan las diferencias (deltas) entre ellos y se comprimen en un Ãºnico archivo.

D. Se envÃ­an todos los objetos del repositorio a un servidor remoto para su almacenamiento seguro.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La creaciÃ³n de packfiles implica la identificaciÃ³n, el cÃ¡lculo de deltas y la compresiÃ³n de los objetos.

ğŸ§  Pregunta 37

Â¿Por quÃ© es importante identificar el ancestro comÃºn al realizar una fusiÃ³n con la estrategia recursiva?

A. Para determinar quÃ© rama tiene los cambios mÃ¡s recientes.

B. Para asegurar que los commits se fusionen en el orden correcto de creaciÃ³n.

C. Para comparar los cambios realizados en cada rama desde ese punto y combinarlos de manera inteligente.

D. Para evitar la creaciÃ³n de un nuevo commit de fusiÃ³n.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El ancestro comÃºn es el punto de referencia para entender los cambios introducidos en cada rama.

ğŸ§  Pregunta 38

Â¿CuÃ¡l es una de las principales ventajas de utilizar un rebase interactivo antes de fusionar una rama en un entorno colaborativo?

A. Permite ocultar commits que contienen errores o informaciÃ³n sensible.

B. Facilita la creaciÃ³n de un historial de commits mÃ¡s limpio y lineal en la rama de caracterÃ­sticas, lo que simplifica el seguimiento y la comprensiÃ³n de los cambios al fusionarla con la rama principal.

C. Acelera el proceso de fusiÃ³n al evitar la creaciÃ³n de commits de fusiÃ³n adicionales.

D. Permite fusionar ramas que no tienen un ancestro comÃºn directo.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Un historial limpio facilita la colaboraciÃ³n y la comprensiÃ³n del desarrollo.

ğŸ§  Pregunta 39

Â¿En quÃ© se diferencia git cherry-pick de un git merge normal?

A. git cherry-pick integra todos los commits de una rama, mientras que git merge solo aplica commits especÃ­ficos.

B. git cherry-pick aplica commits especÃ­ficos de una rama a la rama actual, mientras que git merge integra toda una rama en la rama actual.

C. git cherry-pick modifica el historial de la rama de destino, mientras que git merge siempre crea un nuevo commit de fusiÃ³n.

D. git cherry-pick solo se puede utilizar para deshacer commits, mientras que git merge se utiliza para integrar cambios.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Cherry-pick se enfoca en commits individuales, mientras que merge integra ramas completas.

ğŸ§  Pregunta 40

Â¿CuÃ¡l es una buena prÃ¡ctica al usar git reset y por quÃ©?

A. Usarlo frecuentemente en ramas compartidas para mantener el historial limpio para todos.

B. Limitar su uso a ramas locales y privadas, ya que puede reescribir el historial que otros ya han sincronizado, causando problemas.

C. Utilizarlo siempre con la opciÃ³n --hard para asegurar una limpieza completa del historial.

D. Ejecutarlo automÃ¡ticamente despuÃ©s de cada git push para sincronizar el historial local y remoto.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Reescribir el historial en ramas compartidas puede generar inconsistencias y problemas para otros colaboradores.

ğŸ§  Pregunta 41

Â¿CÃ³mo ayuda la verificaciÃ³n de integridad basada en Ã¡rboles de Merkle a la seguridad de un repositorio Git distribuido?

A. Al cifrar el contenido de los archivos, haciÃ©ndolos ilegibles para usuarios no autorizados.

B. Al asegurar que cualquier alteraciÃ³n en cualquier parte del historial (archivos, directorios, commits) se detecte mediante la verificaciÃ³n de los hashes.

C. Al registrar la direcciÃ³n IP de cada usuario que realiza cambios en el repositorio.

D. Al requerir autenticaciÃ³n de dos factores para cada operaciÃ³n de escritura en el repositorio.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La estructura de hashes encadenados permite detectar cualquier manipulaciÃ³n del historial.

ğŸ§  Pregunta 42

Â¿QuÃ© papel juegan los blobs, los Ã¡rboles y los commits en la estructura de datos de Git basada en Ã¡rboles de Merkle?

A. Los blobs representan los metadatos del repositorio, los Ã¡rboles representan los archivos y los commits representan los directorios.

B. Los blobs representan los archivos individuales, los Ã¡rboles representan los directorios que contienen blobs y otros Ã¡rboles, y los commits apuntan a un Ã¡rbol raÃ­z que representa el estado del proyecto en ese momento.

C. Los Ã¡rboles representan las diferentes ramas del repositorio, los blobs representan los commits en cada rama y los commits representan la fusiÃ³n de las ramas.

D. Los blobs, los Ã¡rboles y los commits son simplemente diferentes formas de comprimir los datos del repositorio para ahorrar espacio.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Esta es la jerarquÃ­a fundamental de los objetos en Git.

ğŸ§  Pregunta 43

Â¿CÃ³mo maneja Git los archivos binarios en tÃ©rminos de delta encoding y almacenamiento en packfiles?

A. Los archivos binarios siempre se almacenan como objetos completos en los packfiles, ya que el delta encoding no es efectivo para ellos.

B. Git intenta aplicar delta encoding incluso a archivos binarios, comparando bloques de datos para encontrar similitudes.

C. Los archivos binarios se excluyen automÃ¡ticamente de los packfiles y se almacenan por separado.

D. Git convierte los archivos binarios a formato de texto antes de aplicar el delta encoding y almacenarlos en packfiles.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Git intenta optimizar el almacenamiento incluso de binarios buscando similitudes a nivel de bloques.

ğŸ§  Pregunta 44

Â¿CuÃ¡l es una posible desventaja de utilizar git rebase en ramas compartidas con otros colaboradores?

A. Puede hacer que la rama local se desincronice con la rama remota.

B. Puede reescribir el historial que otros ya han basado su trabajo, generando conflictos y confusiÃ³n.

C. Puede eliminar permanentemente commits importantes del historial.

D. Puede ralentizar significativamente las operaciones de Git.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La reescritura del historial en ramas compartidas es una prÃ¡ctica peligrosa.

ğŸ§  Pregunta 45

Â¿QuÃ© informaciÃ³n esencial contiene un objeto commit en Git?

A. El contenido de todos los archivos del proyecto en ese momento exacto.

B. El nombre del autor, la direcciÃ³n de correo electrÃ³nico, la fecha y hora, un mensaje descriptivo y una referencia al Ã¡rbol (tree) que representa la instantÃ¡nea del proyecto.

C. Una lista de todos los commits realizados posteriormente en la misma rama.

D. Las diferencias (deltas) entre este commit y el commit anterior.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Un commit contiene metadatos importantes sobre el cambio y su contexto.

ğŸ§  Pregunta 46

Â¿CÃ³mo asegura Git la integridad del historial completo del repositorio utilizando los hashes criptogrÃ¡ficos?

A. Al requerir una firma digital para cada commit realizado.

B. Al encadenar los hashes de los commits, donde cada commit apunta al hash de su padre (o padres), de manera que cualquier alteraciÃ³n en un commit cambiarÃ¡ su hash y, por ende, los hashes de todos sus descendientes.

C. Al comparar periÃ³dicamente los hashes de todos los objetos con una copia de seguridad almacenada en un servidor central.

D. Al cifrar el historial completo del repositorio utilizando una clave privada conocida solo por los colaboradores autorizados.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: El encadenamiento de hashes es fundamental para la integridad del historial.

ğŸ§  Pregunta 47

Â¿QuÃ© implicaciones tiene la inmutabilidad de los objetos en Git (una vez creados, su contenido no cambia)?

A. Que es imposible deshacer los cambios realizados en un commit.

B. Que cada cambio siempre resulta en la creaciÃ³n de un nuevo objeto con un hash diferente, lo que facilita el seguimiento y la integridad del historial.

C. Que los objetos deben ser copiados completamente cada vez que se realiza un commit, lo que puede aumentar el uso de espacio en disco.

D. Que los objetos no pueden ser compartidos entre diferentes commits o ramas.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La inmutabilidad asegura la trazabilidad y la consistencia del historial.

ğŸ§  Pregunta 48

Â¿CÃ³mo maneja Git la concurrencia y evita la corrupciÃ³n del repositorio cuando mÃºltiples usuarios realizan operaciones simultÃ¡neamente?

A. Mediante el uso de bloqueos (locks) en los archivos del repositorio.

B. Principalmente a travÃ©s de la naturaleza distribuida, donde los usuarios trabajan en sus copias locales y luego sincronizan los cambios, y mediante mecanismos para la gestiÃ³n de fusiones y conflictos.

C. Al requerir que todas las operaciones pasen por un servidor central que gestiona las transacciones de forma secuencial.

D. Al crear copias temporales del repositorio para cada usuario durante sus operaciones.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La naturaleza distribuida y las herramientas de gestiÃ³n de fusiones son clave para la concurrencia.

ğŸ§  Pregunta 49

Â¿CuÃ¡l es el beneficio de que Git realice la mayorÃ­a de las operaciones de forma local?

A. Reduce la carga en el servidor central del repositorio.

B. Permite realizar operaciones como commits, visualizaciÃ³n del historial y creaciÃ³n de ramas de forma rÃ¡pida, sin la latencia de la red.

C. Asegura que todos los desarrolladores trabajen siempre con la Ãºltima versiÃ³n del repositorio.

D. Simplifica la gestiÃ³n de permisos y el control de acceso al repositorio.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La localidad de las operaciones mejora significativamente la velocidad y la eficiencia.

ğŸ§  Pregunta 50

En un flujo de trabajo de Git tÃ­pico, Â¿cuÃ¡l es el propÃ³sito de una rama de "caracterÃ­sticas" (feature branch)?

A. Almacenar la versiÃ³n estable y principal del cÃ³digo.

B. Aislar el desarrollo de una nueva funcionalidad o correcciÃ³n de errores del cÃ³digo principal, permitiendo trabajar en paralelo sin afectar la estabilidad de la rama principal.

C. Mantener un registro de todos los cambios realizados en el repositorio por un desarrollador especÃ­fico.

D. Facilitar la implementaciÃ³n continua y la entrega continua (CI/CD).

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Las ramas de caracterÃ­sticas son fundamentales para el desarrollo aislado y paralelo.