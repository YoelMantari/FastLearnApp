ğŸ§  Pregunta 1

Â¿CuÃ¡l es una de las principales ventajas de que Git sea un sistema distribuido?

A. Permite trabajar solo cuando se estÃ¡ conectado al servidor central
B. Cada desarrollador necesita acceso constante a internet
C. Cada clon contiene una copia completa del historial del repositorio
D. Obliga a sincronizar en tiempo real con todos los colaboradores

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: En Git, cada clon es un repositorio autÃ³nomo que guarda todo el historial de cambios, ramas y etiquetas, permitiendo trabajar sin conexiÃ³n.

ğŸ§  Pregunta 2

Â¿QuÃ© estructura utiliza Git para organizar internamente los commits y mantener relaciones temporales entre ellos?

A. Ãrbol de Merkle
B. Lista doblemente enlazada
C. Grafo acÃ­clico dirigido (DAG)
D. Pila LIFO

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Git organiza los commits como nodos en un grafo acÃ­clico dirigido (DAG), lo que permite representar relaciones de dependencia sin ciclos y seguir el flujo del tiempo.

ğŸ§  Pregunta 3

Â¿Para quÃ© sirve principalmente el uso de Ã¡rboles de Merkle en Git?

A. Guardar los logs de cada commit
B. Detectar errores de sintaxis automÃ¡ticamente
C. Verificar la integridad del contenido a travÃ©s de hashes
D. Mejorar la compatibilidad con sistemas centralizados

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Git utiliza Ã¡rboles de Merkle para garantizar la integridad del repositorio mediante hashes que se propagan jerÃ¡rquicamente al cambiar el contenido.

ğŸ§  Pregunta 4

Â¿CuÃ¡l de las siguientes afirmaciones sobre los algoritmos de hash usados en Git es correcta?

A. SHA-1 permite revertir el hash para recuperar el contenido original
B. SHA-256 es menos seguro pero mÃ¡s rÃ¡pido que SHA-1
C. Git usa hashes para identificar de forma Ãºnica los objetos
D. Git asigna hashes aleatorios para mayor variabilidad

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Git usa algoritmos de hash (como SHA-1 o SHA-256) para identificar de manera Ãºnica cada objeto en el repositorio segÃºn su contenido.

ğŸ§  Pregunta 5

Â¿CuÃ¡l es una ventaja principal de los packfiles en Git?

A. Requieren mÃ¡s espacio en disco pero aceleran las fusiones
B. Permiten enviar mÃºltiples objetos de forma comprimida y eficiente
C. Eliminar versiones antiguas automÃ¡ticamente
D. Guardar los cambios en un formato legible por humanos

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Los packfiles agrupan objetos del repositorio en un solo archivo comprimido, lo que acelera las transferencias y optimiza el almacenamiento.

ğŸ§  Pregunta 6

Â¿QuÃ© tÃ©cnica utiliza Git para reducir el tamaÃ±o de almacenamiento de versiones similares?

A. Rebase interactivo
B. Hashing paralelo
C. Delta encoding
D. Commit splitting

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Delta encoding almacena solo las diferencias entre versiones, lo que permite a Git ahorrar espacio y optimizar la transferencia de datos.

ğŸ§  Pregunta 7

Â¿CuÃ¡l es una desventaja identificada en el uso de SHA-1 como algoritmo en Git?

A. No se puede usar en sistemas distribuidos
B. Tiene problemas con archivos grandes
C. Se han encontrado colisiones que afectan la seguridad
D. No permite revertir cambios

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: SHA-1 ha sido vulnerado mediante colisiones, lo que puede comprometer la seguridad del contenido si no se actualiza a algoritmos mÃ¡s robustos como SHA-256.

ğŸ§  Pregunta 8

Â¿QuÃ© comando en Git se utiliza para fusionar mÃºltiples ramas al mismo tiempo?

A. git squash
B. git octopus
C. git merge con estrategia octopus
D. git multi-merge

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Git permite usar la estrategia de fusiÃ³n "octopus" con el comando git merge para combinar mÃ¡s de dos ramas simultÃ¡neamente, siempre que no haya conflictos complejos.

ğŸ§  Pregunta 9

Â¿QuÃ© herramienta de Git permite modificar el historial de una rama antes de fusionarla?

A. git cherry-pick
B. git log
C. git gc
D. git rebase -i

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: git rebase -i (interactivo) permite reorganizar, combinar o eliminar commits, lo que facilita mantener un historial limpio y comprensible.

ğŸ§  Pregunta 10

Â¿CuÃ¡l es uno de los principales beneficios del modelo peer-to-peer en Git?

A. Requiere menos memoria RAM
B. Aumenta la dependencia del servidor
C. Permite recuperar el repositorio desde cualquier clon
D. Asegura que solo una persona pueda hacer commits

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Gracias a su naturaleza distribuida, cualquier clon completo del repositorio puede restaurarlo completamente si el servidor principal falla.


ğŸ§  Pregunta 11

Â¿QuÃ© ventaja ofrece Git al permitir trabajar sin conexiÃ³n a internet?

A. Permite que varios desarrolladores trabajen en la misma rama al mismo tiempo
B. Mejora la seguridad de la red del repositorio
C. Permite realizar commits, ver historial y comparar cambios localmente
D. Aumenta la velocidad de los servidores centrales

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Gracias a su arquitectura distribuida, Git permite trabajar de forma completamente local: hacer commits, navegar el historial, y hacer diffs sin conexiÃ³n.

ğŸ§  Pregunta 12

Â¿QuÃ© sucede si se cambia una sola lÃ­nea de un archivo en Git?

A. Solo cambia el commit mÃ¡s reciente
B. Cambia el blob, el Ã¡rbol que lo contiene y el commit correspondiente
C. No hay impacto en la estructura interna del repositorio
D. Solo cambia el Ã¡rbol raÃ­z del proyecto

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Git detecta el cambio en el blob (archivo), lo que cambia el tree (directorio) que lo contiene, y finalmente el commit, propagando el nuevo hash.

ğŸ§  Pregunta 13

Â¿QuÃ© tipo de estructura permite a Git verificar que el historial no ha sido modificado?

A. Ãrbol AVL
B. Grafo cÃ­clico
C. Ãrbol de Merkle
D. Punteros dobles

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Los Ã¡rboles de Merkle en Git permiten verificar la integridad del historial, ya que cualquier modificaciÃ³n en un objeto afecta los hashes ascendentes.

ğŸ§  Pregunta 14

Â¿QuÃ© funciÃ³n cumple el archivo .idx asociado a un packfile?

A. Guarda las instrucciones para deshacer cambios
B. Sirve como Ã­ndice para acceder rÃ¡pidamente a objetos dentro del packfile
C. Contiene logs de actividad
D. Define las ramas existentes en el repositorio

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El archivo .idx acompaÃ±a a un packfile para indexar y permitir el acceso rÃ¡pido a cada objeto comprimido que contiene.

ğŸ§  Pregunta 15

Â¿CuÃ¡l es una caracterÃ­stica clave del algoritmo de hashing que usa Git?

A. Su salida varÃ­a aunque la entrada sea la misma
B. Su salida puede revertirse para obtener el contenido original
C. Cambios mÃ­nimos en la entrada generan un hash totalmente distinto
D. Se usa para cifrar contraseÃ±as de acceso a Git

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Los algoritmos de hash como SHA-1 y SHA-256 tienen la propiedad de avalancha: un pequeÃ±o cambio en la entrada produce un hash completamente diferente.

ğŸ§  Pregunta 16

Â¿Por quÃ© Git es considerado resiliente ante fallos del servidor?

A. Porque sincroniza cambios cada segundo
B. Porque solo permite commits desde el servidor
C. Porque cada clon contiene el historial completo y puede restaurar el repositorio
D. Porque bloquea commits ante errores

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Como Git es distribuido, cualquier clon contiene el historial completo, lo que permite restaurar el repositorio incluso si el servidor original se pierde.

ğŸ§  Pregunta 17

Â¿QuÃ© comando se recomienda para combinar mÃºltiples commits antes de fusionar una rama al main?

A. git cherry-pick
B. git revert
C. git rebase -i
D. git gc

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: git rebase -i permite editar, reordenar o combinar commits (squash), lo que ayuda a mantener un historial limpio antes de fusionar una rama.

ğŸ§  Pregunta 18

Â¿QuÃ© operaciÃ³n realiza git fetch?

A. Fusiona automÃ¡ticamente cambios desde el repositorio remoto
B. Descarga cambios desde el repositorio remoto sin integrarlos
C. Elimina ramas remotas obsoletas
D. Aplica cambios de commits seleccionados manualmente

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: git fetch descarga los cambios del repositorio remoto, pero no los fusiona con la rama actual. Es Ãºtil para revisar los cambios antes de integrarlos.

ğŸ§  Pregunta 19

Â¿CuÃ¡ndo usa Git la estrategia de fusiÃ³n â€œoctopusâ€?

A. Cuando desea revertir commits
B. Cuando se fusionan exactamente dos ramas
C. Cuando se fusionan tres o mÃ¡s ramas sin conflictos
D. Cuando se realiza una rebase interactiva

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La estrategia "octopus" permite fusionar tres o mÃ¡s ramas al mismo tiempo, siempre que no haya conflictos complejos entre ellas.

ğŸ§  Pregunta 20

Â¿CuÃ¡l es una ventaja del uso de delta encoding en Git?

A. Permite crear ramas mÃ¡s rÃ¡pidamente
B. Disminuye el nÃºmero de commits
C. Reduce el uso de disco y acelera la transferencia de datos
D. Evita conflictos en fusiones

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Delta encoding permite que Git almacene y transfiera solo las diferencias entre versiones, reduciendo el espacio en disco y el uso de red.

ğŸ§  Pregunta 21

Â¿QuÃ© ventaja clave ofrece Git al usar un modelo peer-to-peer?

A. Todos los cambios deben pasar por un moderador central
B. Se requiere una red privada para colaborar
C. Todos los desarrolladores tienen la misma jerarquÃ­a y control sobre el repositorio
D. Solo un nodo puede tener acceso al historial completo

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El modelo peer-to-peer de Git elimina jerarquÃ­as fijas, permitiendo que todos los clones tengan el mismo nivel de acceso y control.

ğŸ§  Pregunta 22

Â¿Por quÃ© Git puede detectar corrupciÃ³n o alteraciones en cualquier parte del repositorio?

A. Usa fechas como identificadores Ãºnicos
B. Utiliza claves pÃºblicas para validar ramas
C. Su estructura de Merkle encadena hashes que cambian ante cualquier modificaciÃ³n
D. Mantiene una copia cifrada de cada versiÃ³n

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Cualquier cambio en un archivo afecta su hash, lo que altera todos los hashes ascendentes en el Ã¡rbol de Merkle, permitiendo detectar cambios no autorizados.

ğŸ§  Pregunta 23

Â¿CuÃ¡l de los siguientes comandos modifica directamente el historial de commits?

A. git fetch
B. git push
C. git rebase
D. git log

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: git rebase reescribe el historial de commits, especialmente Ãºtil para mantener una lÃ­nea de tiempo limpia antes de una fusiÃ³n.

ğŸ§  Pregunta 24

Â¿QuÃ© identifica de forma Ãºnica a cada commit en Git?

A. Su fecha de creaciÃ³n
B. La rama en la que fue creado
C. El mensaje de commit
D. Su hash criptogrÃ¡fico

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: Cada commit en Git estÃ¡ identificado por un hash generado a partir de su contenido y metadatos, asegurando unicidad e integridad.

ğŸ§  Pregunta 25

Â¿QuÃ© es git cherry-pick?

A. Un comando para crear ramas nuevas
B. Un mÃ©todo para deshacer varios commits
C. Un comando que aplica commits especÃ­ficos de otra rama
D. Una estrategia de fusiÃ³n automÃ¡tica

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: git cherry-pick toma uno o varios commits de una rama y los aplica directamente en la rama actual, sin fusionar ramas completas.

ğŸ§  Pregunta 26

Â¿CuÃ¡ndo es preferible usar git revert en lugar de git reset?

A. Cuando deseas cambiar el nombre de una rama
B. Cuando trabajas en una rama pÃºblica y necesitas deshacer un cambio
C. Cuando quieres eliminar el historial completo
D. Cuando no tienes conexiÃ³n a internet

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: git revert es seguro para ramas compartidas porque crea un nuevo commit que deshace los efectos de otro sin alterar el historial anterior.

ğŸ§  Pregunta 27

Â¿QuÃ© permite Git gracias a la propagaciÃ³n de hashes?

A. Eliminar ramas huÃ©rfanas automÃ¡ticamente
B. Identificar cambios en el contenido con precisiÃ³n
C. Determinar quÃ© ramas estÃ¡n obsoletas
D. Restaurar automÃ¡ticamente el repositorio desde la nube

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La propagaciÃ³n de hashes asegura que cualquier cambio en un archivo modifique toda la cadena de objetos hacia el commit, lo que permite rastrear con exactitud los cambios.

ğŸ§  Pregunta 28

Â¿QuÃ© sucede cuando ejecutas git commit?

A. Se actualizan las ramas remotas automÃ¡ticamente
B. Git conecta el proyecto con un servidor externo
C. Se crea un nuevo objeto commit con su hash Ãºnico
D. Se borra el historial anterior de cambios

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Al hacer git commit, Git crea un nuevo objeto que referencia el Ã¡rbol del proyecto y su historial, y le asigna un hash Ãºnico que lo identifica.

ğŸ§  Pregunta 29

Â¿CuÃ¡l es el propÃ³sito de git mergetool?

A. Crear mÃºltiples ramas simultÃ¡neamente
B. Visualizar diferencias entre commits
C. Ayudar a resolver conflictos de fusiÃ³n de manera visual
D. Automatizar los commits de integraciÃ³n

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: git mergetool permite resolver conflictos de fusiÃ³n usando herramientas visuales, como meld, kdiff3 o editores modernos como VS Code.

ğŸ§  Pregunta 30

Â¿QuÃ© componente de Git representa archivos individuales y su contenido?

A. Commit
B. Tree
C. Tag
D. Blob

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: En Git, los blobs (Binary Large OBjects) almacenan el contenido de los archivos como parte de la estructura del Ã¡rbol de Merkle.



ğŸ§  Pregunta 31
Â¿CuÃ¡l es una consecuencia directa del cambio de contenido en un archivo gestionado por Git?

A. Solo se modifica el mensaje del commit actual
B. El Ã¡rbol y el commit que lo contienen tambiÃ©n cambian
C. Se genera una rama nueva automÃ¡ticamente
D. Git borra el historial del archivo

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: En Git, cambiar un archivo modifica su blob, lo que cambia el tree que lo contiene y, por lo tanto, el commit asociado, propagando el cambio.

ğŸ§  Pregunta 32
Â¿QuÃ© ventaja ofrece Git al permitir mÃºltiples flujos de trabajo como Git Flow o GitHub Flow?

A. Facilita el uso sin ramas
B. Impide que dos usuarios trabajen en paralelo
C. Permite adaptar el flujo de trabajo al estilo del equipo
D. Requiere siempre trabajar en la rama main

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Git es flexible y permite aplicar diferentes flujos de trabajo segÃºn el tamaÃ±o y estilo del equipo, como ramas cortas o estructuras formales.

ğŸ§  Pregunta 33
Â¿QuÃ© tipo de datos almacena un objeto tree en Git?

A. Solamente el mensaje del commit
B. El contenido completo de cada archivo
C. Referencias a blobs y otros trees
D. El historial de fusiones entre ramas

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Un objeto tree representa un directorio e incluye referencias a blobs (archivos) y otros trees (subdirectorios).

ğŸ§  Pregunta 34
Â¿Por quÃ© Git puede ser mÃ¡s eficiente en operaciones locales comparado con sistemas centralizados?

A. Utiliza una base de datos externa
B. Ejecuta todos los comandos en la nube
C. Opera principalmente en el servidor remoto
D. Realiza operaciones crÃ­ticas sin necesidad de conectarse a red

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: Git realiza operaciones como commits, logs y diffs localmente, lo que lo hace mÃ¡s rÃ¡pido y eficiente al no depender del servidor.

ğŸ§  Pregunta 35
Â¿QuÃ© diferencia a un sistema distribuido como Git de uno centralizado como Subversion?

A. En Git, los commits no se registran
B. Git no necesita conexiÃ³n constante al servidor
C. En Git no se pueden fusionar ramas
D. Git no guarda historial de versiones

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: A diferencia de Subversion, Git no requiere conexiÃ³n constante porque cada clon es un repositorio completo con todo el historial.

ğŸ§  Pregunta 36
Â¿CuÃ¡ndo se generan los packfiles en Git?

A. Solo durante la creaciÃ³n del repositorio
B. Cada vez que se hace un git commit
C. Durante operaciones como git clone, fetch, push o git gc
D. Solo cuando se eliminan ramas

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Los packfiles se generan durante operaciones de transferencia o mantenimiento como clone, fetch, push o git gc, para optimizar almacenamiento.

ğŸ§  Pregunta 37
Â¿QuÃ© comando permite ver y editar visualmente conflictos durante una fusiÃ³n?

A. git log
B. git branch
C. git mergetool
D. git fetch

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: git mergetool permite al usuario resolver conflictos visualmente usando herramientas grÃ¡ficas compatibles como Meld o VS Code.

ğŸ§  Pregunta 38
Â¿QuÃ© tipo de objeto Git contiene informaciÃ³n como autor, fecha y mensaje?

A. Tree
B. Blob
C. Commit
D. Packfile

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El objeto commit almacena metadatos del cambio como autor, fecha, mensaje y punteros al Ã¡rbol del proyecto y a su padre.

ğŸ§  Pregunta 39
Â¿QuÃ© comando permite aplicar un commit especÃ­fico de una rama distinta a la actual?

A. git merge
B. git fetch
C. git cherry-pick
D. git reset

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: git cherry-pick aplica commits seleccionados de otra rama en la rama actual, sin fusionar todo el historial de la rama de origen.

ğŸ§  Pregunta 40
Â¿Por quÃ© Git puede detectar rÃ¡pidamente si un archivo ha sido modificado?

A. Porque guarda una copia temporal en el servidor
B. Porque compara nombres de archivo
C. Porque compara los hashes del contenido
D. Porque hace un escaneo visual de los archivos

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Git detecta cambios comparando los hashes del contenido. Si el contenido cambia, el hash cambia y Git lo marca como modificado.

ğŸ§  Pregunta 41
Â¿QuÃ© propiedad tiene un algoritmo de hash que permite detectar alteraciones con alta sensibilidad?

A. Aleatoriedad
B. Reversibilidad
C. PropagaciÃ³n de ramas
D. Avalancha

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: La propiedad de avalancha implica que un pequeÃ±o cambio en la entrada genera un cambio radical en el hash, permitiendo detectar alteraciones mÃ­nimas.

ğŸ§  Pregunta 42
Â¿CuÃ¡l es el beneficio principal de usar SHA-256 en lugar de SHA-1 en Git?

A. Mejora la visualizaciÃ³n del historial
B. Ocupa menos espacio en disco
C. Es mÃ¡s rÃ¡pido al crear ramas
D. Es mÃ¡s resistente a colisiones

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: SHA-256 ofrece mayor seguridad criptogrÃ¡fica que SHA-1, especialmente contra ataques por colisiÃ³n donde dos entradas generan el mismo hash.

ğŸ§  Pregunta 43
Â¿QuÃ© estructura usa Git para representar el historial de versiones y sus relaciones?

A. Ãrbol AVL
B. Grafo acÃ­clico dirigido (DAG)
C. Matriz de versiones
D. Lista doblemente enlazada

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Git usa un grafo acÃ­clico dirigido (DAG) donde cada commit apunta a sus padres, reflejando asÃ­ la evoluciÃ³n y ramificaciÃ³n del historial.

ğŸ§  Pregunta 44
Â¿QuÃ© ventaja tiene Git sobre sistemas centralizados cuando se trabaja en entornos sin conectividad?

A. No permite commits sin red
B. Exige conexiÃ³n al servidor para ver historial
C. Permite commits y consultas locales sin red
D. Bloquea operaciones locales hasta sincronizar

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Al tener una copia completa del repositorio, Git permite trabajar localmente en cualquier operaciÃ³n como commit, log o diff sin necesidad de internet.

ğŸ§  Pregunta 45
Â¿CuÃ¡l es la funciÃ³n del comando git gc?

A. Generar commits condicionales
B. Forzar la sincronizaciÃ³n con ramas remotas
C. Recolectar basura y optimizar almacenamiento
D. Generar claves para el repositorio

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: git gc (garbage collection) limpia objetos huÃ©rfanos y agrupa objetos en packfiles para optimizar espacio y rendimiento.

ğŸ§  Pregunta 46
Â¿QuÃ© caracterÃ­stica del diseÃ±o de Git permite detectar cualquier corrupciÃ³n en su contenido?

A. Control centralizado
B. Hash por objeto
C. Commit incremental
D. ValidaciÃ³n manual

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Cada objeto (blob, tree, commit) en Git se identifica por un hash de su contenido; si el contenido se altera, el hash cambia y se detecta.

ğŸ§  Pregunta 47
Â¿QuÃ© componente de Git actÃºa como â€œinstantÃ¡neaâ€ del estado del proyecto en un momento dado?

A. Blob
B. Branch
C. Commit
D. HEAD

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Un commit apunta a un tree que representa el estado completo del proyecto en ese instante, actuando como una instantÃ¡nea del repositorio.

ğŸ§  Pregunta 48
Â¿QuÃ© comando permite combinar commits durante un rebase interactivo?

A. squash
B. fetch
C. revert
D. pop

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: En un git rebase -i, puedes usar la acciÃ³n squash para combinar varios commits en uno solo y mantener un historial mÃ¡s limpio.

ğŸ§  Pregunta 49
Â¿QuÃ© tÃ©cnica usa Git para reducir el tamaÃ±o de almacenamiento entre archivos similares?

A. Compression shift
B. Tree pruning
C. Delta encoding
D. File snapshotting

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Delta encoding permite que Git almacene solo las diferencias entre versiones de archivos, reduciendo el espacio requerido.

ğŸ§  Pregunta 50
Â¿CuÃ¡l es el riesgo principal que motivÃ³ la migraciÃ³n de Git de SHA-1 a SHA-256?

A. Bajo rendimiento al comprimir
B. Dificultad para identificar ramas
C. Existencia de vulnerabilidades de colisiÃ³n en SHA-1
D. Incompatibilidad con sistemas operativos modernos

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: SHA-1 fue vulnerado con colisiones prÃ¡cticas, lo que representa un riesgo para la integridad del repositorio. SHA-256 corrige estas debilidades.


ğŸ§  Pregunta 51
Â¿QuÃ© representa el objeto HEAD en un repositorio Git?

A. El primer commit del historial
B. El commit mÃ¡s reciente de la rama main
C. El puntero a la rama activa o al Ãºltimo commit referenciado
D. Un archivo de configuraciÃ³n del repositorio

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: HEAD es un puntero simbÃ³lico que indica la rama o commit en el que estÃ¡s trabajando actualmente. Cambia cuando haces checkout o commit.

ğŸ§  Pregunta 52
Â¿QuÃ© sucede si haces git reset --hard HEAD~1?

A. Agrega un commit vacÃ­o
B. Fusiona automÃ¡ticamente la rama actual con otra
C. Elimina el Ãºltimo commit de forma irreversible
D. Mueve la rama actual al commit mÃ¡s reciente

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El comando git reset --hard HEAD~1 borra el Ãºltimo commit y sus cambios, dejando el proyecto como estaba en el commit anterior.

ğŸ§  Pregunta 53
Â¿QuÃ© componente de Git agrupa varios objetos en un Ãºnico archivo comprimido para eficiencia?

A. Commit
B. Tree
C. Packfile
D. Mergefile

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Los packfiles agrupan muchos objetos Git (blobs, commits, trees) en un solo archivo comprimido, lo que mejora rendimiento y ahorro de espacio.

ğŸ§  Pregunta 54
Â¿QuÃ© comando se utiliza para ver el historial de commits en una lÃ­nea de tiempo?

A. git show
B. git graph
C. git log
D. git timeline

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: git log permite ver la lista de commits, sus mensajes, autores, fechas y hashes, mostrando el historial del proyecto.

ğŸ§  Pregunta 55
Â¿QuÃ© herramienta ofrece Git para comparar cambios entre dos commits?

A. git commit --diff
B. git patch
C. git compare
D. git diff

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: git diff compara los cambios entre commits, ramas, archivos o el Ã­ndice, permitiendo analizar quÃ© ha cambiado en el cÃ³digo.

ğŸ§  Pregunta 56
Â¿CuÃ¡l es la funciÃ³n principal del comando git branch?

A. Fusionar ramas
B. Crear, listar o eliminar ramas
C. Cambiar de commit
D. Mostrar diferencias entre archivos

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: git branch se usa para listar, crear o eliminar ramas en el repositorio, facilitando la gestiÃ³n de desarrollos paralelos.

ğŸ§  Pregunta 57
Â¿CuÃ¡ndo es recomendable usar git revert en lugar de git reset?

A. En ramas pÃºblicas compartidas con otros desarrolladores
B. Cuando se desea eliminar completamente el historial
C. Solo al trabajar con repositorios remotos
D. Nunca, ya que ambos hacen lo mismo

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: git revert genera un nuevo commit que deshace los cambios de otro, sin alterar el historial, lo que lo hace seguro en ramas compartidas.

ğŸ§  Pregunta 58
Â¿CuÃ¡l es la principal ventaja del modelo de sincronizaciÃ³n asincrÃ³nica en Git?

A. Evita la creaciÃ³n de ramas
B. Permite hacer commits directamente al servidor
C. Los desarrolladores pueden trabajar en paralelo y sincronizar despuÃ©s
D. Garantiza que no habrÃ¡ conflictos

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Git permite que los desarrolladores trabajen localmente y sin conexiÃ³n, sincronizando sus cambios con otros cuando lo deseen mediante pull o push.

ğŸ§  Pregunta 59
Â¿QuÃ© representa un blob dentro de la base de datos de objetos de Git?

A. Un grupo de ramas
B. Un objeto con los metadatos de un commit
C. El contenido de un archivo
D. Una estructura que describe directorios

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Un blob (Binary Large OBject) representa el contenido de un archivo sin informaciÃ³n de nombre ni ubicaciÃ³n, solo su contenido puro.

ğŸ§  Pregunta 60
Â¿CuÃ¡l de las siguientes opciones es una ventaja directa del uso de Ã¡rboles de Merkle en Git?

A. Permiten revertir fÃ¡cilmente los cambios
B. Aumentan el tamaÃ±o del repositorio
C. Verifican la integridad del historial mediante propagaciÃ³n de hashes
D. Requieren acceso al servidor para validar los commits

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Los Ã¡rboles de Merkle en Git encadenan hashes jerÃ¡rquicamente, asegurando que cualquier alteraciÃ³n sea detectable desde la raÃ­z del repositorio.


ğŸ§  Pregunta 61
Â¿QuÃ© ventaja ofrece Git al calcular el hash de cada objeto usando su contenido?

A. Permite ocultar los archivos modificados
B. Acelera las operaciones de clonaciÃ³n
C. Permite identificar cambios exactos y evitar duplicaciÃ³n de datos
D. Elimina la necesidad de branches

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Al usar el contenido para generar el hash, Git evita duplicar archivos idÃ©nticos y puede detectar exactamente quÃ© ha cambiado en cada versiÃ³n.

ğŸ§  Pregunta 62
Â¿QuÃ© comando se usa para traer cambios desde un repositorio remoto y fusionarlos con la rama actual?

A. git push
B. git merge
C. git fetch
D. git pull

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: git pull trae los cambios del repositorio remoto y los fusiona automÃ¡ticamente con tu rama actual.

ğŸ§  Pregunta 63
Â¿QuÃ© significa que Git es â€œresilienteâ€?

A. Que se adapta al sistema operativo del servidor
B. Que requiere poco mantenimiento manual
C. Que puede recuperarse desde cualquier clon si se pierde el servidor principal
D. Que tiene una interfaz grÃ¡fica predeterminada

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Al ser distribuido, cualquier clon completo de un repositorio Git puede ser usado para restaurar todo el proyecto si el servidor falla.

ğŸ§  Pregunta 64
Â¿CuÃ¡l es el propÃ³sito del comando git status?

A. Mostrar las ramas remotas existentes
B. Indicar el estado del repositorio y los archivos modificados
C. Revertir los Ãºltimos commits
D. Generar el archivo de configuraciÃ³n del proyecto

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: git status informa sobre los archivos modificados, aÃ±adidos o pendientes de commit, y muestra en quÃ© rama estÃ¡s.

ğŸ§  Pregunta 65
Â¿CuÃ¡l es la diferencia entre git fetch y git pull?

A. git fetch descarga y fusiona, mientras que git pull solo descarga
B. git fetch descarga sin fusionar, git pull descarga y fusiona
C. No existe diferencia, ambos hacen lo mismo
D. git pull solo sirve en la rama main

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: git fetch descarga cambios remotos sin aplicarlos, mientras que git pull tambiÃ©n los fusiona con la rama actual.

ğŸ§  Pregunta 66
Â¿QuÃ© opciÃ³n describe mejor el uso de git reset?

A. Fusiona cambios remotos
B. Reescribe el historial y mueve la rama a un commit anterior
C. Borra el contenido del repositorio
D. Crea ramas temporales para pruebas

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: git reset mueve el puntero de la rama actual a un commit anterior y, dependiendo del modo usado, puede modificar el Ã¡rbol de trabajo y el staging area.

ğŸ§  Pregunta 67
Â¿QuÃ© ocurre cuando se resuelve un conflicto de merge manualmente?

A. Se borra el historial de la rama
B. Git crea automÃ¡ticamente una nueva rama
C. Se deben quitar los delimitadores <<<<<<<, =======, >>>>>>> y hacer commit
D. El conflicto se soluciona al hacer git fetch

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Cuando hay un conflicto, Git marca el cÃ³digo en conflicto con delimitadores, y el desarrollador debe resolverlo manualmente y luego hacer commit.

ğŸ§  Pregunta 68
Â¿Por quÃ© los comandos como git log, git diff y git blame son rÃ¡pidos en Git?

A. Porque se ejecutan en la nube
B. Porque se basan en archivos temporales
C. Porque acceden directamente al servidor remoto
D. Porque operan localmente sin depender del servidor

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: Git ejecuta estas operaciones completamente en local gracias a que cada clon contiene todo el historial, lo que las hace muy rÃ¡pidas.

ğŸ§  Pregunta 69
Â¿QuÃ© ventaja clave ofrece la compresiÃ³n en los packfiles?

A. Disminuye la cantidad de ramas activas
B. Oculta los cambios mÃ¡s recientes
C. Reduce el tamaÃ±o del repositorio y mejora las transferencias
D. Elimina commits duplicados automÃ¡ticamente

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Los packfiles comprimen los objetos del repositorio, reduciendo el tamaÃ±o del disco y acelerando operaciones como clone o fetch.

ğŸ§  Pregunta 70
Â¿CuÃ¡l es la principal razÃ³n de Git para usar estructuras como DAGs y Ã¡rboles de Merkle?

A. Soportar mÃºltiples sistemas de archivos
B. Permitir personalizar los comandos
C. Garantizar integridad, trazabilidad y eficiencia en las operaciones
D. Poder ejecutar Git sin instalaciÃ³n

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Git combina DAGs y Ã¡rboles de Merkle para asegurar relaciones claras entre commits, integridad criptogrÃ¡fica y operaciones eficientes sobre el historial.

ğŸ§  Pregunta 71
Â¿QuÃ© ocurre si dos ramas modifican la misma lÃ­nea de un archivo y luego se hace un merge?

A. Git elige automÃ¡ticamente una versiÃ³n y descarta la otra
B. Git ignora los cambios y deja el archivo original
C. Git genera un conflicto que debe resolverse manualmente
D. Git crea un nuevo archivo para cada versiÃ³n

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Cuando dos ramas modifican la misma lÃ­nea, Git no puede decidir quÃ© versiÃ³n conservar y marca el conflicto para que lo resuelva el desarrollador.

ğŸ§  Pregunta 72
Â¿En quÃ© casos Git utiliza la estrategia de fusiÃ³n recursiva?

A. Solo cuando se hace un cherry-pick
B. Cuando se fusionan dos ramas con un ancestro comÃºn
C. Para borrar ramas obsoletas
D. Cuando se hace git clone

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La fusiÃ³n recursiva se usa al combinar dos ramas, buscando su ancestro comÃºn y fusionando los cambios desde ese punto.

ğŸ§  Pregunta 73
Â¿QuÃ© es el "merge base" en Git?

A. El primer commit del repositorio
B. La rama de origen en una fusiÃ³n
C. El commit mÃ¡s reciente antes de una divergencia entre ramas
D. El Ãºltimo archivo modificado antes de una fusiÃ³n

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El merge base es el ancestro comÃºn mÃ¡s reciente entre dos ramas, utilizado como punto de partida para fusionar los cambios.

ğŸ§  Pregunta 74
Â¿CuÃ¡l es una razÃ³n para evitar usar git reset en ramas compartidas?

A. Porque crea demasiados commits
B. Porque elimina ramas
C. Porque puede reescribir el historial y causar conflictos con otros usuarios
D. Porque borra archivos del repositorio

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: git reset modifica el historial de la rama, lo que puede causar problemas si otros ya han basado su trabajo en los commits eliminados.

ğŸ§  Pregunta 75
Â¿QuÃ© comando permite listar todas las ramas locales existentes?

A. git log
B. git branch
C. git status
D. git remote

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: git branch muestra todas las ramas locales del repositorio, y permite crear o eliminar ramas si se le agregan opciones.

ğŸ§  Pregunta 76
Â¿QuÃ© comando permite deshacer un commit ya enviado sin borrar el historial?

A. git revert
B. git remove
C. git stash
D. git pop

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: git revert crea un nuevo commit que invierte los cambios de un commit anterior, manteniendo intacto el historial del repositorio.

ğŸ§  Pregunta 77
Â¿QuÃ© acciÃ³n se recomienda antes de fusionar una rama feature a main?

A. Hacer un reset de la rama feature
B. Crear un tag
C. Aplicar un rebase interactivo para limpiar el historial
D. Borrar la rama feature

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Un git rebase -i permite reorganizar y limpiar los commits de la rama feature para que su integraciÃ³n en main sea mÃ¡s clara y ordenada.

ğŸ§  Pregunta 78
Â¿CuÃ¡l es la diferencia principal entre git revert y git reset?

A. revert cambia el historial y reset no
B. revert elimina archivos y reset los restaura
C. revert crea un nuevo commit, mientras que reset mueve la referencia del historial
D. No existe diferencia funcional

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: revert aÃ±ade un nuevo commit que deshace cambios, Ãºtil en ramas pÃºblicas; reset mueve el puntero de la rama, reescribiendo el historial.

ğŸ§  Pregunta 79
Â¿QuÃ© comando permite ver todos los commits realizados, en orden cronolÃ³gico inverso?

A. git show
B. git diff
C. git log
D. git fetch

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: git log muestra una lista cronolÃ³gica de los commits realizados, con detalles como autor, fecha, hash y mensaje.

ğŸ§  Pregunta 80
Â¿CuÃ¡l es una ventaja directa del uso de ramas en Git?

A. Permiten eliminar cambios sin guardar
B. Obligan a usar un servidor remoto
C. Facilitan el desarrollo paralelo de funcionalidades sin afectar la rama principal
D. Requieren menos espacio de almacenamiento

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Las ramas permiten a los desarrolladores trabajar en nuevas funcionalidades o correcciones de forma aislada, sin alterar la versiÃ³n estable del proyecto.

ğŸ§  Pregunta 81
Â¿QuÃ© comando se utiliza para subir commits locales al repositorio remoto?

A. git merge
B. git pull
C. git commit
D. git push

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: git push envÃ­a los commits realizados localmente al repositorio remoto, permitiendo que otros desarrolladores accedan a los cambios.

ğŸ§  Pregunta 82
Â¿CuÃ¡l es una consecuencia de realizar git rebase sobre una rama pÃºblica?

A. Se crean ramas nuevas automÃ¡ticamente
B. Se elimina el historial del repositorio
C. Se reescribe el historial, lo que puede causar conflictos con otros colaboradores
D. Se hace un merge automÃ¡tico sin conflictos

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Reescribir el historial con git rebase en ramas pÃºblicas puede desincronizar a los colaboradores, ya que los hashes de los commits cambian.

ğŸ§  Pregunta 83
Â¿QuÃ© hace git stash?

A. Elimina archivos del Ã¡rea de staging
B. Almacena temporalmente cambios no confirmados
C. Mueve commits entre ramas
D. Borra los archivos ignorados por Git

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: git stash guarda temporalmente los cambios del Ã¡rea de trabajo para poder hacer otras tareas, sin perder el progreso.

ğŸ§  Pregunta 84
Â¿QuÃ© comando permite recuperar los cambios guardados con git stash?

A. git recover
B. git apply
C. git reset
D. git cherry-pick

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: git apply recupera los cambios almacenados con git stash sin eliminar el stash, permitiendo aplicarlos de nuevo si es necesario.

ğŸ§  Pregunta 85
Â¿QuÃ© significa que Git maneje â€œflujos de trabajo asincrÃ³nicosâ€?

A. Solo una persona puede hacer commits a la vez
B. Se deben coordinar los commits con cada colaborador
C. Cada desarrollador puede trabajar por separado y sincronizar cuando estÃ© listo
D. Todos deben trabajar en la misma rama

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Git permite que cada desarrollador trabaje localmente en su propio flujo y luego sincronice con el resto del equipo al momento deseado.

ğŸ§  Pregunta 86
Â¿QuÃ© ventaja ofrece el comando git tag?

A. Elimina commits antiguos automÃ¡ticamente
B. Marca puntos importantes del historial, como versiones o lanzamientos
C. Fusiona ramas remotas
D. Verifica el estado de los archivos

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: git tag se usa para seÃ±alar momentos clave del proyecto, como versiones estables o puntos de liberaciÃ³n importantes.

ğŸ§  Pregunta 87
Â¿QuÃ© ocurre si ejecutas git init en una carpeta?

A. Se elimina todo el contenido
B. Se descarga un repositorio desde GitHub
C. Se convierte la carpeta en un repositorio Git local
D. Se genera automÃ¡ticamente un archivo README

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: git init inicializa un nuevo repositorio Git local en la carpeta actual, creando una estructura interna en .git.

ğŸ§  Pregunta 88
Â¿QuÃ© comando se utiliza para comparar dos ramas?

A. git graph
B. git show
C. git branch
D. git diff

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: git diff rama1..rama2 permite ver las diferencias entre dos ramas, mostrando los cambios que no han sido compartidos.

ğŸ§  Pregunta 89
Â¿CuÃ¡l es el comportamiento de git clone?

A. Reescribe el historial remoto
B. Crea una copia exacta del repositorio remoto en local
C. Solo descarga la rama principal
D. Aplica todos los stashes pendientes

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: git clone copia todo el contenido del repositorio remoto (incluyendo historial, ramas, y configuraciÃ³n) en una nueva carpeta local.

ğŸ§  Pregunta 90
Â¿QuÃ© significa que Git puede detectar colisiones en los hashes?

A. Puede corregir errores automÃ¡ticamente
B. Puede detectar si dos objetos distintos tienen el mismo hash
C. Puede borrar duplicados automÃ¡ticamente
D. Puede fusionar ramas sin conflictos

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Git se basa en que los hashes sean Ãºnicos, por lo que si detecta dos objetos con el mismo hash (una colisiÃ³n), alerta de una posible vulnerabilidad.

ğŸ§  Pregunta 91
Â¿CuÃ¡l es el efecto inmediato de ejecutar git checkout nombre-rama?

A. Elimina la rama especificada
B. Cambia la rama activa a nombre-rama
C. Fusiona la rama con main
D. Reescribe el historial de la rama actual

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: git checkout nombre-rama cambia el contexto de trabajo a esa rama, actualizando los archivos del proyecto y el puntero HEAD.

ğŸ§  Pregunta 92
Â¿CuÃ¡l de las siguientes estructuras contiene una referencia a un tree y a sus commits padres?

A. Blob
B. Packfile
C. Commit
D. HEAD

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Un commit en Git contiene una referencia al Ã¡rbol (tree) que representa el estado del proyecto y tambiÃ©n apunta a su commit padre (o padres, en caso de merge).

ğŸ§  Pregunta 93
Â¿QuÃ© comando se utiliza para crear una nueva rama y moverse a ella al instante?

A. git switch
B. git checkout -b nombre-rama
C. git clone --branch
D. git branch && git merge

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: git checkout -b nombre-rama crea una nueva rama y cambia directamente a ella en una sola instrucciÃ³n.

ğŸ§  Pregunta 94
Â¿CuÃ¡l es la utilidad principal del comando git show?

A. Ver ramas disponibles
B. Visualizar detalles de un commit especÃ­fico
C. Comparar ramas remotas
D. Borrar cambios no guardados

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: git show permite ver detalles completos de un commit, como su hash, autor, fecha y cambios realizados.

ğŸ§  Pregunta 95
Â¿QuÃ© sucede si ejecutas git commit sin usar git add previamente?

A. Se hace commit de todos los cambios, incluidos los no guardados
B. No se realiza ningÃºn commit
C. Solo se confirma el Ãºltimo archivo modificado
D. Solo se confirman los cambios previamente aÃ±adidos al Ã¡rea de staging

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: git commit solo registra los archivos que han sido aÃ±adidos al Ã¡rea de staging mediante git add.

ğŸ§  Pregunta 96
Â¿QuÃ© es origin en el contexto de Git?

A. El archivo de configuraciÃ³n principal
B. Un tipo especial de commit
C. El nombre por defecto del repositorio remoto cuando se clona
D. Una rama temporal creada al hacer merge

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Cuando se clona un repositorio, Git asigna el nombre origin por defecto al repositorio remoto desde donde se clonÃ³.

ğŸ§  Pregunta 97
Â¿QuÃ© comando permite ver los cambios realizados pero aÃºn no aÃ±adidos al Ã¡rea de staging?

A. git reset
B. git diff
C. git status
D. git stash show

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: git diff muestra los cambios realizados en los archivos del Ã¡rea de trabajo que todavÃ­a no se han agregado al staging con git add.

ğŸ§  Pregunta 98
Â¿Para quÃ© sirve el archivo .gitignore?

A. Para ignorar ramas remotas en el log
B. Para excluir archivos o carpetas del control de versiones
C. Para bloquear commits no deseados
D. Para revertir los cambios de una rama

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El archivo .gitignore le indica a Git quÃ© archivos o directorios debe ignorar (no rastrear ni incluir en commits).

ğŸ§  Pregunta 99
Â¿QuÃ© comando se puede usar para eliminar una rama local?

A. git remove-branch
B. git branch -delete
C. git branch -d nombre-rama
D. git delete nombre-rama

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: git branch -d nombre-rama elimina una rama local de forma segura, siempre que haya sido fusionada. Para forzar, se puede usar -D.

ğŸ§  Pregunta 100
Â¿CuÃ¡l es el propÃ³sito de git config?

A. Instalar plugins externos
B. Establecer configuraciones como nombre de usuario y correo
C. Visualizar conflictos pendientes
D. Comprimir objetos automÃ¡ticamente

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: git config permite definir configuraciones del entorno de Git, como nombre, correo, editor por defecto, alias, entre otros.


ğŸ§  Pregunta 1

Â¿CuÃ¡l es la principal ventaja de que Git sea un sistema de control de versiones "distribuido"?

A. Requiere de una conexiÃ³n constante a un servidor central para realizar la mayorÃ­a de las operaciones.

B. Permite que solo el servidor central tenga una copia completa del historial del proyecto.

C. Cada desarrollador tiene una copia completa del repositorio, incluyendo el historial, lo que permite trabajar offline y tener redundancia de datos.

D. Simplifica la gestiÃ³n de un Ãºnico flujo de trabajo lineal para todo el equipo.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El texto destaca que la naturaleza distribuida de Git implica que cada clon contiene el historial completo, permitiendo operaciones locales sin conexiÃ³n y ofreciendo mÃºltiples puntos de respaldo.

ğŸ§  Pregunta 2

Â¿QuÃ© distingue al modelo de funcionamiento de Git en comparaciÃ³n con sistemas de control de versiones centralizados como Subversion (SVN)?

A. Git depende de un servidor central para todas las operaciones, mientras que SVN permite operaciones locales.

B. En Git, cada desarrollador tiene una copia completa del repositorio, mientras que en SVN los desarrolladores trabajan directamente sobre el repositorio central.

C. SVN utiliza un modelo peer-to-peer, similar a una red de iguales, donde cada copia es autÃ³noma.

D. Git requiere una conexiÃ³n a internet activa para realizar commits y navegar por el historial, a diferencia de SVN.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: El texto explica claramente que Git sigue un modelo distribuido donde cada clon es una rÃ©plica completa, a diferencia del modelo centralizado de SVN donde se interactÃºa directamente con un servidor.

ğŸ§  Pregunta 3

Â¿CuÃ¡l es la funciÃ³n principal de un Grafo AcÃ­clico Dirigido (DAG) en la arquitectura interna de Git?

A. Almacenar el contenido de los archivos del proyecto en diferentes versiones.

B. Garantizar la integridad de los datos mediante la verificaciÃ³n de hashes.

C. Organizar el historial de commits, mostrando las relaciones de dependencia y la direcciÃ³n temporal de los cambios.

D. Comprimir los objetos del repositorio para ahorrar espacio en disco.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La lectura describe el DAG como la estructura que representa el historial de commits, con nodos para cada commit y flechas indicando las relaciones entre ellos, siempre en una direcciÃ³n temporal.

ğŸ§  Pregunta 4

Â¿De quÃ© manera los Ã¡rboles de Merkle contribuyen a la funcionalidad de Git?

A. Permiten la creaciÃ³n de ramas y la fusiÃ³n de cambios de manera eficiente.

B. Facilitan la comparaciÃ³n del contenido de diferentes versiones de los archivos.

C. Aseguran la integridad de los datos al calcular un hash Ãºnico para cada objeto (blob, tree, commit) y sus relaciones.

D. Optimizan el almacenamiento de datos al guardar solo las diferencias entre archivos.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El texto explica que los Ã¡rboles de Merkle, con su sistema de hashes encadenados, permiten a Git verificar la integridad del contenido del repositorio en cada punto del historial.

ğŸ§  Pregunta 5

Â¿QuÃ© propÃ³sito fundamental cumplen los algoritmos de hashing criptogrÃ¡fico, como SHA-1 (histÃ³ricamente) y SHA-256 (actualmente en transiciÃ³n), dentro de Git?

A. Facilitar la compresiÃ³n de los archivos del repositorio para reducir el espacio de almacenamiento.

B. Permitir la comunicaciÃ³n segura entre diferentes repositorios remotos.

C. Identificar de manera Ãºnica cada objeto (commit, archivo, directorio) basÃ¡ndose en su contenido y verificar su integridad.

D. Organizar la estructura de directorios y archivos dentro del repositorio.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La lectura detalla cÃ³mo los algoritmos de hash generan identificadores Ãºnicos para cada objeto, asegurando que cualquier cambio en el contenido se refleje en un hash diferente, lo que permite la verificaciÃ³n de la integridad.

ğŸ§  Pregunta 6

Â¿CuÃ¡l es el principal beneficio de utilizar "delta encoding" en Git?

A. Permite identificar y fusionar automÃ¡ticamente ramas con cambios conflictivos.

B. Reduce la necesidad de almacenar copias completas de archivos en cada versiÃ³n, guardando solo las diferencias entre ellas, lo que ahorra espacio.

C. Facilita la navegaciÃ³n a travÃ©s del historial de commits al mostrar solo los cambios significativos.

D. Mejora la seguridad del repositorio al cifrar el contenido de los archivos.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: El texto explica que el delta encoding optimiza el almacenamiento al guardar Ãºnicamente las modificaciones entre versiones de los archivos.

ğŸ§  Pregunta 7

Â¿QuÃ© es un "packfile" en Git y cuÃ¡l es su principal ventaja?

A. Es un archivo de texto que contiene los metadatos del repositorio, como las ramas y las etiquetas.

B. Es un archivo binario que agrupa mÃºltiples objetos del repositorio en un solo contenedor comprimido, facilitando la transferencia y el almacenamiento eficiente.

C. Es un registro de todos los comandos de Git ejecutados por los usuarios.

D. Es una copia de seguridad completa del repositorio que se crea periÃ³dicamente.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La lectura describe los packfiles como archivos comprimidos que contienen mÃºltiples objetos, lo que optimiza el almacenamiento y la velocidad de las operaciones.

ğŸ§  Pregunta 8

Â¿CuÃ¡l es el objetivo principal de la estrategia de fusiÃ³n "recursiva" (recursive merge) en Git?

A. Fusionar tres o mÃ¡s ramas simultÃ¡neamente en un solo commit.

B. Identificar el ancestro comÃºn entre dos ramas y combinar los cambios realizados en cada una desde ese punto.

C. Aplicar commits especÃ­ficos de una rama a otra sin fusionar la rama completa.

D. Reescribir el historial de una rama para que parezca que se desarrollÃ³ directamente desde otra.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: El texto explica que la fusiÃ³n recursiva compara los cambios en dos ramas desde su ancestro comÃºn para integrarlos.

ğŸ§  Pregunta 9

Â¿En quÃ© situaciÃ³n serÃ­a mÃ¡s apropiado utilizar la estrategia de fusiÃ³n "octopus" en Git?

A. Cuando se necesita integrar una rama de caracterÃ­sticas pequeÃ±a en la rama principal.

B. Cuando se deben fusionar dos ramas que tienen cambios conflictivos en las mismas lÃ­neas de cÃ³digo.

C. Cuando se quieren integrar mÃºltiples ramas de caracterÃ­sticas listas para ser unidas a una rama de desarrollo o en un release.

D. Cuando se desea limpiar el historial de commits de una rama antes de fusionarla.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La lectura indica que la fusiÃ³n octopus estÃ¡ diseÃ±ada para la integraciÃ³n simultÃ¡nea de varias ramas, especialmente en escenarios como la preparaciÃ³n de un release.

ğŸ§  Pregunta 10

Â¿QuÃ© utilidad ofrece el "rebase interactivo" (git rebase -i) en Git antes de fusionar una rama?

A. Permite deshacer commits ya realizados en la rama principal.

B. Facilita la resoluciÃ³n automÃ¡tica de conflictos de fusiÃ³n complejos.

C. Permite reordenar, editar mensajes, combinar o eliminar commits en una rama para mantener un historial mÃ¡s limpio y lÃ³gico.

D. Permite seleccionar commits especÃ­ficos de otra rama para integrarlos en la rama actual.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El texto describe el rebase interactivo como una herramienta para manipular el historial de una rama antes de la fusiÃ³n, con el objetivo de obtener un historial mÃ¡s claro.


ğŸ§  Pregunta 11

Â¿CuÃ¡l es una de las ventajas clave de que cada clon de Git sea un repositorio autÃ³nomo con el historial completo?

A. Requiere menos espacio de almacenamiento en las mÃ¡quinas individuales de los desarrolladores.

B. Permite que solo los usuarios con permisos especiales puedan ver el historial completo del proyecto.

C. Posibilita realizar operaciones como commits y visualizaciÃ³n del historial sin necesidad de conexiÃ³n a internet.

D. Asegura que todos los desarrolladores trabajen siempre sobre la misma copia del repositorio en tiempo real.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La naturaleza distribuida permite la independencia de la conexiÃ³n para muchas operaciones locales.

ğŸ§  Pregunta 12

En un modelo de control de versiones centralizado, Â¿quÃ© ocurre si el servidor central falla?

A. Los desarrolladores pueden seguir trabajando localmente sin ninguna interrupciÃ³n.

B. Se pierde el acceso al historial del proyecto y la capacidad de realizar nuevas operaciones hasta que se restaure el servidor.

C. Cada desarrollador puede designar su copia local como el nuevo servidor central.

D. El sistema automÃ¡ticamente replica el repositorio en las mÃ¡quinas de todos los desarrolladores.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La dependencia del servidor central es una vulnerabilidad de los sistemas centralizados.

ğŸ§  Pregunta 13

Â¿QuÃ© significa que el DAG en Git no tiene ciclos ("acÃ­clico")?

A. Que los commits siempre se organizan en una Ãºnica lÃ­nea temporal sin ramificaciones.

B. Que no es posible volver a un commit anterior siguiendo las relaciones de dependencia.

C. Que el historial de commits siempre avanza hacia adelante, sin bucles ni referencias circulares.

D. Que las fusiones de ramas siempre crean un nuevo commit sin alterar el historial de las ramas originales.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La propiedad acÃ­clica del DAG asegura una direcciÃ³n temporal clara y evita confusiones en el historial.

ğŸ§  Pregunta 14

Â¿CÃ³mo se relaciona el hash SHA-1 (o SHA-256) de un commit con el contenido del proyecto en ese momento?

A. El hash es independiente del contenido y se genera secuencialmente.

B. El hash se calcula basÃ¡ndose en el contenido de los archivos, los Ã¡rboles de directorios y el commit mismo, actuando como una huella digital.

C. El hash se utiliza Ãºnicamente para identificar al autor del commit.

D. El hash indica la fecha y hora exacta en que se realizÃ³ el commit.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: El hash se deriva del contenido, garantizando la integridad y la identificaciÃ³n Ãºnica del estado del proyecto.

ğŸ§  Pregunta 15

Â¿Por quÃ© la resistencia a colisiones es una propiedad importante de los algoritmos de hashing criptogrÃ¡fico utilizados por Git?

A. Asegura que la compresiÃ³n de los archivos sea mÃ¡s eficiente.

B. Permite que diferentes objetos en el repositorio tengan el mismo identificador sin causar problemas.

C. Hace extremadamente difÃ­cil encontrar dos entradas distintas (por ejemplo, dos versiones diferentes de un archivo) que produzcan el mismo hash, lo que podrÃ­a comprometer la integridad del sistema.

D. Facilita la bÃºsqueda rÃ¡pida de objetos dentro del repositorio.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La resistencia a colisiones es crucial para la seguridad y la integridad de la identificaciÃ³n Ãºnica de los objetos.

ğŸ§  Pregunta 16

Â¿CuÃ¡l es la principal razÃ³n por la que Git estÃ¡ migrando gradualmente de SHA-1 a SHA-256?

A. SHA-256 produce hashes mÃ¡s cortos y fÃ¡ciles de recordar.

B. SHA-256 es mÃ¡s rÃ¡pido en el cÃ¡lculo de hashes, mejorando el rendimiento de Git.

C. Se han descubierto vulnerabilidades teÃ³ricas y prÃ¡cticas en SHA-1 que podrÃ­an comprometer la seguridad.

D. SHA-256 es un estÃ¡ndar mÃ¡s antiguo y probado que SHA-1.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La migraciÃ³n se debe a las preocupaciones de seguridad relacionadas con las vulnerabilidades encontradas en SHA-1.

ğŸ§  Pregunta 17

Â¿CÃ³mo contribuye el uso de hashes a la capacidad de Git para detectar modificaciones no autorizadas o errores accidentales en los archivos?

A. Al cifrar el contenido de los archivos, impidiendo que sean alterados sin la clave correcta.

B. Al registrar la fecha y hora de la Ãºltima modificaciÃ³n de cada archivo.

C. Al calcular un hash Ãºnico basado en el contenido de cada archivo; cualquier cambio en el contenido alterarÃ¡ el hash, lo que Git puede detectar.

D. Al comparar el tamaÃ±o de los archivos entre diferentes versiones del repositorio.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La alteraciÃ³n del contenido siempre resulta en un hash diferente, lo que permite la detecciÃ³n de cambios.

ğŸ§  Pregunta 18

Â¿QuÃ© tipo de objetos se almacenan en un packfile de Git?

A. Solo las diferencias (deltas) entre las versiones de los archivos.

B. Solo las versiones completas de los archivos mÃ¡s recientes.

C. Una combinaciÃ³n de objetos completos (commits, blobs, trees, tags) y sus diferencias (deltas) para optimizar el almacenamiento.

D. Solo los metadatos del repositorio, como el historial de commits y las ramas.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: Los packfiles contienen tanto objetos completos como deltas para maximizar la eficiencia del almacenamiento.

ğŸ§  Pregunta 19

Â¿QuÃ© funciÃ³n cumple el archivo Ã­ndice (.idx) asociado a un packfile en Git?

A. Contiene la lista de todos los autores de los commits incluidos en el packfile.

B. Almacena la informaciÃ³n sobre la estructura de directorios del repositorio en el momento en que se creÃ³ el packfile.

C. Sirve como un Ã­ndice para localizar rÃ¡pidamente objetos dentro del packfile, mejorando el rendimiento de las operaciones de Git.

D. Contiene las instrucciones para descomprimir los objetos almacenados en el packfile.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El archivo .idx permite un acceso rÃ¡pido a los objetos dentro del packfile.

ğŸ§  Pregunta 20

Â¿En quÃ© situaciones Git podrÃ­a optar por almacenar un objeto completo en un packfile en lugar de un delta?

A. Cuando el objeto es muy pequeÃ±o.

B. Cuando el objeto es la primera versiÃ³n de un archivo y no tiene una versiÃ³n anterior para comparar.

C. Cuando el objeto ha sido modificado muchas veces y calcular el delta serÃ­a mÃ¡s costoso que almacenar el objeto completo.

D. Todas las anteriores.

âœ… Correcta: D

ğŸ§¾ ExplicaciÃ³n: Git evalÃºa la eficiencia y puede almacenar objetos completos en diversas situaciones.

ğŸ§  Pregunta 21

Â¿CuÃ¡l es el primer paso que realiza Git al intentar fusionar dos ramas utilizando la estrategia de fusiÃ³n recursiva?

A. Aplicar todos los commits de una rama sobre la otra de forma secuencial.

B. Identificar los commits que son Ãºnicos en cada una de las ramas.

C. Localizar el Ãºltimo commit que ambas ramas tienen en comÃºn, conocido como el ancestro comÃºn o merge base.

D. Comparar el nÃºmero total de commits en cada rama para determinar la estrategia de fusiÃ³n mÃ¡s adecuada.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: Encontrar el ancestro comÃºn es fundamental para determinar los cambios a fusionar.

ğŸ§  Pregunta 22

Â¿QuÃ© indica la presencia de marcadores como <<<<<<<, =======, y >>>>>>> en un archivo despuÃ©s de un intento de fusiÃ³n en Git?

A. Que la fusiÃ³n se ha completado exitosamente sin ningÃºn conflicto.

B. Que Git ha detectado cambios conflictivos en esa secciÃ³n del archivo que requieren resoluciÃ³n manual por parte del desarrollador.

C. Que el archivo ha sido marcado para su eliminaciÃ³n despuÃ©s de la fusiÃ³n.

D. Que Git estÃ¡ esperando la confirmaciÃ³n del usuario para aplicar los cambios fusionados.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Estos marcadores delimitan las secciones conflictivas que necesitan intervenciÃ³n manual.

ğŸ§  Pregunta 23

Â¿CuÃ¡l es una limitaciÃ³n importante del algoritmo de fusiÃ³n "octopus" al fusionar mÃºltiples ramas?

A. Solo puede fusionar un mÃ¡ximo de tres ramas a la vez.

B. No es capaz de manejar conflictos entre mÃ¡s de dos ramas de forma automÃ¡tica.

C. Requiere que todas las ramas a fusionar tengan un ancestro comÃºn directo.

D. Solo se puede utilizar en repositorios con un historial lineal sin ramificaciones previas.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La fusiÃ³n octopus no resuelve conflictos complejos entre mÃºltiples ramas automÃ¡ticamente.

ğŸ§  Pregunta 24

Â¿CuÃ¡l es el principal propÃ³sito de utilizar git rebase -i antes de fusionar una rama de caracterÃ­sticas a la rama principal?

A. Asegurarse de que la rama principal estÃ© actualizada con los Ãºltimos cambios de la rama de caracterÃ­sticas.

B. Integrar todos los commits de la rama principal en la rama de caracterÃ­sticas.

C. Manipular el historial de la rama de caracterÃ­sticas para que sea mÃ¡s limpio y lineal antes de integrarlo en la rama principal.

D. Eliminar permanentemente la rama de caracterÃ­sticas despuÃ©s de la fusiÃ³n.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El rebase interactivo se usa para limpiar y reorganizar el historial de la rama de caracterÃ­sticas.

ğŸ§  Pregunta 25

Â¿En quÃ© escenario serÃ­a mÃ¡s Ãºtil la herramienta git cherry-pick?

A. Para fusionar todas las ramas de un repositorio en una sola.

B. Para revertir un commit especÃ­fico en la rama actual.

C. Para aplicar un commit particular de otra rama a la rama actual sin necesidad de fusionar toda la rama.

D. Para comparar los cambios entre dos commits consecutivos en la misma rama.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: Cherry-pick permite seleccionar e integrar commits individuales.

ğŸ§  Pregunta 26

Â¿CuÃ¡l es la diferencia fundamental entre git revert y git reset?

A. git revert se utiliza para deshacer cambios en archivos individuales, mientras que git reset afecta a commits completos.

B. git revert crea un nuevo commit que anula los cambios de un commit anterior, preservando el historial, mientras que git reset mueve el HEAD a un commit anterior, potencialmente alterando el historial.

C. git revert solo se puede usar en ramas locales, mientras que git reset se utiliza para deshacer cambios en ramas remotas.

D. git revert requiere una conexiÃ³n a internet, mientras que git reset es una operaciÃ³n local.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Revert crea un nuevo commit para deshacer, mientras que reset modifica el historial.

ğŸ§  Pregunta 27

Â¿QuÃ© tipo de informaciÃ³n se puede visualizar y manipular utilizando herramientas de interfaz grÃ¡fica (GUIs) para Git al resolver conflictos de fusiÃ³n?

A. Solo el contenido textual de los archivos conflictivos.

B. Las diferencias entre las ramas en conflicto de forma visual, permitiendo elegir quÃ© cambios conservar de cada rama de manera mÃ¡s intuitiva.

C. El nÃºmero de lÃ­neas modificadas en cada rama y el autor de los cambios.

D. La fecha y hora exacta de cada modificaciÃ³n en las ramas conflictivas.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Las GUIs facilitan la comparaciÃ³n visual y la selecciÃ³n de los cambios deseados.

ğŸ§  Pregunta 28

Â¿CÃ³mo contribuye la estructura del DAG a la eficiencia de las operaciones de fusiÃ³n en Git?

A. Permite comprimir el historial de commits para acelerar la comparaciÃ³n de ramas.

B. Facilita la identificaciÃ³n rÃ¡pida del ancestro comÃºn entre las ramas que se van a fusionar.

C. Asegura que las fusiones siempre se realicen de forma automÃ¡tica sin necesidad de intervenciÃ³n manual.

D. Permite reordenar los commits de diferentes ramas antes de la fusiÃ³n para evitar conflictos.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: El DAG estructura el historial de manera que el ancestro comÃºn puede encontrarse eficientemente.

ğŸ§  Pregunta 29

Â¿De quÃ© manera el uso de packfiles puede mejorar el rendimiento de un git clone de un repositorio grande?

A. Al descargar los objetos de forma individual, permitiendo una descarga mÃ¡s granular.

B. Al comprimir y empaquetar todos los objetos en un solo archivo para su transferencia, reduciendo el nÃºmero de conexiones y el tamaÃ±o total de la descarga.

C. Al descargar solo las ramas mÃ¡s recientes del repositorio.

D. Al verificar la integridad de cada objeto individualmente antes de descargarlo.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Los packfiles optimizan la transferencia al consolidar y comprimir los objetos.

ğŸ§  Pregunta 30

Â¿CuÃ¡l es la implicaciÃ³n de que Git trate a cada commit como una instantÃ¡nea del proyecto en un momento dado?

A. Que cada commit contiene una copia completa de todos los archivos del proyecto en ese estado.

B. Que Git solo guarda las diferencias entre commits para ahorrar espacio de almacenamiento.

C. Que es imposible volver a un estado anterior del proyecto representado por un commit.

D. Que los commits no estÃ¡n relacionados entre sÃ­ y se pueden manipular de forma independiente sin afectar al resto del historial.

âœ… Correcta: A

ğŸ§¾ ExplicaciÃ³n: Cada commit representa un estado completo del proyecto en el momento de su creaciÃ³n.

ğŸ§  Pregunta 31

Â¿QuÃ© ventaja ofrece el modelo peer-to-peer de Git en tÃ©rminos de resiliencia y seguridad de los datos?

A. Depender de un Ãºnico servidor central asegura la consistencia de los datos.

B. La replicaciÃ³n completa del historial en mÃºltiples mÃ¡quinas permite la recuperaciÃ³n del proyecto si el servidor original falla.

C. La necesidad de una conexiÃ³n constante a internet protege el repositorio de accesos no autorizados.

D. La estructura jerÃ¡rquica del sistema facilita la gestiÃ³n de permisos y el control de acceso.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La distribuciÃ³n del repositorio en mÃºltiples clones proporciona redundancia y facilita la recuperaciÃ³n en caso de fallos.

ğŸ§  Pregunta 32

Â¿CÃ³mo influye la estructura del DAG en la capacidad de Git para realizar fusiones eficientes?

A. Permite comparar el contenido de los archivos lÃ­nea por lÃ­nea de forma mÃ¡s rÃ¡pida.

B. Facilita la identificaciÃ³n del ancestro comÃºn mÃ¡s reciente entre las ramas que se van a fusionar.

C. Asegura que los commits se fusionen en el orden cronolÃ³gico exacto en que fueron creados.

D. Permite comprimir los commits antes de la fusiÃ³n para reducir el tamaÃ±o del historial.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La estructura del DAG facilita la bÃºsqueda del punto de divergencia entre las ramas.

ğŸ§  Pregunta 33

Â¿QuÃ© implicaciÃ³n tiene el hecho de que los hashes en Git dependan del contenido de los objetos?

A. Que los hashes son predecibles y fÃ¡ciles de memorizar.

B. Que cualquier modificaciÃ³n en el contenido de un objeto resultarÃ¡ en un hash diferente, lo que permite la detecciÃ³n de cambios.

C. Que objetos diferentes siempre tendrÃ¡n el mismo hash si fueron creados por el mismo autor.

D. Que los hashes solo se utilizan internamente y no son relevantes para el usuario.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La dependencia del contenido asegura la integridad y la trazabilidad a travÃ©s de los hashes Ãºnicos.

ğŸ§  Pregunta 34

Â¿CuÃ¡l es el principal desafÃ­o que la transiciÃ³n de SHA-1 a SHA-256 presenta para el ecosistema de Git?

A. La necesidad de cambiar todos los hashes existentes en los repositorios antiguos.

B. Asegurar la compatibilidad y la interoperabilidad entre repositorios y herramientas que aÃºn utilizan SHA-1 y aquellos que han migrado a SHA-256.

C. El aumento significativo en el tamaÃ±o de los hashes, lo que requiere mÃ¡s espacio de almacenamiento.

D. La pÃ©rdida de la capacidad de identificar objetos duplicados en el repositorio.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La coexistencia de ambos algoritmos requiere una gestiÃ³n cuidadosa de la compatibilidad.

ğŸ§  Pregunta 35

Â¿CÃ³mo optimiza el delta encoding las transferencias de datos en operaciones como git fetch o git pull?

A. Al comprimir todos los objetos del repositorio en un Ãºnico archivo antes de la transferencia.

B. Al enviar solo las diferencias entre los objetos que el receptor ya tiene y las nuevas versiones, en lugar de enviar los objetos completos.

C. Al priorizar la descarga de los commits mÃ¡s recientes.

D. Al verificar la integridad de los datos antes de iniciar la transferencia.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Enviar solo las diferencias reduce la cantidad de datos que necesitan ser transferidos.

ğŸ§  Pregunta 36

Â¿QuÃ© sucede durante el proceso de creaciÃ³n de un packfile en Git?

A. Se eliminan los objetos redundantes del repositorio para liberar espacio.

B. Se organiza el historial de commits en un formato lineal y secuencial.

C. Se identifican los objetos necesarios, se calculan las diferencias (deltas) entre ellos y se comprimen en un Ãºnico archivo.

D. Se envÃ­an todos los objetos del repositorio a un servidor remoto para su almacenamiento seguro.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La creaciÃ³n de packfiles implica la identificaciÃ³n, el cÃ¡lculo de deltas y la compresiÃ³n de los objetos.

ğŸ§  Pregunta 37

Â¿Por quÃ© es importante identificar el ancestro comÃºn al realizar una fusiÃ³n con la estrategia recursiva?

A. Para determinar quÃ© rama tiene los cambios mÃ¡s recientes.

B. Para asegurar que los commits se fusionen en el orden correcto de creaciÃ³n.

C. Para comparar los cambios realizados en cada rama desde ese punto y combinarlos de manera inteligente.

D. Para evitar la creaciÃ³n de un nuevo commit de fusiÃ³n.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El ancestro comÃºn es el punto de referencia para entender los cambios introducidos en cada rama.

ğŸ§  Pregunta 38

Â¿CuÃ¡l es una de las principales ventajas de utilizar un rebase interactivo antes de fusionar una rama en un entorno colaborativo?

A. Permite ocultar commits que contienen errores o informaciÃ³n sensible.

B. Facilita la creaciÃ³n de un historial de commits mÃ¡s limpio y lineal en la rama de caracterÃ­sticas, lo que simplifica el seguimiento y la comprensiÃ³n de los cambios al fusionarla con la rama principal.

C. Acelera el proceso de fusiÃ³n al evitar la creaciÃ³n de commits de fusiÃ³n adicionales.

D. Permite fusionar ramas que no tienen un ancestro comÃºn directo.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Un historial limpio facilita la colaboraciÃ³n y la comprensiÃ³n del desarrollo.

ğŸ§  Pregunta 39

Â¿En quÃ© se diferencia git cherry-pick de un git merge normal?

A. git cherry-pick integra todos los commits de una rama, mientras que git merge solo aplica commits especÃ­ficos.

B. git cherry-pick aplica commits especÃ­ficos de una rama a la rama actual, mientras que git merge integra toda una rama en la rama actual.

C. git cherry-pick modifica el historial de la rama de destino, mientras que git merge siempre crea un nuevo commit de fusiÃ³n.

D. git cherry-pick solo se puede utilizar para deshacer commits, mientras que git merge se utiliza para integrar cambios.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Cherry-pick se enfoca en commits individuales, mientras que merge integra ramas completas.

ğŸ§  Pregunta 40

Â¿CuÃ¡l es una buena prÃ¡ctica al usar git reset y por quÃ©?

A. Usarlo frecuentemente en ramas compartidas para mantener el historial limpio para todos.

B. Limitar su uso a ramas locales y privadas, ya que puede reescribir el historial que otros ya han sincronizado, causando problemas.

C. Utilizarlo siempre con la opciÃ³n --hard para asegurar una limpieza completa del historial.

D. Ejecutarlo automÃ¡ticamente despuÃ©s de cada git push para sincronizar el historial local y remoto.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Reescribir el historial en ramas compartidas puede generar inconsistencias y problemas para otros colaboradores.

ğŸ§  Pregunta 41

Â¿CÃ³mo ayuda la verificaciÃ³n de integridad basada en Ã¡rboles de Merkle a la seguridad de un repositorio Git distribuido?

A. Al cifrar el contenido de los archivos, haciÃ©ndolos ilegibles para usuarios no autorizados.

B. Al asegurar que cualquier alteraciÃ³n en cualquier parte del historial (archivos, directorios, commits) se detecte mediante la verificaciÃ³n de los hashes.

C. Al registrar la direcciÃ³n IP de cada usuario que realiza cambios en el repositorio.

D. Al requerir autenticaciÃ³n de dos factores para cada operaciÃ³n de escritura en el repositorio.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La estructura de hashes encadenados permite detectar cualquier manipulaciÃ³n del historial.

ğŸ§  Pregunta 42

Â¿QuÃ© papel juegan los blobs, los Ã¡rboles y los commits en la estructura de datos de Git basada en Ã¡rboles de Merkle?

A. Los blobs representan los metadatos del repositorio, los Ã¡rboles representan los archivos y los commits representan los directorios.

B. Los blobs representan los archivos individuales, los Ã¡rboles representan los directorios que contienen blobs y otros Ã¡rboles, y los commits apuntan a un Ã¡rbol raÃ­z que representa el estado del proyecto en ese momento.

C. Los Ã¡rboles representan las diferentes ramas del repositorio, los blobs representan los commits en cada rama y los commits representan la fusiÃ³n de las ramas.

D. Los blobs, los Ã¡rboles y los commits son simplemente diferentes formas de comprimir los datos del repositorio para ahorrar espacio.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Esta es la jerarquÃ­a fundamental de los objetos en Git.

ğŸ§  Pregunta 43

Â¿CÃ³mo maneja Git los archivos binarios en tÃ©rminos de delta encoding y almacenamiento en packfiles?

A. Los archivos binarios siempre se almacenan como objetos completos en los packfiles, ya que el delta encoding no es efectivo para ellos.

B. Git intenta aplicar delta encoding incluso a archivos binarios, comparando bloques de datos para encontrar similitudes.

C. Los archivos binarios se excluyen automÃ¡ticamente de los packfiles y se almacenan por separado.

D. Git convierte los archivos binarios a formato de texto antes de aplicar el delta encoding y almacenarlos en packfiles.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Git intenta optimizar el almacenamiento incluso de binarios buscando similitudes a nivel de bloques.

ğŸ§  Pregunta 44

Â¿CuÃ¡l es una posible desventaja de utilizar git rebase en ramas compartidas con otros colaboradores?

A. Puede hacer que la rama local se desincronice con la rama remota.

B. Puede reescribir el historial que otros ya han basado su trabajo, generando conflictos y confusiÃ³n.

C. Puede eliminar permanentemente commits importantes del historial.

D. Puede ralentizar significativamente las operaciones de Git.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La reescritura del historial en ramas compartidas es una prÃ¡ctica peligrosa.

ğŸ§  Pregunta 45

Â¿QuÃ© informaciÃ³n esencial contiene un objeto commit en Git?

A. El contenido de todos los archivos del proyecto en ese momento exacto.

B. El nombre del autor, la direcciÃ³n de correo electrÃ³nico, la fecha y hora, un mensaje descriptivo y una referencia al Ã¡rbol (tree) que representa la instantÃ¡nea del proyecto.

C. Una lista de todos los commits realizados posteriormente en la misma rama.

D. Las diferencias (deltas) entre este commit y el commit anterior.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Un commit contiene metadatos importantes sobre el cambio y su contexto.

ğŸ§  Pregunta 46

Â¿CÃ³mo asegura Git la integridad del historial completo del repositorio utilizando los hashes criptogrÃ¡ficos?

A. Al requerir una firma digital para cada commit realizado.

B. Al encadenar los hashes de los commits, donde cada commit apunta al hash de su padre (o padres), de manera que cualquier alteraciÃ³n en un commit cambiarÃ¡ su hash y, por ende, los hashes de todos sus descendientes.

C. Al comparar periÃ³dicamente los hashes de todos los objetos con una copia de seguridad almacenada en un servidor central.

D. Al cifrar el historial completo del repositorio utilizando una clave privada conocida solo por los colaboradores autorizados.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: El encadenamiento de hashes es fundamental para la integridad del historial.

ğŸ§  Pregunta 47

Â¿QuÃ© implicaciones tiene la inmutabilidad de los objetos en Git (una vez creados, su contenido no cambia)?

A. Que es imposible deshacer los cambios realizados en un commit.

B. Que cada cambio siempre resulta en la creaciÃ³n de un nuevo objeto con un hash diferente, lo que facilita el seguimiento y la integridad del historial.

C. Que los objetos deben ser copiados completamente cada vez que se realiza un commit, lo que puede aumentar el uso de espacio en disco.

D. Que los objetos no pueden ser compartidos entre diferentes commits o ramas.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La inmutabilidad asegura la trazabilidad y la consistencia del historial.

ğŸ§  Pregunta 48

Â¿CÃ³mo maneja Git la concurrencia y evita la corrupciÃ³n del repositorio cuando mÃºltiples usuarios realizan operaciones simultÃ¡neamente?

A. Mediante el uso de bloqueos (locks) en los archivos del repositorio.

B. Principalmente a travÃ©s de la naturaleza distribuida, donde los usuarios trabajan en sus copias locales y luego sincronizan los cambios, y mediante mecanismos para la gestiÃ³n de fusiones y conflictos.

C. Al requerir que todas las operaciones pasen por un servidor central que gestiona las transacciones de forma secuencial.

D. Al crear copias temporales del repositorio para cada usuario durante sus operaciones.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La naturaleza distribuida y las herramientas de gestiÃ³n de fusiones son clave para la concurrencia.

ğŸ§  Pregunta 49

Â¿CuÃ¡l es el beneficio de que Git realice la mayorÃ­a de las operaciones de forma local?

A. Reduce la carga en el servidor central del repositorio.

B. Permite realizar operaciones como commits, visualizaciÃ³n del historial y creaciÃ³n de ramas de forma rÃ¡pida, sin la latencia de la red.

C. Asegura que todos los desarrolladores trabajen siempre con la Ãºltima versiÃ³n del repositorio.

D. Simplifica la gestiÃ³n de permisos y el control de acceso al repositorio.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La localidad de las operaciones mejora significativamente la velocidad y la eficiencia.

ğŸ§  Pregunta 50

En un flujo de trabajo de Git tÃ­pico, Â¿cuÃ¡l es el propÃ³sito de una rama de "caracterÃ­sticas" (feature branch)?

A. Almacenar la versiÃ³n estable y principal del cÃ³digo.

B. Aislar el desarrollo de una nueva funcionalidad o correcciÃ³n de errores del cÃ³digo principal, permitiendo trabajar en paralelo sin afectar la estabilidad de la rama principal.

C. Mantener un registro de todos los cambios realizados en el repositorio por un desarrollador especÃ­fico.

D. Facilitar la implementaciÃ³n continua y la entrega continua (CI/CD).

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Las ramas de caracterÃ­sticas son fundamentales para el desarrollo aislado y paralelo.