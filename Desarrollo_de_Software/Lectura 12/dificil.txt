üß† Pregunta 61

Considerando el uso del rebase interactivo para limpiar el historial antes de una fusi√≥n, ¬øcu√°l ser√≠a el impacto a largo plazo en la colaboraci√≥n de un equipo si esta pr√°ctica se aplicara de forma inconsistente o sin una comunicaci√≥n clara?

A. Mejorar√≠a la eficiencia individual de los desarrolladores al tener historiales m√°s limpios en sus ramas locales.
B. Podr√≠a generar confusi√≥n y dificultar el seguimiento de los cambios para otros colaboradores si la historia compartida se reescribe inesperadamente.
C. No tendr√≠a un impacto significativo, ya que cada desarrollador puede elegir su propia estrategia de limpieza del historial.
D. Forzar√≠a a los desarrolladores a adoptar un flujo de trabajo m√°s estricto y estandarizado, mejorando la colaboraci√≥n general.

‚úÖ Correcta: B

üßæ Explicaci√≥n: Si el rebase interactivo se usa inconsistentemente o sin informar a los dem√°s, la reescritura de la historia en ramas compartidas puede llevar a desincronizaci√≥n, conflictos inesperados y dificultad para entender la evoluci√≥n del c√≥digo por parte de otros miembros del equipo.

üß† Pregunta 62

Si un equipo decide utilizar merges sin Fast-Forward de manera exclusiva, ¬øc√≥mo afectar√≠a esto la visualizaci√≥n del historial del proyecto en comparaci√≥n con un equipo que utiliza Fast-Forward merges siempre que sea posible?

A. El historial ser√≠a m√°s lineal y f√°cil de seguir en el equipo que usa Fast-Forward.
B. El historial mostrar√≠a expl√≠citamente cu√°ndo se integraron las ramas de caracter√≠sticas en el equipo que usa --no-ff, proporcionando m√°s contexto.
C. No habr√≠a una diferencia visual notable en el historial entre ambos equipos.
D. El equipo que usa --no-ff tendr√≠a un historial m√°s complejo y dif√≠cil de entender debido a la creaci√≥n constante de commits de merge.

‚úÖ Correcta: B

üßæ Explicaci√≥n: El uso constante de --no-ff crea commits de merge para cada integraci√≥n de rama, lo que visualmente preserva la existencia de las ramas de caracter√≠sticas y el momento de su integraci√≥n en la rama principal, ofreciendo un historial m√°s rico en contexto.

üß† Pregunta 63

En un escenario donde un error cr√≠tico se introduce en la rama principal y no se descubre inmediatamente, ¬øc√≥mo podr√≠a la combinaci√≥n de git log avanzado (con --graph, --decorate, --oneline) y git bisect ayudar a resolver el problema de manera eficiente?

A. git log permitir√≠a identificar r√°pidamente el commit sospechoso bas√°ndose en el mensaje, y git bisect permitir√≠a revertir ese commit.
B. git log ayudar√≠a a visualizar la l√≠nea de tiempo de los cambios y las fusiones, mientras que git bisect facilitar√≠a la localizaci√≥n del commit que introdujo el error a trav√©s de pruebas iterativas.
C. git log mostrar√≠a qui√©n realiz√≥ los cambios recientes, y git bisect permitir√≠a enviar una notificaci√≥n autom√°tica al desarrollador culpable.
D. Ambas herramientas ser√≠an in√∫tiles en este escenario; se requerir√≠a una revisi√≥n manual exhaustiva de todos los commits recientes.

‚úÖ Correcta: B

üßæ Explicaci√≥n: git log avanzado proporciona una visi√≥n estructurada de la historia, ayudando a identificar posibles puntos de origen del error, mientras que git bisect automatiza la b√∫squeda del commit espec√≠fico que introdujo el problema a trav√©s de la divisi√≥n y prueba del historial.

üß† Pregunta 64

Considerando la diferencia entre subm√≥dulos y subtrees, ¬øen qu√© tipo de proyecto ser√≠a m√°s ventajoso utilizar subtrees y por qu√©?

A. En proyectos con dependencias externas que se actualizan con frecuencia y donde se desea que los cambios se integren de forma m√°s transparente en el historial del proyecto principal.
B. En proyectos donde se necesita mantener una referencia estricta a una versi√≥n espec√≠fica de una biblioteca externa para garantizar la estabilidad.
C. En proyectos muy grandes con numerosos colaboradores, donde la gesti√≥n de dependencias debe ser lo m√°s aislada posible.
D. En proyectos donde el repositorio externo es mantenido por el mismo equipo y se considera una parte integral del proyecto principal.

‚úÖ Correcta: D

üßæ Explicaci√≥n: Los subtrees son m√°s adecuados cuando el proyecto externo se considera una parte integral del proyecto principal y se desea que su contenido evolucione junto con √©l en el mismo historial, facilitando las modificaciones y la integraci√≥n de cambios de manera m√°s directa.

üß† Pregunta 65

Si un desarrollador realiza accidentalmente un git reset --hard y luego utiliza el reflog para identificar el commit anterior de HEAD, ¬øqu√© implicaciones podr√≠a tener para otros colaboradores si ya hab√≠an basado su trabajo en el estado actual (despu√©s del reset)?

A. No habr√≠a ning√∫n impacto, ya que el reset --hard solo afecta al repositorio local del desarrollador.
B. Si el desarrollador hace push de su rama local reescrita, podr√≠a forzar a otros a realizar un rebase o reset en sus propias ramas para sincronizarse, lo que podr√≠a resultar en p√©rdida de trabajo si no se hace con cuidado.
C. El repositorio remoto rechazar√≠a el push del desarrollador, previniendo cualquier problema para los dem√°s.
D. Git fusionar√≠a autom√°ticamente los cambios del desarrollador con el trabajo de los dem√°s, resolviendo cualquier inconsistencia.

‚úÖ Correcta: B

üßæ Explicaci√≥n: Reescribir la historia que ya ha sido compartida (mediante push) puede causar serios problemas para otros colaboradores que hayan basado su trabajo en esa historia. Forzar un push con la historia reescrita obligar√° a los dem√°s a realinear sus ramas, lo que puede ser complejo y arriesgado.

üß† Pregunta 66

En un equipo que utiliza intensivamente ramas de caracter√≠sticas de corta duraci√≥n, ¬øc√≥mo podr√≠a el uso estrat√©gico del rebase interactivo antes de fusionar a la rama principal afectar la claridad del historial y la resoluci√≥n de conflictos futuros?

A. Har√≠a el historial m√°s confuso al reordenar los commits de las caracter√≠sticas.
B. Podr√≠a simplificar el historial al combinar commits relacionados y facilitar la resoluci√≥n de conflictos al tener cambios m√°s cohesivos.
C. Aumentar√≠a la probabilidad de conflictos durante la fusi√≥n debido a la modificaci√≥n de los timestamps de los commits.
D. No tendr√≠a un impacto significativo en la claridad del historial ni en la resoluci√≥n de conflictos.

‚úÖ Correcta: B

üßæ Explicaci√≥n: Al limpiar y organizar los commits de una rama de caracter√≠stica con rebase interactivo antes de la fusi√≥n, se puede crear un historial m√°s lineal y l√≥gico en la rama principal, lo que facilita la comprensi√≥n de los cambios introducidos por la caracter√≠stica y puede simplificar la resoluci√≥n de conflictos futuros al tener commits m√°s enfocados.

üß† Pregunta 67

Considerando el escenario donde se utiliza un script de Bash para automatizar git bisect, ¬øcu√°l es la principal ventaja de esta automatizaci√≥n en comparaci√≥n con la ejecuci√≥n manual de los comandos?

A. Permite a los desarrolladores que no est√°n familiarizados con git bisect utilizar la herramienta.
B. Agiliza el proceso al automatizar la prueba de cada commit, reduciendo el tiempo y el esfuerzo manual requerido.
C. Garantiza que el resultado de git bisect sea siempre m√°s preciso que la identificaci√≥n manual.
D. Permite integrar git bisect con otras herramientas de depuraci√≥n y an√°lisis de c√≥digo de forma m√°s sencilla.

‚úÖ Correcta: B

üßæ Explicaci√≥n: La automatizaci√≥n de git bisect con un script de pruebas elimina la necesidad de que el desarrollador pruebe manualmente cada commit y marque el resultado, lo que acelera significativamente el proceso de identificaci√≥n del commit que introdujo el error, especialmente en historiales largos.

üß† Pregunta 68

Si un equipo decide migrar de utilizar subm√≥dulos a subtrees para gestionar una dependencia externa, ¬øqu√© consideraciones importantes deber√≠an tener en cuenta durante la transici√≥n para evitar la p√©rdida de informaci√≥n o la corrupci√≥n del historial?

A. Deber√≠an simplemente eliminar el directorio del subm√≥dulo y agregar el subtree con la misma URL.
B. Deber√≠an asegurarse de haber fusionado todos los cambios pendientes del subm√≥dulo en el proyecto principal antes de la migraci√≥n y ser conscientes de c√≥mo se integrar√° el historial del subtree.
C. No hay consideraciones importantes; la migraci√≥n entre subm√≥dulos y subtrees es un proceso directo.
D. Deber√≠an crear un nuevo repositorio y copiar el c√≥digo del proyecto principal y la dependencia al nuevo repositorio utilizando subtrees desde el inicio.

‚úÖ Correcta: B

üßæ Explicaci√≥n: La migraci√≥n de subm√≥dulos a subtrees requiere cuidado, especialmente en relaci√≥n con los cambios no confirmados en el subm√≥dulo y c√≥mo se incorporar√° el historial del repositorio externo como un subtree en el historial del proyecto principal. Es crucial asegurarse de que no se pierdan cambios y comprender las implicaciones en el historial.

üß† Pregunta 69

En un proyecto donde varios desarrolladores trabajan en la misma funci√≥n y realizan numerosos commits locales antes de hacer push, ¬øc√≥mo podr√≠a el uso de git rebase -i para combinar sus commits relacionados antes del push afectar la revisi√≥n del c√≥digo por parte de otros miembros del equipo?

A. Har√≠a la revisi√≥n m√°s dif√≠cil al presentar un gran n√∫mero de commits individuales.
B. Facilitar√≠a la revisi√≥n al presentar un conjunto m√°s peque√±o de commits l√≥gicos y cohesivos que representan la implementaci√≥n completa de la funci√≥n o partes significativas de ella.
C. No tendr√≠a ning√∫n impacto en el proceso de revisi√≥n del c√≥digo.
D. Forzar√≠a al revisor a examinar cada peque√±o cambio individualmente, lo que llevar√≠a m√°s tiempo.

‚úÖ Correcta: B

üßæ Explicaci√≥n: Al combinar commits relacionados en unidades l√≥gicas m√°s grandes antes de la revisi√≥n, se facilita la comprensi√≥n del prop√≥sito y el contexto de los cambios, lo que puede hacer que el proceso de revisi√≥n del c√≥digo sea m√°s eficiente y efectivo.

üß† Pregunta 70

Si un equipo utiliza merges sin Fast-Forward y luego decide revertir una caracter√≠stica completa que fue introducida por una rama fusionada, ¬øc√≥mo simplificar√≠a el commit de merge creado por --no-ff este proceso de reversi√≥n en comparaci√≥n con si se hubieran utilizado Fast-Forward merges?

A. No habr√≠a diferencia en el proceso de reversi√≥n.
B. El commit de merge creado por --no-ff actuar√≠a como un √∫nico punto para revertir toda la caracter√≠stica con un solo comando (git revert -m 1 <hash_del_merge>).
C. Ser√≠a m√°s dif√≠cil revertir la caracter√≠stica debido a la existencia del commit de merge adicional.
D. Git autom√°ticamente identificar√≠a y revertir√≠a todos los commits individuales de la rama de la caracter√≠stica.

‚úÖ Correcta: B

üßæ Explicaci√≥n: El commit de merge creado por --no-ff representa la integraci√≥n completa de la rama de la caracter√≠stica. Esto permite revertir todos los cambios introducidos por esa rama con un solo git revert al commit de merge, especificando la rama principal como el "padre" a mantener (-m 1).

üß† Pregunta 71

En un flujo de trabajo donde se fomenta la creaci√≥n frecuente de ramas de caracter√≠sticas, pero la rama principal debe mantenerse siempre estable y con un historial limpio, ¬øc√≥mo se podr√≠an combinar estrat√©gicamente el rebase interactivo en las ramas de caracter√≠sticas y los merges sin Fast-Forward en la rama principal para lograr estos objetivos?

A. Rebasar las ramas de caracter√≠sticas contra la rama principal para obtener un historial lineal y luego usar Fast-Forward merge para integrarlas.
B. Rebasar las ramas de caracter√≠sticas para limpiar su historial y luego usar merge sin Fast-Forward en la rama principal para mantener la trazabilidad de cada caracter√≠stica como un bloque.
C. Usar merges sin Fast-Forward en las ramas de caracter√≠sticas para preservar su historial y luego rebasar la rama principal contra cada caracter√≠stica integrada para mantenerla lineal.
D. Evitar el rebase y los merges sin Fast-Forward por completo para simplificar el historial y facilitar la estabilidad de la rama principal.

‚úÖ Correcta: B

üßæ Explicaci√≥n: Rebasar las ramas de caracter√≠sticas ayuda a tener un historial limpio y lineal de los cambios de cada caracter√≠stica. Luego, al usar un merge sin Fast-Forward en la rama principal, se crea un commit de merge que representa la integraci√≥n de esa caracter√≠stica, manteniendo la trazabilidad de cu√°ndo y c√≥mo se a√±adi√≥, incluso si la rama principal ha avanzado.

üß† Pregunta 72

Si un equipo experimenta frecuentes problemas al intentar comprender la historia de los cambios en archivos espec√≠ficos, ¬øc√≥mo podr√≠a la combinaci√≥n del uso regular de mensajes de commit claros y descriptivos con el uso estrat√©gico de git log -L mejorar esta situaci√≥n?

A. Los mensajes de commit claros har√≠an innecesario el uso de git log -L.
B. git log -L mostrar√≠a solo los commits con mensajes relevantes al archivo, filtrando el ruido.
C. Los mensajes de commit claros proporcionar√≠an el contexto general de los cambios, mientras que git log -L permitir√≠a rastrear la evoluci√≥n de l√≠neas espec√≠ficas de c√≥digo y entender el por qu√© de los cambios en detalle.
D. La combinaci√≥n de ambos no tendr√≠a un impacto significativo en la comprensi√≥n del historial de archivos.

‚úÖ Correcta: C

üßæ Explicaci√≥n: Los buenos mensajes de commit ofrecen una visi√≥n general del prop√≥sito de cada cambio. Al combinarlos con git log -L, que permite ver la historia de l√≠neas espec√≠ficas, se puede obtener una comprensi√≥n profunda tanto del contexto general como de los detalles de c√≥mo ha evolucionado el c√≥digo en un archivo.

üß† Pregunta 73

En un proyecto donde se utiliza git bisect para encontrar la causa de una regresi√≥n, y el script de pruebas automatizado devuelve resultados inconsistentes para algunos commits intermedios, ¬øc√≥mo deber√≠a el desarrollador proceder para asegurar la identificaci√≥n correcta del commit problem√°tico?

A. Asumir que el primer commit marcado como "malo" es la causa de la regresi√≥n.
B. Ejecutar las pruebas manualmente varias veces para esos commits inconsistentes y basar la decisi√≥n en la mayor√≠a de los resultados.
C. Reiniciar la sesi√≥n de git bisect y probar solo los commits m√°s recientes.
D. Marcar los commits inconsistentes como "skip" y esperar que git bisect pueda aislar el error con la informaci√≥n restante.

‚úÖ Correcta: B

üßæ Explicaci√≥n: La inconsistencia en los resultados de las pruebas sugiere un problema que no est√° directamente relacionado con un cambio de c√≥digo espec√≠fico (podr√≠a ser un problema ambiental o una prueba no determinista). En estos casos, la mejor estrategia es intentar determinar el resultado m√°s probable ejecutando las pruebas varias veces para esos commits problem√°ticos.

üß† Pregunta 74

Considerando el reflog como una red de seguridad para acciones en Git, ¬øen qu√© escenario espec√≠fico su utilidad ser√≠a m√°s evidente para recuperar un trabajo que de otra manera se considerar√≠a perdido?

A. Cuando se elimina un archivo por error y no se ha realizado un commit.
B. Cuando se realiza un git commit --amend y se sobrescribe el commit anterior con errores.
C. Cuando se realiza un git reset --hard a una versi√≥n anterior y luego se quiere recuperar el estado en el que se estaba antes del reset.
D. Cuando se olvida en qu√© rama se realizaron ciertos cambios locales.

‚úÖ Correcta: C

üßæ Explicaci√≥n: El reflog rastrea los movimientos de HEAD, incluyendo los resets. Si accidentalmente se revierte el repositorio a un estado anterior con reset --hard, el reflog contendr√° una entrada que apunta al estado justo antes del reset, permitiendo volver a ese punto.

üß† Pregunta 75

Si un equipo decide utilizar subm√≥dulos para incluir una biblioteca externa, pero necesita realizar modificaciones locales a esa biblioteca para adaptarla a su proyecto, ¬øcu√°l es la estrategia recomendada para gestionar estos cambios a largo plazo y facilitar futuras actualizaciones de la biblioteca?

A. Modificar los archivos directamente en el directorio del subm√≥dulo y esperar que las futuras actualizaciones no entren en conflicto.
B. Hacer fork del repositorio de la biblioteca externa, realizar las modificaciones en el fork, y luego usar la URL del fork al agregar el subm√≥dulo. Las actualizaciones se gestionar√≠an fusionando cambios del repositorio original al fork.
C. Evitar el uso de subm√≥dulos y copiar directamente el c√≥digo de la biblioteca en el proyecto principal para tener control total sobre las modificaciones.
D. Utilizar subtrees en lugar de subm√≥dulos, ya que permiten una integraci√≥n m√°s directa de las modificaciones.

‚úÖ Correcta: B

üßæ Explicaci√≥n: Hacer fork del repositorio externo permite realizar modificaciones locales sin afectar el repositorio original y facilita la gesti√≥n de futuras actualizaciones al permitir la fusi√≥n de cambios desde el repositorio original al fork modificado. Luego, el proyecto principal utiliza el fork como subm√≥dulo.

üß† Pregunta 76

En un proyecto que utiliza subtrees para integrar varios componentes internos que se desarrollan por separado, ¬øc√≥mo se podr√≠a asegurar la coherencia entre las versiones de estos componentes cuando se realiza un nuevo lanzamiento del proyecto principal?

A. Asegur√°ndose de que la rama principal del repositorio del proyecto principal siempre apunte a la √∫ltima versi√≥n de las ramas principales de los subtrees.
B. Utilizando etiquetas (tags) en los repositorios de los subtrees para marcar las versiones que corresponden a un lanzamiento espec√≠fico del proyecto principal y referenciando esos tags al actualizar los subtrees.
C. Fusionando continuamente los cambios de los subtrees en la rama principal del proyecto principal para que siempre est√©n sincronizados.
D. Evitando el uso de subtrees para componentes internos y gestion√°ndolos como dependencias separadas.

‚úÖ Correcta: B

üßæ Explicaci√≥n: El uso de etiquetas en los repositorios de los subtrees permite marcar puntos espec√≠ficos en el tiempo que corresponden a una versi√≥n particular del componente. Al referenciar estas etiquetas al actualizar los subtrees en el proyecto principal para un lanzamiento, se asegura la coherencia de las versiones de los componentes.

üß† Pregunta 77

Si un desarrollador est√° trabajando en una rama de caracter√≠stica y realiza varios commits peque√±os e incrementales. Antes de fusionar esta rama a la principal, decide usar git rebase -i para combinarlos en un solo commit m√°s significativo. ¬øQu√© consideraciones deber√≠a tener sobre el mensaje de este commit combinado para que sea √∫til para futuros desarrolladores que consulten el historial?

A. Deber√≠a simplemente usar el mensaje del primer commit de la serie.
B. Deber√≠a incluir una lista de todos los mensajes de los commits combinados.
C. Deber√≠a escribir un mensaje conciso y de alto nivel que describa el resultado final de todos los cambios combinados, en lugar de los pasos individuales.
D. No importa el mensaje, ya que los commits individuales ya no estar√°n visibles en la historia principal.

‚úÖ Correcta: C

üßæ Explicaci√≥n: El objetivo de combinar commits es presentar un cambio l√≥gico y completo. El mensaje del commit combinado debe reflejar el resultado final de esos cambios, proporcionando una comprensi√≥n clara de la funcionalidad o la correcci√≥n que se introdujo, sin la necesidad de revisar los pasos intermedios.

üß† Pregunta 78

En un proyecto con un gran n√∫mero de colaboradores y una alta frecuencia de commits, ¬øc√≥mo podr√≠a el uso estrat√©gico de herramientas de visualizaci√≥n del historial de Git (como las integradas en IDEs o herramientas externas) complementar los comandos de l√≠nea como git log avanzado para facilitar la comprensi√≥n del flujo de trabajo y la identificaci√≥n de problemas?

A. Las herramientas de visualizaci√≥n son principalmente para principiantes y no ofrecen ventajas sobre la l√≠nea de comandos para usuarios avanzados.
B. Las herramientas de visualizaci√≥n pueden ofrecer una representaci√≥n gr√°fica m√°s intuitiva de las ramas, merges y el flujo de los cambios a lo largo del tiempo, lo que puede facilitar la identificaci√≥n de patrones o anomal√≠as que ser√≠an m√°s dif√≠ciles de discernir solo con la salida de texto de git log.
C. El uso de herramientas de visualizaci√≥n ralentizar√≠a el proceso de revisi√≥n del historial en comparaci√≥n con la rapidez de la l√≠nea de comandos.
D. Las herramientas de visualizaci√≥n solo muestran la misma informaci√≥n que git log pero con un formato diferente, sin ofrecer ninguna ventaja anal√≠tica adicional.

‚úÖ Correcta: B

üßæ Explicaci√≥n: Las herramientas de visualizaci√≥n pueden transformar la informaci√≥n textual del historial de Git en representaciones gr√°ficas, lo que facilita la comprensi√≥n de relaciones complejas entre ramas, la identificaci√≥n de l√≠neas de desarrollo paralelas, y la visualizaci√≥n del impacto de los merges y rebases de una manera m√°s intuitiva que la salida de texto de git log.

üß† Pregunta 79

Si un equipo decide no utilizar git rebase en ramas compartidas debido al riesgo de reescritura de la historia, pero a√∫n desea mantener un historial limpio en la rama principal, ¬øqu√© estrategia de merge podr√≠an adoptar para lograr un equilibrio entre ambos objetivos?

A. Utilizar siempre Fast-Forward merges para evitar la creaci√≥n de commits de merge innecesarios.
B. Utilizar merges sin Fast-Forward para preservar la historia de cada rama de caracter√≠stica como un bloque al integrarla en la principal.
C. Realizar merges regulares y luego usar git filter-branch en la rama principal para eliminar commits innecesarios.
D. Fusionar todas las ramas de caracter√≠sticas en una rama de integraci√≥n separada y luego rebasar la rama principal contra esta rama de integraci√≥n.

‚úÖ Correcta: B

üßæ Explicaci√≥n: El merge sin Fast-Forward crea un commit de merge expl√≠cito que une la rama de caracter√≠stica a la principal, preservando la historia de la caracter√≠stica como un bloque en el gr√°fico del historial, incluso si la rama principal ha avanzado. Esto mantiene la trazabilidad sin reescribir la historia ya compartida de la rama principal.

üß† Pregunta 80

En un proyecto que depende de varios subm√≥dulos, y se necesita actualizar un subm√≥dulo espec√≠fico a la √∫ltima versi√≥n disponible en su repositorio remoto, ¬øqu√© secuencia de comandos ser√≠a la m√°s apropiada para realizar esta tarea de forma segura y registrar el cambio en el repositorio principal?

A. cd <ruta_del_subm√≥dulo>, git pull, cd .., git add <ruta_del_subm√≥dulo>, git commit -m "Actualiza subm√≥dulo <nombre>"
B. git submodule update --remote <ruta_del_subm√≥dulo>, git add <ruta_del_subm√≥dulo>, git commit -m "Actualiza subm√≥dulo <nombre>"
C. git submodule foreach 'git pull', git add .gitmodules, git commit -m "Actualiza todos los subm√≥dulos"
D. git submodule sync, git submodule update --init --recursive, git commit -am "Sincroniza y actualiza subm√≥dulos"

‚úÖ Correcta: B

üßæ Explicaci√≥n: git submodule update --remote <ruta_del_subm√≥dulo> busca la √∫ltima confirmaci√≥n en la rama rastreada del repositorio remoto del subm√≥dulo y actualiza la referencia en el repositorio principal. Luego, es necesario hacer git add a la ruta del subm√≥dulo y git commit para registrar esta actualizaci√≥n en el repositorio principal.

üß† Pregunta 81

Considerando un equipo que adopta el uso de git blame de forma regular durante las revisiones de c√≥digo, ¬øc√≥mo podr√≠a esta pr√°ctica influir en la responsabilidad del equipo sobre la calidad del c√≥digo y la comprensi√≥n de las decisiones de implementaci√≥n pasadas?

A. Disminuir√≠a la responsabilidad individual al diluir la autor√≠a de cada l√≠nea de c√≥digo.
B. Fomentar√≠a una mayor responsabilidad al hacer m√°s transparente qui√©n realiz√≥ cada cambio y cu√°ndo, facilitando la discusi√≥n informada sobre decisiones de dise√±o y la identificaci√≥n de posibles introductores de errores.
C. No tendr√≠a un impacto significativo en la responsabilidad o la comprensi√≥n del historial.
D. Har√≠a que las revisiones de c√≥digo se centren m√°s en la persona que escribi√≥ el c√≥digo que en la calidad del c√≥digo en s√≠.

‚úÖ Correcta: B

üßæ Explicaci√≥n: Al hacer visible la autor√≠a de cada l√≠nea de c√≥digo, git blame puede fomentar una mayor sensaci√≥n de responsabilidad sobre el c√≥digo escrito. Tambi√©n proporciona contexto sobre cu√°ndo y por qu√© se realizaron ciertos cambios, lo que enriquece la discusi√≥n durante las revisiones de c√≥digo y ayuda a comprender las decisiones pasadas.

üß† Pregunta 82

En un escenario donde un equipo utiliza un script de Bash para automatizar tareas comunes de Git, incluyendo git bisect, ¬øqu√© consideraciones √©ticas deber√≠an tenerse en cuenta al analizar los resultados de git bisect y la identificaci√≥n del commit culpable?

A. El resultado de git bisect deber√≠a ser considerado como la verdad absoluta y el √∫nico factor para determinar la responsabilidad.
B. Deber√≠a utilizarse como una herramienta para comprender la historia del error y facilitar la correcci√≥n, en lugar de se√±alar culpables o asignar culpas.
C. Los resultados de git bisect deber√≠an hacerse p√∫blicos para fomentar la transparencia y la rendici√≥n de cuentas.
D. El equipo deber√≠a centrarse en corregir el error lo m√°s r√°pido posible, sin prestar atenci√≥n a la identificaci√≥n del commit culpable.

‚úÖ Correcta: B

üßæ Explicaci√≥n: git bisect es una herramienta para ayudar a comprender c√≥mo se introdujo un error. El enfoque √©tico debe estar en la colaboraci√≥n para corregir el problema, utilizando la informaci√≥n del commit culpable para entender el contexto y evitar errores similares en el futuro, en lugar de asignar culpa individual.

üß† Pregunta 83

Si un desarrollador utiliza el reflog para recuperar un conjunto de commits que hab√≠an sido eliminados accidentalmente de una rama local, ¬øqu√© implicaciones podr√≠a tener esta recuperaci√≥n si, mientras tanto, otros desarrolladores hab√≠an continuado trabajando y haciendo push a la misma rama remota?

A. No habr√≠a ning√∫n problema, ya que Git fusionar√≠a autom√°ticamente los commits recuperados con los cambios remotos.
B. El desarrollador podr√≠a necesitar realizar un rebase o un merge para integrar sus commits recuperados con los cambios remotos, lo que podr√≠a generar conflictos si hay ediciones superpuestas.
C. El push de los commits recuperados ser√≠a rechazado por el repositorio remoto para evitar la reescritura de la historia.
D. Los commits recuperados aparecer√≠an como una rama separada en el repositorio remoto.

‚úÖ Correcta: B

üßæ Explicaci√≥n: Si la rama remota ha avanzado mientras el desarrollador recuperaba sus commits perdidos, la historia local del desarrollador diverger√° de la remota. Para integrar sus cambios recuperados, necesitar√° sincronizar su rama local con la remota, lo que probablemente requerir√° un rebase (si desea una historia lineal) o un merge, y podr√≠a resultar en la resoluci√≥n de conflictos.

üß† Pregunta 84

En un proyecto que utiliza subm√≥dulos para gestionar dependencias, y se actualiza el repositorio principal a una nueva versi√≥n que requiere una versi√≥n espec√≠fica de uno de los subm√≥dulos, ¬øc√≥mo se asegurar√≠a el equipo de que todos los desarrolladores utilicen la versi√≥n correcta del subm√≥dulo al clonar o actualizar el proyecto?

A. Simplemente documentando la versi√≥n requerida del subm√≥dulo en el README del proyecto.
B. Asegur√°ndose de que el commit registrado en el repositorio principal para el subm√≥dulo apunte a la versi√≥n correcta en el repositorio del subm√≥dulo. Los desarrolladores necesitar√≠an usar git submodule update --init --recursive para obtener esa versi√≥n espec√≠fica.
C. Incluyendo el c√≥digo del subm√≥dulo directamente en el repositorio principal para evitar problemas de versiones.
D. Forzando una actualizaci√≥n autom√°tica del subm√≥dulo cada vez que se hace git pull en el repositorio principal.

‚úÖ Correcta: B

üßæ Explicaci√≥n: La clave para asegurar la coherencia de la versi√≥n del subm√≥dulo es que el repositorio principal registre el commit espec√≠fico del subm√≥dulo que se debe utilizar. Los desarrolladores deben inicializar y actualizar sus subm√≥dulos para que coincidan con este commit registrado.

üß† Pregunta 85

Si un equipo decide migrar de subtrees a subm√≥dulos para gestionar una dependencia externa, ¬øqu√© beneficios podr√≠an esperar obtener de este cambio en t√©rminos de aislamiento de la dependencia y gesti√≥n de sus actualizaciones?

A. Una integraci√≥n m√°s directa del c√≥digo de la dependencia en el proyecto principal.
B. Un historial m√°s limpio y simplificado del proyecto principal.
C. Una gesti√≥n m√°s expl√≠cita y aislada de la dependencia, con la capacidad de referenciar commits espec√≠ficos y facilitar las actualizaciones sin mezclar el historial de la dependencia con el del proyecto principal.
D. Actualizaciones autom√°ticas de la dependencia a la √∫ltima versi√≥n disponible.

‚úÖ Correcta: C

üßæ Explicaci√≥n: Los subm√≥dulos proporcionan un mayor aislamiento de la dependencia, ya que se gestionan como un repositorio separado dentro del principal, con un enlace a un commit espec√≠fico. Esto facilita la gesti√≥n de versiones y las actualizaciones de la dependencia de forma m√°s controlada y sin saturar el historial del proyecto principal.

üß† Pregunta 86

En un proyecto donde se realizan merges sin Fast-Forward para mantener la trazabilidad de las ramas de caracter√≠sticas, pero el gr√°fico del historial se vuelve muy complejo con el tiempo, ¬øqu√© estrategias podr√≠an utilizarse para navegar y comprender este historial de manera m√°s efectiva?

A. Convertir todos los merges sin Fast-Forward a Fast-Forward merges retroactivamente.
B. Utilizar herramientas de visualizaci√≥n del historial de Git que permitan filtrar y analizar el gr√°fico de ramas y merges.
C. Ignorar el gr√°fico del historial y centrarse √∫nicamente en los mensajes de commit.
D. Rebasar toda la rama principal para obtener un historial lineal.

‚úÖ Correcta: B

üßæ Explicaci√≥n: Las herramientas de visualizaci√≥n del historial de Git est√°n dise√±adas para manejar gr√°ficos complejos de ramas y merges. Permiten filtrar por rama, autor, fecha, etc., y ofrecen una representaci√≥n visual que puede facilitar la comprensi√≥n del flujo de trabajo y la identificaci√≥n de la integraci√≥n de caracter√≠sticas.

üß† Pregunta 87

Si un equipo decide utilizar un script de Bash para automatizar la creaci√≥n de ramas de caracter√≠sticas basadas en tickets de un sistema de seguimiento de issues, ¬øqu√© ventajas podr√≠a ofrecer esta automatizaci√≥n en t√©rminos de consistencia y eficiencia del flujo de trabajo?

A. Reducir√≠a la necesidad de que los desarrolladores comprendan el sistema de seguimiento de issues.
B. Asegurar√≠a que los nombres de las ramas sigan una convenci√≥n est√°ndar, vincular√≠a autom√°ticamente las ramas a los tickets correspondientes y posiblemente configurar√≠a el entorno de desarrollo adecuado, ahorrando tiempo y reduciendo errores manuales.
C. Permitir√≠a que los no desarrolladores creen ramas de caracter√≠sticas.
D. Har√≠a que el proceso de creaci√≥n de ramas sea m√°s lento debido a la sobrecarga del script.

‚úÖ Correcta: B

üßæ Explicaci√≥n: La automatizaci√≥n de la creaci√≥n de ramas puede imponer consistencia en los nombres de las ramas, vincularlas directamente a los issues relevantes para una mejor trazabilidad y automatizar tareas de configuraci√≥n, lo que mejora la eficiencia y reduce la posibilidad de errores humanos.

üß† Pregunta 88

En un proyecto que utiliza extensivamente el reflog, ¬øc√≥mo se podr√≠a educar a los nuevos miembros del equipo sobre su utilidad y cu√°ndo ser√≠a m√°s apropiado recurrir a √©l para resolver problemas o recuperar trabajo?

A. Explic√°ndoles que es una herramienta avanzada que solo deben usar los desarrolladores experimentados.
B. Proporcionando documentaci√≥n clara y ejemplos de casos de uso donde el reflog ha sido crucial para la recuperaci√≥n de trabajo perdido o la comprensi√≥n de cambios inesperados en el historial.
C. Desactivando el reflog para evitar confusiones a los nuevos miembros del equipo.
D. Asegur√°ndose de que los nuevos miembros del equipo solo utilicen comandos de Git de alto nivel a trav√©s de una GUI.

‚úÖ Correcta: B

üßæ Explicaci√≥n: La mejor manera de educar sobre el reflog es a trav√©s de documentaci√≥n clara y ejemplos pr√°cticos que ilustren su poder para deshacer acciones accidentales o rastrear cambios en el estado del repositorio que no se reflejan directamente en el historial de commits.

üß† Pregunta 89

Si un equipo decide no rebasar ramas compartidas, pero a√∫n quiere tener un historial lineal en la rama principal, ¬øqu√© implicaciones tendr√≠a la adopci√≥n de una pol√≠tica de "squash merge" de las ramas de caracter√≠sticas al fusionarlas a la principal?

A. Se mantendr√≠a la historia detallada de cada commit en la rama de caracter√≠stica en la rama principal.
B. La rama principal tendr√≠a un historial lineal, pero se perder√≠a la historia detallada de los commits individuales de cada caracter√≠stica, quedando solo un commit de merge con un mensaje que resume la caracter√≠stica.
C. Se evitar√≠an los commits de merge por completo, resultando en un historial m√°s limpio.
D. Se requerir√≠a una resoluci√≥n de conflictos m√°s frecuente durante la fusi√≥n.

‚úÖ Correcta: B

üßæ Explicaci√≥n: El "squash merge" combina todos los commits de una rama de caracter√≠stica en un √∫nico commit al fusionarla a la rama principal. Esto resulta en un historial lineal en la rama principal, pero se pierde la granularidad de los commits individuales de la caracter√≠stica, que solo permanecen en la rama de la caracter√≠stica (si no se elimina).

üß† Pregunta 90

En un proyecto que utiliza m√∫ltiples subm√≥dulos, ¬øqu√© estrategia se podr√≠a implementar para asegurar que al hacer checkout de una rama espec√≠fica del proyecto principal, se utilicen las versiones de los subm√≥dulos que eran las correctas en el momento en que se cre√≥ o se actualiz√≥ por √∫ltima vez esa rama del proyecto principal?

A. Actualizar todos los subm√≥dulos a la √∫ltima versi√≥n cada vez que se cambia de rama en el proyecto principal.
B. Asegurarse de que los commits en la rama del proyecto principal registren los commits espec√≠ficos de los subm√≥dulos que eran actuales en ese momento. Al hacer checkout de una rama antigua, los subm√≥dulos deber√≠an inicializarse y actualizarse a las versiones registradas en los commits de esa rama.
C. Mantener una rama separada para cada versi√≥n de los subm√≥dulos utilizada por el proyecto principal.
D. Incluir el c√≥digo de todos los subm√≥dulos directamente en el repositorio principal para evitar problemas de versiones.

‚úÖ Correcta: B

üßæ Explicaci√≥n: La clave para mantener la coherencia de las versiones de los subm√≥dulos al cambiar entre ramas del proyecto principal es que cada commit del proyecto principal debe registrar las versiones espec√≠ficas (commits) de los subm√≥dulos que eran correctas en ese momento. Al hacer checkout de una rama, los subm√≥dulos deben actualizarse a las versiones apuntadas por los commits de esa rama.