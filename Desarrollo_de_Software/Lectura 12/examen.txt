üß† Pregunta 91 (2 puntos)

Rebase interactivo y colaboraci√≥n

Un equipo de desarrollo est√° utilizando intensivamente ramas de caracter√≠sticas de larga duraci√≥n. Antes de integrar estas ramas en la principal, cada desarrollador realiza un rebase interactivo para limpiar su historial local.

a) Describe un escenario espec√≠fico donde esta pr√°ctica, aunque bienintencionada, podr√≠a generar complicaciones significativas para la colaboraci√≥n dentro del equipo. (1 punto)
b) Prop√≥n una estrategia de comunicaci√≥n o un conjunto de directrices que el equipo podr√≠a implementar para mitigar los riesgos asociados con el rebase interactivo en este contexto. (1 punto)

‚úÖ Correcta: (La respuesta debe abordar los riesgos de reescritura de historia compartida y proponer soluciones como comunicaci√≥n clara y evitar rebasar commits ya publicados).

üßæ Explicaci√≥n: El rebase interactivo en ramas compartidas puede causar problemas de sincronizaci√≥n y p√©rdida de trabajo para otros colaboradores. Una buena estrategia implica comunicar las intenciones de rebase, evitar rebasar commits ya publicados y, en algunos casos, optar por merges sin Fast-Forward para mantener la trazabilidad.

üß† Pregunta 92 (2 puntos)

Merge avanzado y flujo de trabajo

Un proyecto tiene dos ramas principales activas: main para la versi√≥n estable y next para el desarrollo de la pr√≥xima versi√≥n. Se han completado varias caracter√≠sticas en ramas separadas y ahora deben integrarse primero en next y luego, selectivamente, en main.

a) Describe c√≥mo se podr√≠a utilizar un merge sin Fast-Forward para integrar una rama de caracter√≠stica en next, destacando los beneficios de este enfoque en este flujo de trabajo. (1 punto)
b) Explica c√≥mo se podr√≠a luego integrar solo un commit espec√≠fico de la rama de caracter√≠stica (ya fusionada en next) a la rama main, y qu√© herramienta de Git permitir√≠a realizar esta acci√≥n. (1 punto)

‚úÖ Correcta: (La respuesta debe explicar el uso de --no-ff para trazabilidad en next y el uso de cherry-pick para integrar commits espec√≠ficos en main).

üßæ Explicaci√≥n: El merge sin Fast-Forward en next mantiene la historia de la caracter√≠stica. Para integrar un commit espec√≠fico en main, se puede usar git cherry-pick para aplicar ese commit sin traer toda la rama.

üß† Pregunta 93 (2 puntos)

Herramientas de diagn√≥stico y resoluci√≥n de problemas

Un desarrollador introduce un error en el c√≥digo, pero no se da cuenta hasta varios commits despu√©s. El equipo decide utilizar git bisect para encontrar el commit culpable.

a) Describe brevemente el proceso de git bisect, incluyendo los comandos clave y c√≥mo el equipo colaborar√≠a para identificar el commit problem√°tico. (1 punto)
b) Una vez identificado el commit, ¬øc√≥mo podr√≠a el desarrollador utilizar git blame y git log -L para comprender mejor el cambio que introdujo el error y su contexto? (1 punto)

‚úÖ Correcta: (La respuesta debe describir los pasos de git bisect y c√≥mo git blame muestra la autor√≠a de las l√≠neas y git log -L la evoluci√≥n de la funci√≥n).

üßæ Explicaci√≥n: git bisect usa b√∫squeda binaria para encontrar el commit. git blame ayuda a ver qui√©n modific√≥ las l√≠neas del error, y git log -L muestra la historia de la funci√≥n afectada.

üß† Pregunta 94 (2 puntos)

Reflog y recuperaci√≥n de errores

Un desarrollador ejecuta accidentalmente un git reset --hard HEAD~3 en su rama local, eliminando varios commits importantes que a√∫n no hab√≠an sido compartidos.

a) Explica c√≥mo el desarrollador podr√≠a utilizar el reflog para identificar los commits perdidos y recuperar su trabajo. Incluye el comando clave para ver el reflog y la estrategia para restaurar la rama al estado deseado. (1 punto)
b) ¬øQu√© advertencia importante se debe tener en cuenta si estos commits eliminados ya hubieran sido enviados a un repositorio remoto compartido? (1 punto)

‚úÖ Correcta: (La respuesta debe explicar c√≥mo listar el reflog y usar git reset --hard HEAD@{n} para recuperar, y advertir sobre los riesgos de reescribir historia remota).

üßæ Explicaci√≥n: El reflog rastrea los cambios en HEAD. Se puede usar para encontrar el punto antes del reset y volver a √©l. Si los commits ya estaban en remoto, forzar un push puede causar problemas a otros.

üß† Pregunta 95 (2 puntos)

Subm√≥dulos y gesti√≥n de dependencias

Un proyecto utiliza un subm√≥dulo para incluir una biblioteca externa. El equipo necesita actualizar la biblioteca a una nueva versi√≥n.

a) Describe los pasos necesarios para actualizar el subm√≥dulo a la √∫ltima versi√≥n de su rama remota y c√≥mo se registrar√≠a este cambio en el repositorio principal del proyecto. (1 punto)
b) ¬øCu√°l es una posible desventaja de utilizar subm√≥dulos en comparaci√≥n con subtrees en t√©rminos de la experiencia del desarrollador al clonar el proyecto por primera vez? (1 punto)

‚úÖ Correcta: (La respuesta debe detallar los comandos git submodule update --remote y el commit en el principal, y mencionar la necesidad de inicializar y actualizar subm√≥dulos al clonar).

üßæ Explicaci√≥n: Para actualizar un subm√≥dulo, se usa git submodule update --remote y luego se commite el cambio en el repositorio principal. Clonar un proyecto con subm√≥dulos requiere un paso adicional para inicializar y actualizar los subm√≥dulos.

üß† Pregunta 96 (2 puntos)

Subtrees e integraci√≥n de proyectos

Un proyecto principal necesita integrar el c√≥digo de otro repositorio interno como un subtree. Este repositorio interno se actualiza con frecuencia y el equipo desea incorporar estos cambios de manera regular.

a) Describe el comando y el proceso para agregar el repositorio interno como un subtree al proyecto principal, especificando la importancia del prefijo. (1 punto)
b) Explica c√≥mo se realizar√≠an las actualizaciones posteriores del subtree con los cambios del repositorio interno y qu√© opci√≥n se podr√≠a utilizar para mantener un historial m√°s limpio en el proyecto principal durante estas actualizaciones. (1 punto)

‚úÖ Correcta: (La respuesta debe detallar git subtree add con el prefijo y git subtree pull con la opci√≥n --squash para un historial limpio).

üßæ Explicaci√≥n: git subtree add integra el repositorio externo en un subdirectorio (prefijo). Las actualizaciones se realizan con git subtree pull. La opci√≥n --squash combina los commits del subtree en uno solo en el proyecto principal.

üß† Pregunta 97 (2 puntos)

Automatizaci√≥n con scripts

Un equipo desea automatizar la tarea de verificar que todos los mensajes de commit sigan un formato espec√≠fico antes de ser aceptados.

a) Describe en pseudoc√≥digo c√≥mo se podr√≠a implementar un hook pre-commit en Git para verificar el formato del mensaje del commit. (1 punto)
b) Explica c√≥mo este tipo de automatizaci√≥n podr√≠a contribuir a la calidad del historial del repositorio a largo plazo y facilitar la comprensi√≥n de los cambios. (1 punto)

‚úÖ Correcta: (La respuesta debe incluir la lectura del mensaje, la verificaci√≥n con una expresi√≥n regular y la salida de error si no coincide, explicando c√≥mo esto mejora la consistencia y claridad del historial).

üßæ Explicaci√≥n: Un hook pre-commit puede leer el mensaje del commit y verificar su formato. Esto asegura la consistencia de los mensajes, lo que facilita la b√∫squeda y comprensi√≥n del historial.

üß† Pregunta 98 (2 puntos)

Comparaci√≥n de flujos de trabajo

Compara brevemente las implicaciones en el historial del repositorio y la complejidad de la colaboraci√≥n entre un flujo de trabajo que utiliza principalmente merges directos (Fast-Forward cuando sea posible) y uno que utiliza exclusivamente merges sin Fast-Forward.

a) ¬øC√≥mo se ver√≠a el historial en cada caso y qu√© informaci√≥n se destacar√≠a o se perder√≠a? (1 punto)
b) ¬øQu√© consideraciones importantes deber√≠an tenerse en cuenta al elegir uno de estos flujos de trabajo para un equipo colaborativo? (1 punto)

‚úÖ Correcta: (La respuesta debe describir un historial lineal con Fast-Forward y uno con commits de merge con --no-ff, discutiendo la trazabilidad vs. simplicidad y la importancia de la pol√≠tica del equipo).

üßæ Explicaci√≥n: Fast-Forward crea un historial lineal pero pierde la trazabilidad de las caracter√≠sticas como ramas. --no-ff mantiene la trazabilidad pero crea un historial m√°s ramificado. La elecci√≥n depende de las necesidades del equipo.

üß† Pregunta 99 (2 puntos)

Anatom√≠a del Object Database y Reflog

Un desarrollador elimina accidentalmente un archivo importante que no estaba versionado en Git.

a) Explica por qu√© este archivo no se puede recuperar directamente utilizando comandos de Git de manipulaci√≥n del historial de commits (como git checkout de un commit anterior). (1 punto)
b) Describe si el reflog podr√≠a ofrecer alguna ayuda en este escenario y, de ser as√≠, c√≥mo. (1 punto)

‚úÖ Correcta: (La respuesta debe explicar que Git rastrea commits, no archivos sin versionar, y que el reflog rastrea cambios en las referencias, no el contenido del working directory no versionado).

üßæ Explicaci√≥n: Git solo rastrea archivos versionados en commits. El reflog rastrea cambios en las referencias (HEAD, ramas), no archivos sin commit en el working directory. Por lo tanto, el reflog no ayudar√≠a a recuperar un archivo no versionado eliminado.

üß† Pregunta 100 (2 puntos)

Patrones de Branching y Desarrollo

Considerando los patrones de "Feature Branching" y "Continuous Integration" mencionados en la lectura de Martin Fowler, describe un escenario de proyecto donde la adopci√≥n estricta de "Continuous Integration" podr√≠a presentar desaf√≠os significativos para el equipo de desarrollo.

a) Describe un tipo de proyecto o situaci√≥n donde las integraciones frecuentes y peque√±as podr√≠an ser dif√≠ciles de implementar o contraproducentes. (1 punto)
b) ¬øQu√© patr√≥n de branching podr√≠a ser una alternativa m√°s adecuada en ese escenario y por qu√©? (1 punto)

‚úÖ Correcta: (La respuesta debe describir proyectos con caracter√≠sticas grandes y complejas que requieren un desarrollo aislado prolongado, sugiriendo "Feature Branching" como una alternativa para un desarrollo m√°s aislado antes de la integraci√≥n).

üßæ Explicaci√≥n: En proyectos con caracter√≠sticas grandes y complejas, la integraci√≥n continua podr√≠a ser disruptiva. El "Feature Branching" permite un desarrollo m√°s aislado antes de la integraci√≥n, lo que puede ser m√°s adecuado en estos casos.