ğŸ§  Pregunta 101

Un equipo estÃ¡ utilizando ramas de caracterÃ­sticas de corta duraciÃ³n y desea mantener un historial limpio en la rama principal Â¿QuÃ© estrategia de fusiÃ³n recomendarÃ­as para lograr este objetivo sin reescribir la historia de la rama principal

A Usar siempre merge con Fast-Forward
B Usar siempre merge sin Fast-Forward
C Usar squash merge al fusionar las ramas de caracterÃ­sticas
D Rebasar la rama principal con la rama de caracterÃ­stica

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: Squash merge combina todos los commits de la rama de caracterÃ­stica en un Ãºnico commit al fusionarla a la principal, resultando en un historial lineal y limpio en la rama principal sin alterar su historia directamente.

ğŸ§  Pregunta 102

Â¿CuÃ¡l es la principal ventaja de utilizar git reflog en comparaciÃ³n con git log cuando se intenta recuperar un trabajo perdido debido a una acciÃ³n accidental como un reset --hard

A git log muestra un historial mÃ¡s detallado de todos los cambios
B git reflog rastrea los cambios en los punteros de las ramas y el HEAD, incluyendo acciones que no son commits
C git log permite viajar en el tiempo a cualquier estado del repositorio
D git reflog muestra el contenido exacto de los archivos en cada commit

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: git reflog registra los movimientos del HEAD y las ramas, permitiendo rastrear cambios que no se reflejan en el historial de commits tradicional, como resets o cambios de checkout, lo que facilita la recuperaciÃ³n de estados anteriores.

ğŸ§  Pregunta 103

En un proyecto que utiliza submÃ³dulos para gestionar dependencias externas Â¿QuÃ© comando se utiliza para inicializar los submÃ³dulos despuÃ©s de clonar el repositorio principal pero antes de poder trabajar con el cÃ³digo de los submÃ³dulos

A git submodule update
B git submodule add
C git submodule init
D git submodule clone

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: git submodule init inicializa el archivo .gitmodules y configura los submÃ³dulos para ser actualizados, preparando el entorno para traer el cÃ³digo de los repositorios externos.

ğŸ§  Pregunta 104

Si un equipo experimenta problemas para identificar cuÃ¡ndo se introdujo un error especÃ­fico en una funciÃ³n de un archivo Â¿QuÃ© combinaciÃ³n de comandos de Git serÃ­a mÃ¡s efectiva para acotar la bÃºsqueda al commit exacto y luego examinar los cambios en esa funciÃ³n

A git log <archivo> seguido de git diff <commit_anterior> <commit_culpable> <archivo>
B git blame <archivo> seguido de revisiÃ³n manual del historial
C git bisect seguido de git log -L :<funciÃ³n>:<archivo>
D git log --follow <archivo> seguido de git show <commit_culpable>

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: git bisect permite encontrar el commit que introdujo el error mediante pruebas iterativas git log -L luego permite examinar especÃ­ficamente los cambios realizados en la funciÃ³n dentro de ese commit.

ğŸ§  Pregunta 105

Â¿CuÃ¡l es una diferencia fundamental entre la forma en que Git gestiona la integraciÃ³n de un repositorio externo utilizando un subtree en comparaciÃ³n con un submÃ³dulo en tÃ©rminos del historial del proyecto principal

A Un subtree mantiene un enlace directo al historial del repositorio externo mientras que un submÃ³dulo no
B Un submÃ³dulo integra el historial completo del repositorio externo en el proyecto principal mientras que un subtree no
C Un subtree copia el contenido del repositorio externo directamente en el proyecto principal integrando su historial mientras que un submÃ³dulo mantiene una referencia separada a un commit especÃ­fico
D No hay una diferencia fundamental en cÃ³mo se gestiona el historial

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: Un subtree integra el contenido y el historial del repositorio externo directamente en el proyecto principal como si fuera una subcarpeta Un submÃ³dulo mantiene una referencia a un commit especÃ­fico del repositorio externo sin integrar su historial completo.

ğŸ§  Pregunta 106

Un desarrollador quiere combinar varios commits locales recientes en uno solo antes de hacer push a la rama remota Â¿QuÃ© comando de Git con quÃ© opciÃ³n le permitirÃ­a lograr esto de forma interactiva

A git merge --squash HEAD~3
B git rebase -i HEAD~3
C git checkout --ours HEAD~3
D git reset --soft HEAD~3

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: git rebase -i con la referencia al nÃºmero de commits anteriores abre un editor donde el desarrollador puede elegir la acciÃ³n squash o fixup para combinar los commits.

ğŸ§  Pregunta 107

Â¿CuÃ¡l es la principal razÃ³n por la que un equipo podrÃ­a optar por utilizar merges sin Fast-Forward en su flujo de trabajo de Git

A Para simplificar el historial del proyecto
B Para evitar la creaciÃ³n de commits de merge
C Para preservar la informaciÃ³n de cuÃ¡ndo y cÃ³mo se integrÃ³ una rama de caracterÃ­stica
D Para resolver conflictos de merge de forma automÃ¡tica

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: Los merges sin Fast-Forward crean un commit de merge explÃ­cito que registra la integraciÃ³n de una rama, manteniendo la trazabilidad de la caracterÃ­stica en el historial.

ğŸ§  Pregunta 108

DespuÃ©s de ejecutar git bisect start y marcar un commit como malo y otro como bueno Â¿QuÃ© comando se utiliza para avanzar al siguiente commit a probar en el proceso de bÃºsqueda binaria

A git bisect next
B git bisect continue
C git bisect step
D git bisect proceed

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: git bisect continue le dice a Git que continÃºe con la bÃºsqueda binaria, moviÃ©ndose al siguiente commit que necesita ser probado.

ğŸ§  Pregunta 109

Si accidentalmente eliminas una rama local Â¿QuÃ© comando podrÃ­as utilizar para intentar recuperarla si recuerdas aproximadamente cuÃ¡ndo la eliminaste y el Ãºltimo commit en ella utilizando el reflog

A git checkout -b <nombre_rama> HEAD
B git branch <nombre_rama> <hash_del_commit>
C git checkout <hash_del_commit>
D git reset --hard ORIG_HEAD

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: El reflog registra los cambios en los punteros de las ramas Puedes encontrar el hash del Ãºltimo commit de la rama eliminada en el reflog y luego crear una nueva rama apuntando a ese hash.

ğŸ§  Pregunta 110

Â¿CuÃ¡l es la principal diferencia en cÃ³mo se gestionan las actualizaciones de una dependencia externa cuando se utiliza un submÃ³dulo en comparaciÃ³n con un subtree

A Las actualizaciones de submÃ³dulos se integran automÃ¡ticamente en el historial del proyecto principal
B Las actualizaciones de subtrees requieren la ejecuciÃ³n de comandos especÃ­ficos para traer los cambios del repositorio externo
C Los submÃ³dulos no se pueden actualizar una vez agregados
D Los subtrees mantienen un enlace directo a la Ãºltima versiÃ³n del repositorio externo

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Las actualizaciones de subtrees requieren comandos explÃ­citos como git subtree pull para traer los cambios del repositorio externo e integrarlos en el proyecto principal Los submÃ³dulos requieren actualizar la referencia al commit deseado.

ğŸ§  Pregunta 111

Un equipo quiere asegurarse de que todos los mensajes de commit sigan un formato especÃ­fico Â¿QuÃ© mecanismo de Git se puede utilizar para verificar automÃ¡ticamente el formato de los mensajes de commit antes de que se acepten

A git config commit.template
B Un hook pre-commit
C Un hook commit-msg
D git check-ignore

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El hook commit-msg se ejecuta despuÃ©s de que el usuario ingresa el mensaje de commit pero antes de que se cree el commit Permite validar el formato del mensaje y rechazar el commit si no cumple con los criterios.

ğŸ§  Pregunta 112

Â¿CuÃ¡l es el propÃ³sito principal de utilizar la opciÃ³n --graph con el comando git log

A Mostrar solo los commits que han modificado el contenido de los archivos
B Visualizar la historia de commits como un Ã¡rbol mostrando las ramas y merges
C Mostrar estadÃ­sticas sobre los cambios realizados en cada commit
D Limitar el nÃºmero de commits mostrados en la salida

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La opciÃ³n --graph de git log dibuja una representaciÃ³n visual de la estructura de ramas y merges en el historial del repositorio, facilitando la comprensiÃ³n de cÃ³mo se han integrado las diferentes lÃ­neas de desarrollo.

ğŸ§  Pregunta 113

En un flujo de trabajo donde se realizan muchas fusiones Â¿QuÃ© estrategia de merge podrÃ­a dificultar el seguimiento de la historia de una caracterÃ­stica especÃ­fica a travÃ©s del tiempo en la rama principal

A Merges sin Fast-Forward
B Merges con Fast-Forward
C Squash merges
D Octopus merges

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Los merges con Fast-Forward simplemente mueven el puntero de la rama principal sin crear un commit de merge explÃ­cito Esto puede hacer que la historia de una caracterÃ­stica se disperse entre los commits de la rama principal dificultando su seguimiento como una unidad lÃ³gica.

ğŸ§  Pregunta 114

Si necesitas identificar quÃ© commit introdujo una lÃ­nea de cÃ³digo especÃ­fica en un archivo Â¿QuÃ© comando de Git utilizarÃ­as

A git log -p <archivo>
B git diff <archivo>
C git blame <archivo>
D git show <archivo>

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: git blame anota cada lÃ­nea de un archivo mostrando informaciÃ³n sobre el commit y el autor de la Ãºltima modificaciÃ³n de esa lÃ­nea lo que permite identificar cuÃ¡ndo se introdujo una lÃ­nea especÃ­fica.

ğŸ§  Pregunta 115

Â¿CuÃ¡l es la principal ventaja de utilizar subtrees en lugar de submÃ³dulos en ciertos escenarios de gestiÃ³n de dependencias

A Los subtrees mantienen enlaces directos a commits especÃ­ficos de los repositorios externos
B Los subtrees facilitan la contribuciÃ³n al repositorio externo desde el proyecto principal
C Los subtrees integran el contenido del repositorio externo directamente en el Ã¡rbol del proyecto principal simplificando algunas operaciones
D Los subtrees requieren menos comandos para su gestiÃ³n que los submÃ³dulos

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: Los subtrees integran el cÃ³digo del repositorio externo directamente en el proyecto principal como una subcarpeta lo que puede simplificar flujos de trabajo donde se necesita modificar o interactuar con el cÃ³digo de la dependencia de manera mÃ¡s directa sin la necesidad de inicializar o actualizar submÃ³dulos por separado.