ğŸ§  Pregunta 1

Â¿CuÃ¡l es el propÃ³sito principal del rebase interactivo en Git?

A. Fusionar mÃºltiples ramas en una sola.
B. Modificar y limpiar la historia de los commits antes de la integraciÃ³n.
C. Rastrear los cambios realizados por diferentes colaboradores.
D. Publicar los cambios locales en un repositorio remoto.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: El rebase interactivo permite reestructurar la lÃ­nea de historia de un repositorio, facilitando la combinaciÃ³n de commits, la modificaciÃ³n de mensajes y la eliminaciÃ³n de commits innecesarios antes de integrar los cambios en la rama principal.

ğŸ§  Pregunta 2

Â¿QuÃ© comando de git rebase -i permite combinar dos o mÃ¡s commits en uno solo, conservando los cambios de todos ellos?

A. reword
B. edit
C. squash
D. fixup

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El comando squash (o su abreviatura s) en el rebase interactivo se utiliza para fusionar varios commits seleccionados en un Ãºnico commit, combinando sus respectivos cambios en el proceso.

ğŸ§  Pregunta 3

Â¿CuÃ¡l es la principal diferencia entre un merge normal y un merge sin Fast-Forward (--no-ff)?

A. El merge sin Fast-Forward siempre evita los conflictos.
B. El merge normal crea un commit adicional para registrar la fusiÃ³n.
C. El merge sin Fast-Forward fuerza la creaciÃ³n de un commit de merge, manteniendo la historia de la rama fusionada.
D. El merge normal solo se puede realizar si la rama a fusionar estÃ¡ directamente detrÃ¡s de la rama objetivo.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La opciÃ³n --no-ff en el comando git merge asegura que siempre se cree un commit de merge, incluso si la fusiÃ³n podrÃ­a realizarse con un Fast-Forward. Esto preserva la existencia de la rama de caracterÃ­sticas en la historia del proyecto.

ğŸ§  Pregunta 4

Â¿En quÃ© escenario es mÃ¡s apropiado utilizar un "Octopus merge"?

A. Cuando se necesita resolver conflictos complejos entre dos ramas.
B. Cuando se desean fusionar secuencialmente varias ramas pequeÃ±as.
C. Cuando se quieren integrar mÃºltiples ramas independientes en un solo commit.
D. Cuando se busca una forma rÃ¡pida y sencilla de fusionar dos ramas sin crear un commit adicional.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El "Octopus merge" estÃ¡ diseÃ±ado para fusionar mÃ¡s de dos ramas simultÃ¡neamente en un solo commit, siendo ideal para integrar varias ramas de caracterÃ­sticas que no tienen conflictos entre sÃ­.

ğŸ§  Pregunta 5

Â¿CuÃ¡l de las siguientes opciones describe mejor la funciÃ³n del comando git log --graph --decorate --oneline?

A. Muestra una lista detallada de todos los commits, incluyendo autor, fecha y mensaje.
B. Presenta la historia de commits de forma lineal, mostrando solo el hash y el mensaje de cada commit.
C. Visualiza la historia de commits como un Ã¡rbol, decorando cada commit con referencias y mostrando cada uno en una sola lÃ­nea.
D. Permite buscar commits especÃ­ficos dentro del historial basÃ¡ndose en palabras clave en el mensaje.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La combinaciÃ³n de --graph muestra la estructura de ramas y merges, --decorate aÃ±ade informaciÃ³n sobre las ramas y etiquetas, y --oneline compacta cada commit en una sola lÃ­nea para una visiÃ³n general mÃ¡s concisa.

ğŸ§  Pregunta 6

Â¿Para quÃ© se utiliza principalmente el comando git blame?

A. Para comparar diferentes versiones de un archivo.
B. Para identificar el commit que introdujo un error en el cÃ³digo.
C. Para asociar cada lÃ­nea de un archivo con el commit y el autor de la Ãºltima modificaciÃ³n.
D. Para mostrar el historial de cambios de un archivo especÃ­fico.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: git blame anota cada lÃ­nea de un archivo, mostrando el commit y el autor que realizaron la Ãºltima modificaciÃ³n en esa lÃ­nea, lo que ayuda a entender la autorÃ­a y el origen de los cambios.

ğŸ§  Pregunta 7

El comando git bisect utiliza una estrategia de bÃºsqueda para encontrar un commit especÃ­fico. Â¿QuÃ© tipo de bÃºsqueda emplea?

A. BÃºsqueda lineal.
B. BÃºsqueda por profundidad.
C. BÃºsqueda binaria.
D. BÃºsqueda heurÃ­stica.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: git bisect utiliza una bÃºsqueda binaria al dividir repetidamente el rango de commits a la mitad, lo que permite encontrar el commit que introdujo un error de manera eficiente al requerir probar solo un subconjunto logarÃ­tmico del historial.

ğŸ§  Pregunta 8

En el contexto de git bisect, Â¿quÃ© significan los comandos git bisect good y git bisect bad?

A. Indican el inicio y el final del proceso de bÃºsqueda.
B. Marcan un commit como libre de errores o como conteniendo el error, respectivamente.
C. Muestran una lista de los commits que han sido probados.
D. Permiten volver al commit anterior o avanzar al siguiente en la bÃºsqueda.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: DespuÃ©s de probar un commit durante el proceso de git bisect, se utiliza git bisect good para indicar que ese commit no contiene el error, y git bisect bad para seÃ±alar que sÃ­ lo contiene, permitiendo a Git reducir el rango de bÃºsqueda.

ğŸ§  Pregunta 9

Â¿CuÃ¡l es la funciÃ³n principal del comando git reflog?

A. Mostrar el historial de commits del repositorio.
B. Rastrear todos los cambios en los punteros de las ramas y los movimientos de HEAD.
C. Comparar las diferencias entre dos commits o ramas.
D. Eliminar commits de la historia del repositorio de forma segura.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: git reflog registra cada cambio realizado en las referencias (como HEAD, ramas, etc.), permitiendo rastrear movimientos y potencialmente recuperar commits que se hayan perdido debido a operaciones como resets o rebases.

ğŸ§  Pregunta 10

Si accidentalmente ejecutas git reset --hard HEAD~1, Â¿quÃ© comando podrÃ­as usar para intentar recuperar el estado anterior de tu rama, basÃ¡ndote en la lectura?

A. git log
B. git checkout
C. git reflog seguido de git reset --hard HEAD@{n}
D. git revert HEAD

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El git reflog registra los movimientos de HEAD. Al listar el reflog, puedes identificar el estado anterior (antes del reset) y usar git reset --hard HEAD@{n} (donde n es el Ã­ndice del estado anterior en el reflog) para volver a ese punto.

ğŸ§  Pregunta 11

Â¿CuÃ¡l es la principal diferencia entre un submÃ³dulo y un subtree en Git?

A. Los submÃ³dulos integran el contenido del repositorio externo directamente en el principal, mientras que los subtrees mantienen una referencia separada.
B. Los subtrees permiten tener diferentes versiones del repositorio externo en diferentes ramas del repositorio principal.
C. Los submÃ³dulos mantienen un enlace a un commit especÃ­fico del repositorio externo, requiriendo una actualizaciÃ³n explÃ­cita, mientras que los subtrees integran el contenido sin una referencia separada.
D. Los subtrees son mÃ¡s fÃ¡ciles de inicializar y actualizar que los submÃ³dulos.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: Los submÃ³dulos actÃºan como enlaces a un commit especÃ­fico de un repositorio externo, mientras que los subtrees copian el contenido del repositorio externo directamente al principal, facilitando la fusiÃ³n pero sin un vÃ­nculo directo continuo.

ğŸ§  Pregunta 12

Â¿QuÃ© archivo se actualiza automÃ¡ticamente cuando se agrega un submÃ³dulo a un repositorio Git?

A. .gitignore
B. .gitattributes
C. .gitmodules
D. .gitkeep

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El archivo .gitmodules almacena la informaciÃ³n sobre los submÃ³dulos, como la URL del repositorio externo y la ruta local donde se encuentra el submÃ³dulo dentro del repositorio principal.

ğŸ§  Pregunta 13

Â¿CuÃ¡l es el propÃ³sito de la opciÃ³n --squash al agregar o actualizar un subtree?

A. Comprimir el tamaÃ±o del repositorio del subtree.
B. Fusionar todos los commits del subtree en un Ãºnico commit en el repositorio principal.
C. Evitar la creaciÃ³n de un commit de merge al integrar el subtree.
D. Mantener el historial completo del subtree dentro del repositorio principal.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La opciÃ³n --squash al agregar o hacer pull de un subtree combina todos los commits del repositorio externo en un Ãºnico commit dentro del repositorio principal, lo que puede ayudar a mantener un historial mÃ¡s limpio en el proyecto principal.

ğŸ§  Pregunta 14

En el ejemplo completo proporcionado, despuÃ©s de realizar un "Octopus merge" de las ramas feature/login y feature/dashboard en master, Â¿cuÃ¡ntos commits de merge se esperarÃ­a ver (asumiendo que no hubo conflictos)?

A. Ninguno, los cambios se integrarÃ­an directamente en el Ãºltimo commit de master.
B. Un commit de merge que combina los cambios de ambas ramas.
C. Dos commits de merge, uno por cada rama fusionada.
D. Un commit por cada cambio individual realizado en las ramas fusionadas.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Un "Octopus merge" estÃ¡ diseÃ±ado para fusionar mÃºltiples ramas en un solo commit de merge, lo que significa que se crearÃ­a un Ãºnico commit para integrar los cambios de feature/login y feature/dashboard en la rama master.

ğŸ§  Pregunta 15

Â¿QuÃ© acciÃ³n realiza el comando pick durante un rebase interactivo?

A. Permite modificar el mensaje del commit.
B. Detiene el proceso de rebase para permitir la ediciÃ³n del commit.
C. Utiliza el commit tal como estÃ¡, sin realizar ninguna modificaciÃ³n.
D. Combina el commit actual con el commit anterior.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El comando pick indica a Git que se debe mantener el commit seleccionado tal cual, sin realizar ninguna alteraciÃ³n en su contenido o mensaje durante el rebase interactivo.

ğŸ§  Pregunta 16

Â¿CuÃ¡l es la diferencia fundamental entre los comandos squash y fixup en un rebase interactivo?

A. squash permite editar el mensaje del commit combinado, mientras que fixup descarta el mensaje del commit que se estÃ¡ combinando.
B. fixup combina los cambios de varios commits en uno solo, mientras que squash simplemente reordena los commits.
C. squash se utiliza para eliminar commits, mientras que fixup se usa para modificar su contenido.
D. No hay diferencia funcional entre squash y fixup; ambos realizan la misma acciÃ³n.

âœ… Correcta: A

ğŸ§¾ ExplicaciÃ³n: Tanto squash como fixup combinan commits, pero squash abre un editor para permitir la modificaciÃ³n del mensaje del commit resultante, mientras que fixup automÃ¡ticamente descarta el mensaje del commit que se estÃ¡ fusionando, utilizando el mensaje del commit anterior.

ğŸ§  Pregunta 17

Â¿CuÃ¡l es una ventaja de mantener un historial limpio en Git, lograda a travÃ©s de tÃ©cnicas como el rebase interactivo?

A. Reduce el tamaÃ±o del repositorio.
B. Acelera la ejecuciÃ³n de los comandos de Git.
C. Facilita la revisiÃ³n del cÃ³digo y el seguimiento de los cambios.
D. Mejora el rendimiento de la aplicaciÃ³n desarrollada.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: Un historial limpio, con commits bien organizados y mensajes claros, facilita la comprensiÃ³n de la evoluciÃ³n del proyecto, la identificaciÃ³n de cambios especÃ­ficos y la colaboraciÃ³n entre desarrolladores.

ğŸ§  Pregunta 18

En el contexto de Git, Â¿quÃ© se entiende por "Fast-Forward merge"?

A. Una fusiÃ³n que requiere la resoluciÃ³n manual de conflictos.
B. Una fusiÃ³n en la que la rama a integrar estÃ¡ directamente detrÃ¡s de la rama objetivo, moviendo simplemente el puntero de la rama objetivo.
C. Una fusiÃ³n que crea siempre un nuevo commit de merge.
D. Una tÃ©cnica para fusionar ramas con historiales significativamente divergentes.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Un "Fast-Forward merge" ocurre cuando la rama que se va a fusionar es un descendiente directo de la rama objetivo. En este caso, en lugar de crear un nuevo commit de merge, Git simplemente mueve el puntero de la rama objetivo al Ãºltimo commit de la rama que se estÃ¡ fusionando.

ğŸ§  Pregunta 19

Â¿CuÃ¡l es la principal limitaciÃ³n del "Octopus merge" mencionada en la lectura?

A. No se puede utilizar para fusionar mÃ¡s de tres ramas simultÃ¡neamente.
B. Requiere que todas las ramas a fusionar tengan un ancestro comÃºn reciente.
C. No permite la intervenciÃ³n manual en caso de conflictos.
D. Solo se puede realizar si las ramas a fusionar tienen cambios en los mismos archivos.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El "Octopus merge" estÃ¡ diseÃ±ado para fusionar ramas sin conflictos. Si Git detecta conflictos, la operaciÃ³n fallarÃ¡ y no se completarÃ¡ el merge, sin ofrecer la posibilidad de resolverlos durante el proceso.

ğŸ§  Pregunta 20

Si deseas ver la historia de commits mostrando las ramas y etiquetas junto a cada commit, Â¿quÃ© opciÃ³n agregarÃ­as al comando git log?

A. --oneline
B. --graph
C. --decorate
D. --stat

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La opciÃ³n --decorate al comando git log aÃ±ade informaciÃ³n sobre las referencias (ramas, etiquetas) junto a cada commit en la salida, lo que facilita la comprensiÃ³n de la estructura del repositorio.

ğŸ§  Pregunta 21

Al utilizar git blame archivo.txt, Â¿quÃ© informaciÃ³n principal se muestra para cada lÃ­nea del archivo?

A. El nÃºmero de lÃ­nea y el contenido de la lÃ­nea.
B. El hash del commit, el autor, la fecha y el contenido de la lÃ­nea.
C. Las diferencias entre la lÃ­nea actual y la versiÃ³n anterior.
D. Los permisos del archivo y la fecha de la Ãºltima modificaciÃ³n.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: El comando git blame anota cada lÃ­nea del archivo, mostrando el commit que realizÃ³ la Ãºltima modificaciÃ³n en esa lÃ­nea, junto con el autor y la fecha de ese commit, ademÃ¡s del contenido de la lÃ­nea.

ğŸ§  Pregunta 22

Durante una sesiÃ³n de git bisect, si ejecutas un script de pruebas y este indica que el commit actual contiene el error, Â¿quÃ© comando debes ejecutar a continuaciÃ³n?

A. git bisect next
B. git bisect good
C. git bisect bad
D. git bisect reset

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: Si el script de pruebas falla en el commit actual, significa que ese commit es "malo" (contiene el error), por lo que debes ejecutar git bisect bad para informar a Git y continuar con la bÃºsqueda.

ğŸ§  Pregunta 23

DespuÃ©s de finalizar una sesiÃ³n de git bisect, Â¿quÃ© comando se recomienda ejecutar para volver a tu rama de trabajo original?

A. git checkout HEAD
B. git reset --hard
C. git bisect reset
D. git bisect finish

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El comando git bisect reset limpia el estado de bisect y devuelve tu repositorio a la rama y commit en los que estabas antes de iniciar el proceso de bÃºsqueda binaria.

ğŸ§  Pregunta 24

Â¿QuÃ© tipo de informaciÃ³n se puede encontrar en el git reflog que no estÃ¡ disponible en el git log tradicional?

A. El contenido de los commits.
B. Los mensajes de los commits.
C. Los cambios en los punteros de las ramas y los movimientos de HEAD, incluso aquellos que no resultan en un nuevo commit.
D. La lista de todos los archivos modificados en cada commit.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El git reflog rastrea los movimientos de las referencias de Git, como los cambios de rama, los resets y los merges, proporcionando un historial de las acciones que han afectado el estado de tus ramas, incluso si no se crearon commits en el proceso.

ğŸ§  Pregunta 25

Al agregar un submÃ³dulo, Â¿a quÃ© apunta inicialmente el enlace dentro del repositorio principal?

A. A la Ãºltima versiÃ³n de la rama principal del repositorio externo.
B. A una rama especÃ­fica configurada durante la adiciÃ³n del submÃ³dulo.
C. A un commit especÃ­fico del repositorio externo.
D. A la URL del repositorio externo, sin referencia a un commit especÃ­fico hasta que se actualiza.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: Cuando se agrega un submÃ³dulo, se crea un enlace fijo a un commit especÃ­fico del repositorio externo en el momento de la adiciÃ³n. Para actualizar el submÃ³dulo a una versiÃ³n mÃ¡s reciente, se debe realizar una operaciÃ³n explÃ­cita.

ğŸ§  Pregunta 26

Â¿QuÃ© comando se utiliza para inicializar y actualizar los submÃ³dulos despuÃ©s de clonar un repositorio que los contiene?

A. git submodule init seguido de git submodule update
B. git clone --recurse-submodules
C. git submodule add seguido de la URL del repositorio externo
D. git submodule sync seguido de git submodule update

âœ… Correcta: A

ğŸ§¾ ExplicaciÃ³n: DespuÃ©s de clonar un repositorio con submÃ³dulos, primero se debe inicializar la configuraciÃ³n de los submÃ³dulos con git submodule init, y luego se deben actualizar para traer el contenido de los repositorios externos referenciados con git submodule update. La opciÃ³n --init --recursive en git submodule update tambiÃ©n puede utilizarse para inicializar y actualizar submÃ³dulos anidados.

ğŸ§  Pregunta 27

Â¿CuÃ¡l es una ventaja de utilizar subtrees en lugar de submÃ³dulos para integrar un proyecto externo?

A. Los subtrees mantienen un enlace directo al historial del repositorio externo.
B. Las actualizaciones de los subtrees son generalmente mÃ¡s automÃ¡ticas.
C. Los subtrees integran el contenido del repositorio externo directamente en el Ã¡rbol del proyecto principal, facilitando la colaboraciÃ³n sin necesidad de inicializar o actualizar submÃ³dulos por separado.
D. Los subtrees permiten tener mÃºltiples versiones del proyecto externo dentro del mismo repositorio principal.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: Los subtrees integran el contenido de otro repositorio directamente en el Ã¡rbol del repositorio principal, lo que puede simplificar el flujo de trabajo para algunos equipos al no requerir la gestiÃ³n separada de los submÃ³dulos.

ğŸ§  Pregunta 28

En el ejemplo completo, despuÃ©s de ejecutar git subtree add, Â¿dÃ³nde se encuentra el contenido del repositorio externo https://github.com/usuario/lib-subs.git dentro del project-integrado?

A. En un directorio llamado .git/modules/lib-subs.
B. Directamente en la raÃ­z del project-integrado.
C. En un directorio llamado libs/lib-subs.
D. Como un archivo comprimido dentro del repositorio principal.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El comando git subtree add --prefix=libs/lib-subs ... especifica que el contenido del repositorio externo debe integrarse dentro de un directorio llamado libs/lib-subs dentro del repositorio principal.

ğŸ§  Pregunta 29

Â¿QuÃ© comando se utilizÃ³ en el ejemplo completo para simular la creaciÃ³n de la rama feature/login y cambiar a ella?

A. git branch feature/login seguido de git checkout feature/login
B. git checkout -b feature/login
C. git branch -c feature/login
D. git switch feature/login --create

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: El comando git checkout -b <nombre_de_la_rama> crea una nueva rama con el nombre especificado y cambia inmediatamente a esa rama, combinando la creaciÃ³n y el cambio de rama en un solo paso.

ğŸ§  Pregunta 30

En el escenario de recuperaciÃ³n utilizando git reflog, Â¿quÃ© indica la notaciÃ³n HEAD@{1}?

A. El Ãºltimo commit en la rama actual.
B. El commit al que HEAD apuntaba inmediatamente antes del estado actual.
C. El primer commit realizado en la rama actual.
D. Un commit especÃ­fico identificado por el hash 1.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La notaciÃ³n HEAD@{n} en el git reflog se refiere al estado de HEAD en un momento especÃ­fico en el pasado, donde HEAD@{0} es el estado actual, HEAD@{1} es el estado anterior, y asÃ­ sucesivamente. Por lo tanto, HEAD@{1} representa el estado de HEAD justo antes de la Ãºltima operaciÃ³n que lo modificÃ³.