ğŸ§  Pregunta 31

Â¿QuÃ© ocurre si intentas realizar un rebase interactivo y existen commits que ya han sido compartidos con un repositorio remoto?

A. Git automÃ¡ticamente crea una nueva rama para el rebase.
B. Git advierte sobre el peligro de reescribir la historia compartida, pero permite continuar.
C. Git bloquea la operaciÃ³n de rebase para evitar inconsistencias en el repositorio remoto.
D. Git realiza el rebase en una copia local de la rama sin afectar la rama remota.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Reescribir la historia (como con rebase) en ramas compartidas puede causar problemas para otros colaboradores. Git te advertirÃ¡, pero te permitirÃ¡ continuar, asumiendo que entiendes los riesgos.

ğŸ§  Pregunta 32

Â¿CuÃ¡l de los siguientes comandos se utiliza para detener temporalmente un rebase interactivo para permitir modificaciones en un commit especÃ­fico?

A. git rebase --abort
B. git rebase --continue
C. git rebase --skip
D. El comando edit dentro del editor de rebase.

âœ… Correcta: D

ğŸ§¾ ExplicaciÃ³n: Al marcar un commit con edit en el editor de rebase interactivo, Git detendrÃ¡ el proceso en ese commit, permitiÃ©ndote realizar modificaciones, stage changes y luego continuar el rebase con git rebase --continue.

ğŸ§  Pregunta 33

Si durante un rebase interactivo utilizas el comando drop en un commit, Â¿quÃ© sucede con ese commit?

A. Su mensaje se elimina, pero los cambios se mantienen.
B. Se combina con el commit anterior.
C. Se elimina por completo de la historia de la rama.
D. Se mueve al final de la secuencia de commits a rebasar.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El comando drop en el rebase interactivo instruye a Git para que elimine completamente el commit seleccionado de la historia de la rama que se estÃ¡ rebasando.

ğŸ§  Pregunta 34

Â¿En quÃ© situaciÃ³n serÃ­a mÃ¡s Ãºtil realizar un merge sin Fast-Forward (--no-ff)?

A. Cuando se fusiona una rama de correcciÃ³n rÃ¡pida a la rama principal.
B. Cuando se desea mantener un historial lineal y simplificado.
C. Cuando se quiere preservar la informaciÃ³n de cuÃ¡ndo y cÃ³mo se integrÃ³ una caracterÃ­stica completa.
D. Cuando la rama a fusionar estÃ¡ directamente detrÃ¡s de la rama objetivo.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El merge sin Fast-Forward crea un commit de merge explÃ­cito, lo que permite visualizar claramente en el historial cuÃ¡ndo se integrÃ³ una rama de caracterÃ­sticas, incluso si la fusiÃ³n podrÃ­a haber sido un Fast-Forward.

ğŸ§  Pregunta 35

Â¿QuÃ© podrÃ­a causar un conflicto durante un "Octopus merge"?

A. Intentar fusionar mÃ¡s de tres ramas simultÃ¡neamente.
B. Si las ramas a fusionar tienen cambios incompatibles en los mismos archivos.
C. Si alguna de las ramas a fusionar tiene un historial muy largo.
D. Si las ramas a fusionar no comparten un ancestro comÃºn.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Al igual que con los merges normales, los conflictos en un "Octopus merge" ocurren cuando dos o mÃ¡s ramas que se estÃ¡n fusionando tienen cambios contradictorios en las mismas lÃ­neas de los mismos archivos.

ğŸ§  Pregunta 36

Si deseas ver la historia de un archivo especÃ­fico, incluyendo los commits que lo modificaron, Â¿quÃ© comando utilizarÃ­as?

A. git log --follow <archivo>
B. git history <archivo>
C. git blame <archivo>
D. git diff <archivo>

âœ… Correcta: A

ğŸ§¾ ExplicaciÃ³n: El comando git log --follow <archivo> rastrea la historia del archivo especificado, incluso si el archivo ha sido renombrado a lo largo del tiempo.

ğŸ§  Pregunta 37

Â¿CuÃ¡l es el propÃ³sito de la opciÃ³n -L en el comando git log?

A. Mostrar los logs en un formato mÃ¡s conciso (una lÃ­nea).
B. Limitar el nÃºmero de logs mostrados.
C. Seguir la evoluciÃ³n de un rango especÃ­fico de lÃ­neas o una funciÃ³n dentro de un archivo.
D. Mostrar los logs de una rama especÃ­fica.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La opciÃ³n -L en git log permite filtrar el historial para mostrar solo los commits que afectaron a un rango especÃ­fico de lÃ­neas o a una funciÃ³n dentro de un archivo, lo que es Ãºtil para entender la evoluciÃ³n de una parte particular del cÃ³digo.

ğŸ§  Pregunta 38

Durante una sesiÃ³n de git bisect, Â¿quÃ© ocurre si no estÃ¡s seguro si un commit es "bueno" o "malo"?

A. Debes marcarlo como "malo" para continuar la bÃºsqueda.
B. Debes marcarlo como "bueno" para continuar la bÃºsqueda.
C. Puedes usar git bisect skip para omitir este commit y probar el siguiente.
D. Debes reiniciar la sesiÃ³n de git bisect.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: Si no puedes determinar si un commit introdujo el error, puedes usar git bisect skip para que Git lo ignore y pase al siguiente commit en la bÃºsqueda binaria.

ğŸ§  Pregunta 39

DespuÃ©s de encontrar el commit que introdujo un error con git bisect, Â¿quÃ© informaciÃ³n Ãºtil puedes obtener al usar git blame en las lÃ­neas afectadas?

A. La fecha en que se creÃ³ el archivo.
B. El nÃºmero total de lÃ­neas de cÃ³digo aÃ±adidas y eliminadas por el commit culpable.
C. El autor del commit culpable y la fecha en que se realizÃ³ el cambio.
D. Una lista de todos los archivos modificados en el commit culpable.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: git blame en las lÃ­neas del commit culpable te mostrarÃ¡ quiÃ©n realizÃ³ ese cambio especÃ­fico y cuÃ¡ndo, lo que puede proporcionar pistas importantes sobre por quÃ© se introdujo el error.

ğŸ§  Pregunta 40

Â¿QuÃ© comando se utiliza para ver el historial del reflog?

A. git log --reflog
B. git history reflog
C. git reflog
D. git log HEAD@{}

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El comando git reflog por sÃ­ solo muestra el historial de los movimientos de las referencias de tu repositorio local.

ğŸ§  Pregunta 41

Si accidentalmente eliminas una rama local que contenÃ­a commits importantes, Â¿cÃ³mo podrÃ­as intentar recuperarla utilizando el reflog?

A. Buscar un commit en el reflog que estuviera en la rama eliminada y crear una nueva rama apuntando a ese commit.
B. Utilizar git checkout -b <nombre_rama> HEAD para recrear la rama.
C. El reflog solo rastrea cambios en HEAD, no eliminaciones de ramas.
D. Ejecutar git branch -d <nombre_rama> nuevamente para deshacer la eliminaciÃ³n.

âœ… Correcta: A

ğŸ§¾ ExplicaciÃ³n: El reflog registra cuÃ¡ndo se creÃ³ y eliminÃ³ tu rama local. Puedes buscar el Ãºltimo commit al que apuntaba esa rama antes de ser eliminada y crear una nueva rama que apunte a ese commit.

ğŸ§  Pregunta 42

Â¿CuÃ¡l es el principal beneficio de usar submÃ³dulos para gestionar dependencias externas?

A. Integran el cÃ³digo del proyecto externo directamente en tu repositorio, facilitando las modificaciones.
B. Permiten mantener una referencia a un commit especÃ­fico de la dependencia, asegurando la reproducibilidad.
C. Actualizan automÃ¡ticamente la dependencia a la Ãºltima versiÃ³n disponible.
D. Reducen el tamaÃ±o de tu repositorio principal al no copiar el historial de la dependencia.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Los submÃ³dulos permiten fijar la dependencia a una versiÃ³n especÃ­fica (un commit), lo que garantiza que tu proyecto siempre se construya con la misma versiÃ³n probada de la dependencia.

ğŸ§  Pregunta 43

Si realizas cambios en un submÃ³dulo dentro de tu repositorio principal, Â¿cÃ³mo se registran esos cambios en el repositorio del submÃ³dulo?

A. Se registran automÃ¡ticamente en el repositorio principal como parte de los commits del proyecto.
B. Debes navegar al directorio del submÃ³dulo y realizar commits allÃ­ por separado.
C. Los cambios en los submÃ³dulos no se pueden realizar directamente desde el repositorio principal.
D. Se registran automÃ¡ticamente cuando se hace push del repositorio principal.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Un submÃ³dulo es esencialmente un repositorio Git dentro de otro. Para registrar cambios realizados en el directorio del submÃ³dulo, debes navegar a ese directorio y realizar commits utilizando los comandos de Git dentro del propio submÃ³dulo.

ğŸ§  Pregunta 44

Â¿QuÃ© comando se utiliza para obtener la Ãºltima versiÃ³n de los cambios de un submÃ³dulo en tu repositorio principal?

A. git update-submodule <path>
B. git submodule fetch <path>
C. git submodule merge <path>
D. git submodule update --remote <path>

âœ… Correcta: D

ğŸ§¾ ExplicaciÃ³n: El comando git submodule update --remote <path> se utiliza para buscar cambios en el repositorio remoto del submÃ³dulo y actualizar la referencia en tu repositorio principal al Ãºltimo commit de la rama rastreada del submÃ³dulo.

ğŸ§  Pregunta 45

Â¿CuÃ¡l es una desventaja potencial de usar subtrees en comparaciÃ³n con los submÃ³dulos?

A. Los subtrees no permiten incluir proyectos externos dentro de subdirectorios.
B. Los subtrees pueden hacer que el historial de tu repositorio principal sea mÃ¡s complejo al integrar el historial del proyecto externo.
C. Los subtrees no se pueden actualizar una vez agregados.
D. Los subtrees requieren mÃ¡s comandos para su gestiÃ³n que los submÃ³dulos.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Al integrar un subtree, todo el historial del proyecto externo se copia en tu repositorio principal, lo que puede aumentar su tamaÃ±o y complejidad histÃ³rica.

ğŸ§  Pregunta 46

En el ejemplo completo, despuÃ©s de agregar el subtree lib-subs, Â¿cÃ³mo se actualizarÃ­a a una versiÃ³n mÃ¡s reciente del repositorio remoto?

A. Navegando al directorio libs/lib-subs y ejecutando git pull.
B. Utilizando el comando git subtree update --prefix=libs/lib-subs https://github.com/usuario/lib-subs.git master --squash.
C. Ejecutando git submodule update --remote libs/lib-subs.
D. El subtree se actualiza automÃ¡ticamente al hacer git pull en el repositorio principal.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Para actualizar un subtree, se utiliza el comando git subtree pull especificando el prefijo, la URL del repositorio y la rama que se desea integrar, junto con la opciÃ³n --squash si se usÃ³ al agregar el subtree.

ğŸ§  Pregunta 47

Â¿QuÃ© comando se utilizÃ³ en el ejemplo completo para combinar los commits de las ramas feature/login y feature/dashboard en un solo commit de merge en la rama master?

A. git merge feature/login feature/dashboard
B. git merge --squash feature/login feature/dashboard
C. git merge --no-ff feature/login feature/dashboard -m "Octopus merge: integra feature/login y feature/dashboard"
D. git rebase master feature/login feature/dashboard

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El comando git merge --no-ff fuerza la creaciÃ³n de un commit de merge, y al especificar mÃºltiples ramas (feature/login y feature/dashboard), se realiza un "Octopus merge", combinÃ¡ndolas en un Ãºnico commit con el mensaje proporcionado.

ğŸ§  Pregunta 48

En el ejemplo de recuperaciÃ³n con git reflog, si el comando git reset --hard HEAD~1 eliminÃ³ el Ãºltimo commit de merge, Â¿quÃ© comando se utilizÃ³ para volver a ese estado?

A. git checkout HEAD~1
B. git merge --abort
C. git reset --hard HEAD@{1}
D. git revert HEAD

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El reflog rastrea que HEAD@{1} era el estado de HEAD justo antes del reset --hard. Al usar git reset --hard HEAD@{1}, se revierte el repositorio a ese estado anterior, recuperando el commit de merge perdido.

ğŸ§  Pregunta 49

Â¿CuÃ¡l es el propÃ³sito del script run_test.sh mencionado en el ejemplo de git bisect?

A. Automatizar la creaciÃ³n de commits "buenos" y "malos" para la bÃºsqueda binaria.
B. Compilar y ejecutar pruebas para determinar si un commit introduce el error buscado.
C. Visualizar grÃ¡ficamente el proceso de git bisect.
D. Limpiar el repositorio de commits innecesarios antes de iniciar git bisect.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: En un flujo de trabajo de git bisect automatizado, un script de pruebas como run_test.sh se utiliza para verificar si el commit actual contiene el error. El resultado de este script (Ã©xito o fallo) se utiliza para marcar el commit como "bueno" o "malo".

ğŸ§  Pregunta 50

Al ejecutar git blame auth.c -L 100,150, Â¿quÃ© parte especÃ­fica del archivo auth.c se analiza?

A. Todo el archivo auth.c.
B. Solo la primera y la Ãºltima lÃ­nea del archivo.
C. Las lÃ­neas 100 a 150, inclusive.
D. Las lÃ­neas que contienen la funciÃ³n autenticarUsuario.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La opciÃ³n -L 100,150 en el comando git blame especifica que solo se deben analizar las lÃ­neas que se encuentran dentro del rango de la lÃ­nea 100 a la lÃ­nea 150 del archivo auth.c.

ğŸ§  Pregunta 51

Â¿QuÃ© comando se utiliza en el ejemplo para seguir la evoluciÃ³n de la funciÃ³n autenticarUsuario en el archivo auth.c a lo largo del tiempo?

A. git log auth.c
B. git blame auth.c
C. git log -L :autenticarUsuario:auth.c
D. git diff -L :autenticarUsuario:auth.c

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El comando git log -L :<funciÃ³n>:<archivo> permite rastrear los cambios realizados a una funciÃ³n especÃ­fica dentro de un archivo a lo largo del historial de commits.

ğŸ§  Pregunta 52

Â¿CuÃ¡l es la principal ventaja de utilizar un script en Bash para automatizar tareas de Git, como se muestra en el ejemplo?

A. Reduce la necesidad de entender los comandos de Git subyacentes.
B. Permite ejecutar secuencias complejas de comandos de forma consistente y eficiente.
C. Mejora el rendimiento de las operaciones de Git.
D. Permite integrar Git con otros sistemas de control de versiones.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Los scripts de Bash permiten automatizar tareas repetitivas o complejas de Git, asegurando que se ejecuten de la misma manera cada vez y ahorrando tiempo y esfuerzo a los desarrolladores.

ğŸ§  Pregunta 53

En el contexto del script de Bash de ejemplo, Â¿quÃ© permite la selecciÃ³n de una rama para trabajar?

A. Permite al usuario elegir la rama remota que se clonarÃ¡.
B. Permite al usuario especificar la rama local sobre la cual se realizarÃ¡n las operaciones de mantenimiento.
C. Permite al usuario crear una nueva rama con un nombre dinÃ¡mico.
D. Permite al usuario eliminar ramas remotas de forma segura.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: El script lista las ramas locales y permite al usuario seleccionar una de ellas para aplicar las operaciones de rebase, merge o diagnÃ³stico que el script automatiza.

ğŸ§  Pregunta 54

Â¿QuÃ© operaciÃ³n avanzada de merge se incluye como opciÃ³n en el script de Bash de ejemplo?

A. Merge con squash.
B. Merge con rebase.
C. Merge sin Fast-Forward.
D. Merge con resoluciÃ³n de conflictos automÃ¡tica.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El script de ejemplo menciona la inclusiÃ³n de operaciones avanzadas de merge, especÃ­ficamente la opciÃ³n de realizar un merge sin Fast-Forward, lo que permite preservar la historia de las ramas fusionadas.

ğŸ§  Pregunta 55

Â¿QuÃ© herramienta de diagnÃ³stico de Git se ejemplifica utilizando el script de Bash para detectar un error en el repositorio?

A. git status
B. git diff
C. git bisect
D. gitk

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El script de ejemplo estÃ¡ diseÃ±ado para automatizar el uso de git bisect, facilitando la identificaciÃ³n del commit que introdujo un error al guiar al usuario a travÃ©s del proceso de marcar commits como buenos o malos.

ğŸ§  Pregunta 56

En el escenario de ejemplo con el repositorio project-autenticacion, Â¿quÃ© funciÃ³n especÃ­fica se reporta que no se comporta como se esperaba?

A. iniciarSesion()
B. cerrarSesion()
C. autenticarUsuario()
D. cambiarContrasena()

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El escenario de ejemplo se centra en la funciÃ³n autenticarUsuario(), que se reporta que tiene un comportamiento inesperado y se utiliza como caso de estudio para aplicar las herramientas de diagnÃ³stico de Git.

ğŸ§  Pregunta 57

Durante el proceso interactivo de git bisect en el ejemplo, Â¿quÃ© acciÃ³n debe realizar el desarrollador despuÃ©s de que Git selecciona automÃ¡ticamente un commit intermedio?

A. Examinar los metadatos del commit (autor, fecha, mensaje).
B. Comparar el commit actual con el commit "bueno" conocido.
C. Compilar, ejecutar las pruebas y determinar si el comportamiento de la funciÃ³n es correcto o no.
D. Editar el commit para intentar corregir el error.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El paso clave en git bisect es probar el commit que Git selecciona para determinar si el error estÃ¡ presente (git bisect bad) o no (git bisect good).

ğŸ§  Pregunta 58

DespuÃ©s de identificar el commit culpable con git bisect en el ejemplo, Â¿quÃ© se utiliza para ver detalles de los cambios realizados en la secciÃ³n del archivo donde se ubica la funciÃ³n problemÃ¡tica?

A. git diff
B. git show
C. git blame
D. git log -p

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: git blame permite ver lÃ­nea por lÃ­nea quiÃ©n realizÃ³ la Ãºltima modificaciÃ³n y en quÃ© commit, lo que ayuda a entender el contexto del cambio que introdujo el error.

ğŸ§  Pregunta 59

Â¿QuÃ© informaciÃ³n proporciona la salida del comando git blame auth.c -L 100,150 en el ejemplo?

A. Las diferencias entre las lÃ­neas 100 y 150 y la versiÃ³n anterior del archivo.
B. El nÃºmero total de commits que han modificado las lÃ­neas 100 a 150.
C. Para cada lÃ­nea entre 100 y 150, el hash del commit, el autor, la fecha y el contenido de la lÃ­nea.
D. Una lista de los commits realizados por el autor de la Ãºltima modificaciÃ³n en esas lÃ­neas.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: git blame anota cada lÃ­nea dentro del rango especificado con informaciÃ³n sobre el commit que la modificÃ³ por Ãºltima vez, incluyendo el autor y la fecha.

ğŸ§  Pregunta 60

Â¿CuÃ¡l es el propÃ³sito de utilizar git log -L :autenticarUsuario:auth.c en el escenario de ejemplo?

A. Mostrar solo el Ãºltimo commit que modificÃ³ la funciÃ³n autenticarUsuario.
B. Comparar las diferentes versiones de la funciÃ³n autenticarUsuario a lo largo del tiempo.
C. Desplegar, en forma de historial de diffs, todos los commits que han afectado a la funciÃ³n autenticarUsuario.
D. Mostrar las estadÃ­sticas de contribuciÃ³n del autor de la funciÃ³n autenticarUsuario.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La opciÃ³n -L con el nombre de la funciÃ³n permite rastrear la evoluciÃ³n de esa funciÃ³n especÃ­fica a travÃ©s de los diferentes commits que la han modificado, mostrando los cambios realizados en cada uno.

