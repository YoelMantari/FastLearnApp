ğŸ§  Pregunta 1
Â¿CuÃ¡l es el principal beneficio de utilizar expresiones regulares (regex) en la definiciÃ³n de steps en BDD con Gherkin y Behave?

A. Simplifica la escritura de historias de usuario en lenguaje natural.
B. Permite una validaciÃ³n de escenarios mÃ¡s flexible, reutilizable y precisa.
C. Reduce la necesidad de definir mÃºltiples steps para variaciones similares.
D. Asegura que los steps sean directamente interpretados por los usuarios finales.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Las expresiones regulares ofrecen flexibilidad para aceptar diversas entradas, reutilizaciÃ³n de patrones genÃ©ricos, precisiÃ³n en la validaciÃ³n de formatos complejos y centralizaciÃ³n de la lÃ³gica de reconocimiento.

ğŸ§  Pregunta 2
Â¿QuÃ© funciÃ³n cumplen los anclajes ^ y $ en una expresiÃ³n regular utilizada en un step de Behave?

A. Definen el inicio y el final de un grupo de captura dentro del step.
B. Indican que la coincidencia del patrÃ³n debe ocurrir al principio o al final de la lÃ­nea del escenario, respectivamente.
C. Permiten la bÃºsqueda del patrÃ³n en cualquier parte de la lÃ­nea del escenario.
D. Marcan el inicio y el final de una palabra clave especÃ­fica en el step.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El carÃ¡cter ^ ancla la expresiÃ³n regular al inicio de la lÃ­nea, mientras que $ la ancla al final, asegurando que el patrÃ³n coincida con toda la lÃ­nea y no solo con una parte.

ğŸ§  Pregunta 3
En la expresiÃ³n regular ([^"]+), Â¿quÃ© significa la parte [^"]+?

A. Coincide con cualquier carÃ¡cter, incluyendo las comillas dobles.
B. Coincide con una o mÃ¡s ocurrencias de cualquier carÃ¡cter excepto las comillas dobles.
C. Coincide con cero o mÃ¡s ocurrencias de cualquier carÃ¡cter excepto las comillas dobles.
D. Captura opcionalmente cualquier carÃ¡cter que no sea una comilla doble.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Los corchetes [^...] definen una clase de caracteres negada, y el + indica una o mÃ¡s ocurrencias del carÃ¡cter que no estÃ¡ dentro de los corchetes (en este caso, la comilla doble).

ğŸ§  Pregunta 4
Â¿CÃ³mo se podrÃ­a definir un step en Behave para el siguiente texto en Gherkin: "la aplicaciÃ³n estÃ¡ en modo mantenimiento o en modo lectura"?

A. @given(r'^la aplicaciÃ³n estÃ¡ en modo (mantenimiento|lectura)$')
B. @given(r'^la aplicaciÃ³n estÃ¡ en modo mantenimiento|lectura$')
C. @given(r'^la aplicaciÃ³n estÃ¡ en modo [mantenimiento|lectura]$')
D. @given(r'^la aplicaciÃ³n estÃ¡ en modo mantenimiento o lectura$')

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: El uso de parÃ©ntesis () crea un grupo, y la barra vertical | dentro del grupo actÃºa como un operador de disyunciÃ³n (OR), permitiendo que coincida "mantenimiento" o "lectura".

ğŸ§  Pregunta 5
Â¿QuÃ© representa el cuantificador ? en la expresiÃ³n regular artÃ­culo?s??

A. Indica que la palabra "artÃ­culo" debe aparecer una o cero veces, seguida opcionalmente de la letra "s".
B. Indica que la letra "o" en "artÃ­culo" y la letra "s" son opcionales.
C. Indica que tanto la palabra "artÃ­culo" como la letra "s" son opcionales.
D. Indica que la letra inmediatamente anterior al ? (la "o" en "artÃ­culo" y la "s") puede aparecer cero o una vez.

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: El cuantificador ? hace que el carÃ¡cter precedente (en este caso, la "o" al final de "artÃ­culo" y la "s") sea opcional, es decir, que aparezca cero o una vez.

ğŸ§  Pregunta 6
Â¿CuÃ¡l es la diferencia entre \s+ y \s* en una expresiÃ³n regular?

A. \s+ coincide con cualquier carÃ¡cter de espacio en blanco, mientras que \s* coincide con cualquier carÃ¡cter no alfanumÃ©rico.
B. \s+ coincide con uno o mÃ¡s caracteres de espacio en blanco, mientras que \s* coincide con cero o mÃ¡s caracteres de espacio en blanco.
C. \s+ coincide con cero o mÃ¡s caracteres de espacio en blanco, mientras que \s* coincide con uno o mÃ¡s caracteres de espacio en blanco.
D. No hay diferencia, ambos coinciden con cualquier cantidad de espacios en blanco.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El cuantificador + significa "una o mÃ¡s ocurrencias", mientras que * significa "cero o mÃ¡s ocurrencias" del elemento precedente (\s, que representa un carÃ¡cter de espacio en blanco).

ğŸ§  Pregunta 7
Â¿Para quÃ© se utiliza la secuencia \b en la expresiÃ³n regular \bError\b?

A. Para indicar que la palabra "Error" debe estar al principio y al final de la lÃ­nea.
B. Para capturar la palabra "Error" como un grupo.
C. Para asegurar que "Error" coincida como una palabra completa, sin formar parte de otra palabra.
D. Para indicar que la "E" y la "r" en "Error" son caracteres especiales.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: \b es un anclaje de lÃ­mite de palabra. Asegura que la coincidencia de "Error" estÃ© delimitada por caracteres que no son palabras (como espacios, puntuaciÃ³n o el inicio/fin de la cadena).

ğŸ§  Pregunta 8
En la expresiÃ³n regular (activo|inactivo), Â¿quÃ© funciÃ³n cumplen los parÃ©ntesis?

A. Definen un grupo de captura que contendrÃ¡ "activo" o "inactivo".
B. Indican que los caracteres dentro del parÃ©ntesis son opcionales.
C. Agrupan las alternativas para que la disyunciÃ³n | se aplique a toda la palabra.
D. Delimitan una clase de caracteres que incluye "a", "c", "t", "i", "v", "o", "n".

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Los parÃ©ntesis crean un subpatrÃ³n, y dentro de Ã©l, la barra vertical | actÃºa como un operador OR, de modo que la expresiÃ³n coincidirÃ¡ con "activo" O "inactivo".

ğŸ§  Pregunta 9
Â¿CuÃ¡l es la diferencia entre [0-9] y \d en expresiones regulares?

A. [0-9] coincide con cualquier dÃ­gito, mientras que \d coincide con cualquier carÃ¡cter no numÃ©rico.
B. \d es una forma abreviada o alias de la clase de caracteres [0-9], por lo que ambos tienen la misma funciÃ³n.
C. [0-9] solo funciona en ciertos lenguajes de programaciÃ³n, mientras que \d es un estÃ¡ndar universal.
D. \d tiene funcionalidades adicionales para coincidir con formatos numÃ©ricos especÃ­ficos.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: \d es una clase de carÃ¡cter abreviada que representa cualquier dÃ­gito decimal (0-9), siendo equivalente a la clase de caracteres [0-9].

ğŸ§  Pregunta 10
Â¿QuÃ© indica el cuantificador {n,m} en una expresiÃ³n regular?

A. Que el elemento precedente debe aparecer exactamente n veces o exactamente m veces.
B. Que el elemento precedente debe aparecer al menos n veces y como mÃ¡ximo m veces.
C. Que el elemento precedente debe aparecer entre n y m veces, inclusive, pero solo si se encuentra dentro de un grupo.
D. Que el elemento precedente puede aparecer n veces, m veces o cualquier nÃºmero intermedio, de forma opcional.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El cuantificador {n,m} especifica un rango de ocurrencias para el elemento precedente, indicando que debe aparecer como mÃ­nimo n veces y como mÃ¡ximo m veces para que haya una coincidencia.

ğŸ§  Pregunta 11
Â¿Por quÃ© es importante usar raw strings (prefijo r) al definir expresiones regulares en Python para Behave?

A. Para que las expresiones regulares sean interpretadas directamente por Gherkin.
B. Para evitar la necesidad de escapar ciertos caracteres especiales de Python (como la barra invertida \).
C. Para mejorar el rendimiento de la bÃºsqueda de patrones.
D. Para que la sintaxis de las expresiones regulares sea compatible con otros lenguajes.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Los raw strings tratan las barras invertidas \ como caracteres literales, lo que es crucial en expresiones regulares donde la barra invertida se utiliza para escapar caracteres especiales de la regex. Sin raw strings, habrÃ­a que duplicar algunas barras invertidas.

ğŸ§  Pregunta 12
Â¿QuÃ© problema se intenta evitar al anclar siempre las expresiones regulares en los steps de Behave con ^ y $?

A. Coincidir con mÃºltiples lÃ­neas en un solo step.
B. Capturar grupos innecesarios dentro de la lÃ­nea del escenario.
C. Que el patrÃ³n coincida con una parte de la lÃ­nea del escenario en lugar de la lÃ­nea completa.
D. Que la expresiÃ³n regular sea demasiado especÃ­fica y no coincida con variaciones vÃ¡lidas.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Al usar ^ al principio y $ al final de una regex en un step, se asegura que el patrÃ³n coincida con la totalidad de la lÃ­nea del escenario, evitando coincidencias parciales que podrÃ­an llevar a interpretaciones incorrectas del comportamiento.

ğŸ§  Pregunta 13
Â¿CuÃ¡l es el propÃ³sito de la funciÃ³n re.compile() recomendada en las buenas prÃ¡cticas para el uso de regex en BDD?

A. Para validar la sintaxis de la expresiÃ³n regular durante la ejecuciÃ³n de las pruebas.
B. Para optimizar la bÃºsqueda del patrÃ³n al pre-compilar la expresiÃ³n regular, especialmente si se usa varias veces.
C. Para convertir la expresiÃ³n regular en un formato legible para los usuarios finales.
D. Para generar automÃ¡ticamente ejemplos de datos que coincidan con la expresiÃ³n regular.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: re.compile() compila la expresiÃ³n regular en un objeto de patrÃ³n, lo que puede mejorar la eficiencia si el mismo patrÃ³n se utiliza repetidamente, ya que la compilaciÃ³n solo se realiza una vez.

ğŸ§  Pregunta 14
Â¿Por quÃ© es Ãºtil modularizar patrones de regex comunes en constantes dentro de un mÃ³dulo de Python en un proyecto de BDD?

A. Para que los archivos .feature puedan referenciar directamente las expresiones regulares.
B. Para centralizar y facilitar el mantenimiento de las expresiones regulares utilizadas en mÃºltiples steps.
C. Para mejorar la compatibilidad de las expresiones regulares con diferentes versiones de Python.
D. Para reducir el tamaÃ±o de los archivos de definiciÃ³n de steps.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Definir patrones comunes en constantes facilita su reutilizaciÃ³n en diferentes steps, mejora la legibilidad del cÃ³digo y simplifica las actualizaciones o modificaciones de los patrones.

ğŸ§  Pregunta 15
En un escenario de Gherkin donde se espera un correo electrÃ³nico vÃ¡lido, Â¿quÃ© parte de la expresiÃ³n regular ^[\w\.-]+@[\w\.-]+\.[a-z]{2,}$ se encarga de validar el dominio de nivel superior (TLD)?

A. ^[\w\.-]+
B. @[\w\.-]+
C. \.
D. [a-z]{2,}$

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: La parte [a-z]{2,}$ coincide con dos o mÃ¡s letras minÃºsculas al final de la cadena, lo que tÃ­picamente representa el dominio de nivel superior (como "com", "org", "es"). El \. anterior asegura que haya un punto separando el dominio del TLD.

ğŸ§  Pregunta 16
Â¿QuÃ© significa el lookahead positivo (?=\d) en la expresiÃ³n regular ^el mÃ³dulo "([^"]+)"(?=\d)Version(\d+)$?

A. Asegura que el nombre del mÃ³dulo capturado sea seguido por al menos un dÃ­gito, sin incluir ese dÃ­gito en la captura del nombre.
B. Indica que la palabra "Version" debe estar presente y seguida por un dÃ­gito.
C. Requiere que la lÃ­nea comience con "el mÃ³dulo" y que el nombre del mÃ³dulo contenga al menos un dÃ­gito.
D. Valida que la versiÃ³n capturada (\d+) sea un nÃºmero positivo.

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: El lookahead positivo (?=\d) afirma que la posiciÃ³n actual en la cadena debe ser seguida por un dÃ­gito, pero esa coincidencia no se consume (no forma parte de la coincidencia general ni se incluye en ningÃºn grupo de captura).

ğŸ§  Pregunta 17
Â¿CuÃ¡l es el propÃ³sito del lookahead negativo (?!TMP) en la expresiÃ³n regular ^(?!TMP)[A-Z]{3}\d{4}$?

A. Asegurar que el cÃ³digo capturado contenga las letras "TMP".
B. Excluir cualquier cadena que comience con las letras "TMP" de la coincidencia.
C. Validar que las tres primeras letras del cÃ³digo sean diferentes de "TMP".
D. Indicar que la parte [A-Z]{3}\d{4} es opcional si la cadena comienza con "TMP".

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El lookahead negativo (?!TMP) verifica que la cadena que se estÃ¡ evaluando no comience con la secuencia "TMP". Si lo hace, la coincidencia falla.

ğŸ§  Pregunta 18
En una historia de usuario con el step Given como "Administrador" o "Usuario", Â¿cÃ³mo se utiliza la expresiÃ³n regular en el step de Behave correspondiente?

A. @given(r'^como "(Administrador" y "Usuario)"$') para capturar ambos roles simultÃ¡neamente.
B. @given(r'^como "(Administrador|Usuario)"$') para capturar uno de los dos roles.
C. @given(r'^como "Administrador o Usuario"$') para coincidir con la frase literal.
D. @given(r'^como "(Administrador)" o "(Usuario)"$') para capturar cada rol en grupos separados.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La expresiÃ³n regular @given(r'^como "(Administrador|Usuario)"$') utiliza la disyunciÃ³n | dentro de un grupo () para coincidir con "Administrador" o "Usuario", capturando el rol en el grupo.

ğŸ§  Pregunta 19
En el contexto de los criterios de aceptaciÃ³n, Â¿por quÃ© es Ãºtil validar el formato de un campo como el correo electrÃ³nico utilizando expresiones regulares en los steps de Behave?

A. Para asegurar que los datos de ejemplo en los archivos .feature sean sintÃ¡cticamente correctos.
B. Para verificar que la interfaz de usuario presente los datos en un formato legible para el usuario.
C. Para automatizar la verificaciÃ³n de que los datos manejados por el sistema cumplen con un formato especÃ­fico requerido por la lÃ³gica de negocio.
D. Para generar automÃ¡ticamente correos electrÃ³nicos de prueba con diferentes formatos.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Validar el formato de los datos con regex en los steps automatizados asegura que el sistema bajo prueba estÃ© manejando la informaciÃ³n de acuerdo con las reglas definidas en los criterios de aceptaciÃ³n, lo cual es fundamental para la calidad del software.

ğŸ§  Pregunta 20
Al definir un step en Behave para el Gherkin Given el SKU "<sku>" debe coincidir con /\w{3}-\d{4}/, Â¿quÃ© se estÃ¡ validando realmente en el cÃ³digo Python asociado?

A. Que la cadena literal "&lt;sku>" aparezca en el texto del step.
B. Que el valor del parÃ¡metro sku (extraÃ­do del escenario) coincida con la expresiÃ³n regular \w{3}-\d{4}.
C. Que el texto /\w{3}-\d{4}/ se evalÃºe como una expresiÃ³n regular vÃ¡lida en Python.
D. Que el nombre del escenario contenga la palabra "SKU".

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El step estÃ¡ diseÃ±ado para tomar el valor del <sku> del escenario y verificar, mediante una expresiÃ³n regular (en este caso, \w{3}-\d{4}), que ese valor cumple con el patrÃ³n esperado (tres caracteres alfanumÃ©ricos seguidos de un guion y cuatro dÃ­gitos).

ğŸ§  Pregunta 21
Â¿CuÃ¡l es la principal diferencia entre las clases de caracteres simples como [abc] y los rangos como [a-z] en expresiones regulares?

A. Las clases simples solo pueden contener letras, mientras que los rangos pueden incluir nÃºmeros y sÃ­mbolos.
B. Las clases simples definen un conjunto especÃ­fico de caracteres a coincidir, mientras que los rangos definen un intervalo de caracteres.
C. Los rangos son una forma abreviada de escribir clases simples para secuencias alfabÃ©ticas.
D. No hay diferencia funcional entre ambas, solo una diferencia en la sintaxis.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Una clase de caracteres simple enumera los caracteres exactos que se aceptarÃ¡n, mientras que un rango especifica un intervalo continuo de caracteres (letras o nÃºmeros).

ğŸ§  Pregunta 22
En la expresiÃ³n regular [^A-Za-z0-9\s], Â¿quÃ© conjunto de caracteres coincidirÃ¡?

A. Cualquier letra mayÃºscula, minÃºscula, dÃ­gito o espacio en blanco.
B. Cualquier carÃ¡cter que NO sea una letra mayÃºscula, minÃºscula, dÃ­gito o espacio en blanco.
C. Solo los caracteres que no estÃ¡n dentro de los rangos A-Z, a-z, 0-9, ni sean un espacio.
D. Cualquier carÃ¡cter alfanumÃ©rico que no sea un espacio en blanco.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El sÃ­mbolo ^ dentro de los corchetes [...] niega la clase de caracteres, por lo que la expresiÃ³n coincidirÃ¡ con cualquier carÃ¡cter que no estÃ© incluido en la lista (letras mayÃºsculas, minÃºsculas, dÃ­gitos o espacios en blanco).

ğŸ§  Pregunta 23
Â¿CÃ³mo se podrÃ­a modificar la expresiÃ³n regular \d+ artÃ­culo?s? para que coincida tambiÃ©n con la frase "el carro no contiene artÃ­culos"?

A. \d* artÃ­culo?s?
B. \d+ o no artÃ­culo?s?
C. (no \d+)? artÃ­culo?s?
D. (no )?\d* artÃ­culo?s?

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: Al hacer opcional el "no " con (no )? y permitir cero o mÃ¡s dÃ­gitos con \d*, la expresiÃ³n puede coincidir tanto con la presencia como con la ausencia de un nÃºmero de artÃ­culos.

ğŸ§  Pregunta 24
Â¿QuÃ© diferencia fundamental existe entre el cuantificador * (Kleene star) y el cuantificador + (Kleene plus)?

A. * coincide con una o mÃ¡s ocurrencias, mientras que + coincide con cero o mÃ¡s.
B. * solo se aplica a grupos, mientras que + se aplica a caracteres individuales.
C. + requiere al menos una ocurrencia del elemento precedente, mientras que * permite cero o mÃ¡s ocurrencias.
D. No hay una diferencia significativa en su funcionalidad.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El cuantificador * permite que el elemento precedente aparezca cero, una o mÃ¡s veces, mientras que + exige que aparezca al menos una vez.

ğŸ§  Pregunta 25
Â¿En quÃ© situaciÃ³n serÃ­a mÃ¡s apropiado utilizar el lÃ­mite de palabra \b en lugar de simplemente buscar una cadena literal dentro de un step?

A. Cuando la palabra clave siempre aparece al principio o al final de la lÃ­nea.
B. Cuando se necesita capturar la palabra clave para usarla como parÃ¡metro en el step.
C. Cuando se quiere asegurar que la palabra clave coincida como una unidad completa y no como parte de otra palabra.
D. Cuando la palabra clave puede tener variaciones en mayÃºsculas o minÃºsculas.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: \b es Ãºtil cuando la integridad de la palabra es importante, evitando coincidencias no deseadas dentro de palabras mÃ¡s largas.

ğŸ§  Pregunta 26
Â¿CÃ³mo se podrÃ­a definir un step en Behave para el siguiente texto en Gherkin: "el usuario puede ser administrador, editor o lector"?

A. @given(r'^el usuario puede ser (administrador|editor|lector)$')
B. @given(r'^el usuario puede ser administrador|editor|lector$')
C. @given(r'^el usuario puede ser [administrador|editor|lector]$')
D. @given(r'^el usuario puede ser (administrador, editor, lector)$')

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: Al agrupar las opciones "administrador", "editor" y "lector" con parÃ©ntesis () y usar la disyunciÃ³n |, la expresiÃ³n regular coincidirÃ¡ con cualquiera de las tres palabras.

ğŸ§  Pregunta 27
Â¿CuÃ¡l es la ventaja de utilizar alias o clases abreviadas como \w, \d, \s en expresiones regulares?

A. Hacen que las expresiones regulares sean mÃ¡s potentes y capaces de validar formatos mÃ¡s complejos.
B. Mejoran el rendimiento de la bÃºsqueda de patrones en comparaciÃ³n con las clases de caracteres explÃ­citas.
C. Hacen que las expresiones regulares sean mÃ¡s concisas y fÃ¡ciles de leer y escribir.
D. Permiten una mayor compatibilidad con diferentes lenguajes de programaciÃ³n que utilizan regex.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Los alias como \w (alfanumÃ©rico y guion bajo), \d (dÃ­gito) y \s (espacio en blanco) son formas abreviadas de clases de caracteres comunes, lo que mejora la legibilidad y reduce la verbosidad de las expresiones regulares.

ğŸ§  Pregunta 28
En la expresiÃ³n regular [A-Fa-f0-9]{8}, Â¿quÃ© se estÃ¡ especificando sobre la cadena que debe coincidir?

A. Debe contener exactamente 8 caracteres que sean letras de la A a la F (mayÃºsculas o minÃºsculas) o dÃ­gitos del 0 al 9.
B. Debe contener entre 8 y 16 caracteres hexadecimales.
C. Debe comenzar con una letra de la A a la F y terminar con un dÃ­gito del 0 al 9, con una longitud total de 8 caracteres.
D. Debe contener 8 ocurrencias de cualquier carÃ¡cter alfanumÃ©rico.

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: La clase de caracteres [A-Fa-f0-9] define los caracteres hexadecimales vÃ¡lidos, y el cuantificador {8} especifica que debe haber exactamente 8 de estos caracteres.

ğŸ§  Pregunta 29
Â¿CuÃ¡l es la funciÃ³n del carÃ¡cter de escape \ en una expresiÃ³n regular?

A. Iniciar un grupo de captura.
B. Indicar el final de una lÃ­nea de coincidencia.
C. Tratar un carÃ¡cter especial de regex como un carÃ¡cter literal.
D. Definir una clase de caracteres abreviada.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La barra invertida \ se utiliza para escapar caracteres que tienen un significado especial en las expresiones regulares (como ., *, [, ], \, etc.), permitiendo que se interpreten como caracteres literales en la bÃºsqueda.

ğŸ§  Pregunta 30
Â¿En quÃ© escenario el uso de un lookbehind (positivo o negativo) podrÃ­a ser particularmente Ãºtil en la definiciÃ³n de un step de Behave?

A. Cuando se necesita validar la presencia o ausencia de un patrÃ³n al principio de la lÃ­nea.
B. Cuando la decisiÃ³n de coincidir un patrÃ³n depende de lo que le precede en la cadena, sin incluir ese precedente en la coincidencia.
C. Cuando se necesita capturar mÃºltiples ocurrencias de un patrÃ³n dentro de una sola lÃ­nea.
D. Cuando se quiere optimizar la velocidad de ejecuciÃ³n de las pruebas.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Los lookbehind permiten verificar si un patrÃ³n estÃ¡ precedido por otro patrÃ³n especÃ­fico, sin que este Ãºltimo forme parte de la coincidencia principal. Esto es Ãºtil para validaciones contextuales basadas en lo que viene antes.

ğŸ§  Pregunta 31
Â¿CÃ³mo se integra el uso de expresiones regulares en la estructura de una Historia de Usuario en BDD?

A. Las expresiones regulares se utilizan directamente en la secciÃ³n de "Narrativa" para definir el comportamiento esperado.
B. Los tÃ­tulos de los escenarios en las Historias de Usuario a menudo describen el patrÃ³n de entrada esperado, que luego se implementa con regex en los steps.
C. Las expresiones regulares se incluyen en la secciÃ³n de "Para" para especificar los criterios de aceptaciÃ³n tÃ©cnicos.
D. Las Historias de Usuario no tienen una relaciÃ³n directa con las expresiones regulares; estas se utilizan solo en la capa de automatizaciÃ³n de los steps.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Aunque Gherkin en sÃ­ no interpreta regex, es una buena prÃ¡ctica documentar en los tÃ­tulos o descripciones de los escenarios el formato esperado de los datos, lo que guÃ­a la creaciÃ³n de las expresiones regulares en los steps correspondientes.

ğŸ§  Pregunta 32
Â¿CuÃ¡l es el beneficio de utilizar tablas de ejemplos (Examples) en los archivos .feature al probar steps que utilizan expresiones regulares?

A. Permite definir mÃºltiples conjuntos de datos de prueba que se aplicarÃ¡n al mismo escenario, verificando la robustez y la cobertura de la expresiÃ³n regular.
B. Simplifica la sintaxis de las expresiones regulares dentro de los steps.
C. Genera automÃ¡ticamente la documentaciÃ³n de las expresiones regulares utilizadas en el proyecto.
D. Mejora el rendimiento de la ejecuciÃ³n de las pruebas al reducir la complejidad de las expresiones regulares.

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: Las tablas de ejemplos permiten probar un mismo escenario con diversas entradas, lo que es crucial para asegurar que la expresiÃ³n regular definida en el step funcione correctamente con diferentes variaciones de los datos esperados.

ğŸ§  Pregunta 33
Â¿QuÃ© implica la buena prÃ¡ctica de "validar con ejemplos" al trabajar con expresiones regulares en BDD?

A. Asegurarse de que la documentaciÃ³n de la expresiÃ³n regular incluya ejemplos de cadenas que coincidan y que no coincidan.
B. Utilizar las tablas de ejemplos en los archivos .feature para proporcionar diferentes entradas que prueben la expresiÃ³n regular del step.
C. Escribir pruebas unitarias separadas en Python para verificar que la expresiÃ³n regular compile correctamente con re.compile().
D. Comentar detalladamente cada parte de la expresiÃ³n regular para explicar su funcionamiento con ejemplos.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: "Validar con ejemplos" en el contexto de BDD se refiere principalmente a la prÃ¡ctica de usar la secciÃ³n Examples en los archivos .feature para proporcionar mÃºltiples casos de prueba que ejerciten la lÃ³gica de las expresiones regulares en los steps.

ğŸ§  Pregunta 34
En un step que valida una fecha en formato ISO como "2025-04-17" con la regex (\d{4})-(\d{2})-(\d{2}), Â¿para quÃ© se utilizan los parÃ©ntesis?

A. Para definir la estructura general del formato de fecha (aÃ±o-mes-dÃ­a).
B. Para asegurar que los guiones - sean tratados como caracteres literales.
C. Para capturar el aÃ±o, el mes y el dÃ­a como grupos separados, que luego pueden ser utilizados en el cÃ³digo del step.
D. Para indicar que cada parte de la fecha (aÃ±o, mes, dÃ­a) es opcional.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Los parÃ©ntesis en la expresiÃ³n regular crean grupos de captura. En este caso, cada parte de la fecha (aÃ±o, mes, dÃ­a) se captura en un grupo diferente, lo que permite acceder a estos valores individualmente en la funciÃ³n del step (por ejemplo, para convertirlos a enteros y validarlos).

ğŸ§  Pregunta 35
Â¿CuÃ¡l es una recomendaciÃ³n clave para mantener las expresiones regulares utilizadas en los steps de Behave de manera efectiva a largo plazo?

A. Utilizar las expresiones regulares mÃ¡s complejas posibles para cubrir todas las variaciones de entrada en un solo step.
B. Evitar el uso de alias como \w, \d, \s para que las expresiones sean mÃ¡s explÃ­citas.
C. Documentar claramente quÃ© parte de la entrada coincide con cada grupo de captura y la razÃ³n de ser de la expresiÃ³n regular.
D. Generar automÃ¡ticamente las expresiones regulares a partir de los archivos .feature para asegurar la coherencia.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Una documentaciÃ³n clara y concisa de las expresiones regulares, incluyendo quÃ© capturan los grupos y el propÃ³sito del patrÃ³n, es fundamental para el mantenimiento y la comprensiÃ³n del cÃ³digo a lo largo del tiempo, especialmente cuando las expresiones pueden volverse complejas.

ğŸ§  Pregunta 36
Â¿QuÃ© ocurrirÃ­a si en un step de Behave se define una expresiÃ³n regular sin los anclajes ^ y $, por ejemplo, el usuario ingresa \d+?

A. La expresiÃ³n regular solo coincidirÃ­a si la lÃ­nea del escenario contiene exactamente "el usuario ingresa" seguido de uno o mÃ¡s dÃ­gitos, sin ningÃºn otro texto.
B. La expresiÃ³n regular coincidirÃ­a con cualquier lÃ­nea del escenario que contenga la secuencia "el usuario ingresa" seguida de uno o mÃ¡s dÃ­gitos, incluso si hay texto adicional al principio o al final.
C. Behave ignorarÃ­a la expresiÃ³n regular y buscarÃ­a una coincidencia literal del texto en el step.
D. Se generarÃ­a un error durante la ejecuciÃ³n de las pruebas debido a la falta de anclajes.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Sin los anclajes ^ (inicio de lÃ­nea) y $ (fin de lÃ­nea), la expresiÃ³n regular buscarÃ¡ la secuencia especificada en cualquier parte de la lÃ­nea del escenario, lo que podrÃ­a llevar a coincidencias no deseadas.

ğŸ§  Pregunta 37
Â¿CuÃ¡l es la ventaja de utilizar grupos de captura (definidos con parÃ©ntesis ()) en las expresiones regulares de los steps de Behave?

A. Permiten que la expresiÃ³n regular coincida con mÃºltiples lÃ­neas del escenario.
B. Facilitan la validaciÃ³n de la sintaxis de la expresiÃ³n regular en tiempo de ejecuciÃ³n.
C. Permiten extraer partes especÃ­ficas del texto coincidente para utilizarlas como argumentos en la funciÃ³n del step.
D. Mejoran el rendimiento de la bÃºsqueda de patrones al delimitar las partes importantes de la expresiÃ³n.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Los parÃ©ntesis crean grupos de captura, lo que significa que la parte del texto del escenario que coincide con el patrÃ³n dentro de los parÃ©ntesis se puede acceder y utilizar como parÃ¡metros en la funciÃ³n Python asociada al step.

ğŸ§  Pregunta 38
Â¿CÃ³mo se podrÃ­a modificar la expresiÃ³n regular [A-Za-z]+ para que coincida con una o mÃ¡s letras, pero tambiÃ©n permita la inclusiÃ³n de guiones bajos?

A. [A-Za-z_-]+
B. [A-Za-z\u]+
C. [A-Za-z Guion_bajo]+
D. [A-Za-z]-[_]+

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: Al aÃ±adir el guion bajo _ dentro de la clase de caracteres [], la expresiÃ³n regular ahora coincidirÃ¡ con una o mÃ¡s ocurrencias de letras mayÃºsculas, minÃºsculas o guiones bajos. El guion - se escapa con \ o se coloca al principio o al final de la clase para ser tratado como literal.

ğŸ§  Pregunta 39
Â¿En quÃ© situaciÃ³n serÃ­a Ãºtil utilizar un cuantificador de rango como {3,5} en una expresiÃ³n regular dentro de un step de BDD?

A. Cuando se necesita coincidir con un nÃºmero especÃ­fico de ocurrencias, ni mÃ¡s ni menos.
B. Cuando la parte del texto a coincidir tiene una longitud variable dentro de un lÃ­mite definido (mÃ­nimo y mÃ¡ximo).
C. Cuando se quiere especificar un nÃºmero exacto de repeticiones o un nÃºmero ilimitado de repeticiones.
D. Cuando se necesita hacer que una parte de la expresiÃ³n regular sea opcional.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Un cuantificador de rango como {3,5} especifica que el elemento precedente debe aparecer al menos 3 veces y como mÃ¡ximo 5 veces para que haya una coincidencia.

ğŸ§  Pregunta 40
Â¿CuÃ¡l es la diferencia entre . (punto) y \. (punto escapado) en una expresiÃ³n regular utilizada en un step de Behave?

A. No hay diferencia; ambos coinciden con cualquier carÃ¡cter.
B. . coincide con cualquier carÃ¡cter excepto el salto de lÃ­nea, mientras que \. coincide con el carÃ¡cter literal punto.
C. . coincide con el carÃ¡cter literal punto, mientras que \. coincide con cualquier carÃ¡cter.
D. . se utiliza solo dentro de clases de caracteres, mientras que \. se utiliza fuera de ellas.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El punto . es un metacarÃ¡cter que coincide con cualquier carÃ¡cter individual excepto el carÃ¡cter de nueva lÃ­nea. Para coincidir con el carÃ¡cter literal punto, debe escaparse con una barra invertida: \..

ğŸ§  Pregunta 41
Â¿CÃ³mo se podrÃ­a definir un step en Behave para el siguiente texto en Gherkin: "se muestra el precio de $19.99 o â‚¬15.50"?

A. @then(r'^se muestra el precio de (\$|\â‚¬)\d+\.\d{2}$')
B. @then(r'^se muestra el precio de [$â‚¬]\d+.\d{2}$')
C. @then(r'^se muestra el precio de (\$\d+\.\d{2}|\â‚¬\d+\.\d{2})$')
D. @then(r'^se muestra el precio de [\$\â‚¬]\d+.\d{2}$')

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Esta expresiÃ³n utiliza la disyunciÃ³n | dentro de un grupo para permitir la coincidencia de dos patrones alternativos: uno que comienza con $ y otro con â‚¬, ambos seguidos de un nÃºmero con dos decimales. Los caracteres $ y â‚¬ no necesitan ser escapados dentro de una clase de caracteres, pero aquÃ­ se usan como literales dentro de las alternativas.

ğŸ§  Pregunta 42
Â¿QuÃ© representa la secuencia \w+ en una expresiÃ³n regular?

A. Cualquier carÃ¡cter de espacio en blanco repetido una o mÃ¡s veces.
B. Cualquier dÃ­gito repetido una o mÃ¡s veces.
C. Cualquier carÃ¡cter alfanumÃ©rico (letras, nÃºmeros y guion bajo) repetido una o mÃ¡s veces.
D. Cualquier carÃ¡cter no alfanumÃ©rico repetido una o mÃ¡s veces.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: \w es una clase de carÃ¡cter abreviada que representa letras (mayÃºsculas y minÃºsculas), dÃ­gitos (0-9) y el guion bajo (_). El cuantificador + significa "una o mÃ¡s ocurrencias".

ğŸ§  Pregunta 43
Â¿CuÃ¡l es la funciÃ³n del cuantificador {n} en una expresiÃ³n regular?

A. Indica que el elemento precedente debe aparecer al menos n veces.
B. Indica que el elemento precedente debe aparecer como mÃ¡ximo n veces.
C. Indica que el elemento precedente debe aparecer exactamente n veces.
D. Indica que el elemento precedente puede aparecer hasta n veces, de forma opcional.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El cuantificador {n} especifica que el elemento que le precede debe ocurrir exactamente n veces para que haya una coincidencia.

ğŸ§  Pregunta 44
Â¿En quÃ© se diferencia un lookahead de un lookbehind en expresiones regulares?

A. Un lookahead verifica lo que precede al patrÃ³n, mientras que un lookbehind verifica lo que le sigue.
B. Un lookahead consume los caracteres coincidentes, mientras que un lookbehind no lo hace.
C. Un lookahead verifica si un patrÃ³n estÃ¡ seguido (o no seguido) por otro patrÃ³n, mientras que un lookbehind verifica si un patrÃ³n estÃ¡ precedido (o no precedido) por otro patrÃ³n. Ninguno de los dos consume los caracteres verificados.
D. No hay una diferencia funcional significativa entre ambos en el contexto de Behave.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Tanto los lookahead como los lookbehind son aserciones de ancho cero, lo que significa que verifican la presencia (o ausencia) de un patrÃ³n en una posiciÃ³n dada sin incluir esos caracteres en la coincidencia real. La diferencia radica en la direcciÃ³n de la verificaciÃ³n: hacia adelante (lookahead) o hacia atrÃ¡s (lookbehind).

ğŸ§  Pregunta 45
Â¿CÃ³mo se podrÃ­a utilizar una expresiÃ³n regular con grupos de captura en un step de Behave para extraer un nombre de archivo y su extensiÃ³n de una cadena como "documento.pdf"?

A. @then(r'^el archivo es ([^.]+)\.([^.]+)$')
B. @then(r'^el archivo es (.*)\.(.*)$')
C. @then(r'^el archivo es (.+)\..+$')
D. @then(r'^el archivo es (\w+)\.(\w+)$')

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: Esta expresiÃ³n utiliza dos grupos de captura (...). El primero ([^.]+) captura uno o mÃ¡s caracteres que no sean un punto (el nombre del archivo). Luego, \. coincide con el punto literal, y el segundo grupo ([^.]+) captura uno o mÃ¡s caracteres que no sean un punto (la extensiÃ³n).

ğŸ§  Pregunta 46
Â¿Por quÃ© es importante considerar la precedencia de los operadores al construir expresiones regulares complejas para los steps de BDD?

A. Para asegurar que la expresiÃ³n regular sea lo mÃ¡s corta y eficiente posible.
B. Para controlar el orden en que se aplican las diferentes partes de la expresiÃ³n (como la concatenaciÃ³n, la disyunciÃ³n y los cuantificadores) y asegurar que coincida con el patrÃ³n deseado.
C. Para mejorar la legibilidad de la expresiÃ³n regular para los desarrolladores que no estÃ¡n familiarizados con regex.
D. Para optimizar el rendimiento de la ejecuciÃ³n de las pruebas en Behave.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La precedencia de los operadores en regex determina el orden en que se evalÃºan las diferentes partes de la expresiÃ³n. Comprender y tener en cuenta esta precedencia es crucial para construir expresiones que coincidan con el patrÃ³n esperado y evitar comportamientos inesperados.

ğŸ§  Pregunta 47
Â¿CuÃ¡l es una buena prÃ¡ctica al nombrar las constantes que almacenan expresiones regulares comunes en un mÃ³dulo de Python para BDD?

A. Utilizar nombres cortos y genÃ©ricos para facilitar su reutilizaciÃ³n.
B. Incluir la propia expresiÃ³n regular como parte del nombre de la constante.
C. Utilizar nombres descriptivos que indiquen el tipo de patrÃ³n que la expresiÃ³n regular valida (por ejemplo, EMAIL_PATTERN, DATE_ISO_PATTERN).
D. Nombrar las constantes siguiendo la misma convenciÃ³n de nomenclatura que las variables locales dentro de las funciones de los steps.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Utilizar nombres descriptivos para las constantes que almacenan expresiones regulares mejora la legibilidad del cÃ³digo y facilita la comprensiÃ³n del propÃ³sito de cada patrÃ³n.

ğŸ§  Pregunta 48
En un escenario de Gherkin que describe la creaciÃ³n de un producto con un SKU, Â¿cÃ³mo se podrÃ­a utilizar una expresiÃ³n regular directamente en el tÃ­tulo del escenario o en una condiciÃ³n Given?

A. Gherkin interpreta directamente las expresiones regulares para validar los datos de los ejemplos.
B. Se puede incluir una descripciÃ³n del patrÃ³n esperado en el tÃ­tulo o en un Given, que luego se implementa con una expresiÃ³n regular en el step correspondiente.
C. Las expresiones regulares solo se pueden utilizar dentro de las definiciones de los steps en Python.
D. Se pueden usar comentarios especiales en el archivo .feature para documentar la expresiÃ³n regular esperada.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Aunque Gherkin no ejecuta expresiones regulares, es una prÃ¡ctica Ãºtil documentar el formato esperado de los datos directamente en el archivo .feature para proporcionar contexto y claridad sobre la validaciÃ³n que se realizarÃ¡ en el step correspondiente.

ğŸ§  Pregunta 49
Â¿CuÃ¡l es un beneficio de escribir pruebas unitarias para las funciones de los steps que utilizan expresiones regulares?

A. Permite verificar que las expresiones regulares definidas en los steps coinciden con los datos de ejemplo proporcionados en los archivos .feature.
B. Permite probar la lÃ³gica de la funciÃ³n del step con diferentes entradas extraÃ­das por la expresiÃ³n regular, asegurando que la funciÃ³n se comporta correctamente.
C. Asegura que la sintaxis de las expresiones regulares sea vÃ¡lida antes de ejecutar las pruebas de BDD completas.
D. Todas las opciones anteriores son beneficios de escribir pruebas unitarias para los steps.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Las pruebas unitarias para los steps se centran en la lÃ³gica de la funciÃ³n Python que implementa el step, probando cÃ³mo maneja los parÃ¡metros capturados por la expresiÃ³n regular en diferentes escenarios. Si bien la validez de la regex se puede verificar con re.compile(), las pruebas unitarias aseguran que la lÃ³gica del step sea correcta.

ğŸ§  Pregunta 50
Â¿QuÃ© consideraciones importantes se deben tener en cuenta al decidir si una validaciÃ³n compleja debe realizarse directamente en una expresiÃ³n regular dentro de un step o en la lÃ³gica de la funciÃ³n Python del step?

A. La complejidad de la validaciÃ³n, la legibilidad de la expresiÃ³n regular resultante y la necesidad de extraer y utilizar partes especÃ­ficas de la entrada.
B. El impacto en el rendimiento de la ejecuciÃ³n de las pruebas; las expresiones regulares complejas siempre son mÃ¡s lentas.
C. La facilidad con la que se puede documentar la lÃ³gica de validaciÃ³n; la documentaciÃ³n en Python es siempre mejor que en una expresiÃ³n regular.
D. La compatibilidad de la expresiÃ³n regular con diferentes motores de regex; es mejor mantenerlas simples y portÃ¡tiles.

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: Si la validaciÃ³n es muy compleja, una expresiÃ³n regular puede volverse difÃ­cil de leer y mantener. En tales casos, puede ser mejor extraer partes de la entrada con grupos de captura y realizar la lÃ³gica de validaciÃ³n mÃ¡s compleja en el cÃ³digo Python del step, donde es mÃ¡s fÃ¡cil de escribir, leer y probar.

ğŸ§  Pregunta 1
Â¿QuÃ© ventaja principal ofrece el uso de expresiones regulares en los steps de Behave?

A. Elimina la necesidad de escribir cÃ³digo Python
B. Permite adaptar el flujo de trabajo al estilo del equipo
C. Facilita la captura de parÃ¡metros y validaciÃ³n de formatos complejos
D. Reduce la necesidad de escribir historias de usuario

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Las regex permiten capturar parÃ¡metros dinÃ¡micos y validar formatos especÃ­ficos (como fechas o correos) directamente en los steps.

ğŸ§  Pregunta 2
Â¿QuÃ© representa el patrÃ³n ([^"]+) en un step de Behave?

A. Captura cualquier carÃ¡cter incluyendo comillas dobles
B. Captura secuencias que excluyen comillas dobles
C. Valida un campo vacÃ­o
D. Coincide con nÃºmeros decimales

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: [^"] es una clase de caracteres negada que coincide con cualquier carÃ¡cter excepto comillas dobles, y + captura una o mÃ¡s ocurrencias.

ğŸ§  Pregunta 3
Â¿Para quÃ© sirven los anclajes ^ y $ en una regex de Behave?

A. Capturar mÃºltiples grupos en un paso
B. Validar que el patrÃ³n coincida exactamente con toda la lÃ­nea
C. Ignorar mayÃºsculas y minÃºsculas
D. Permitir coincidencias parciales en el texto

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: ^ (inicio) y $ (fin) aseguran que la regex coincida con la lÃ­nea completa, evitando coincidencias no deseadas.

ğŸ§  Pregunta 4
Â¿QuÃ© permite el cuantificador {1,6} en el patrÃ³n \d{1,6}?

A. Exactamente 6 dÃ­gitos
B. Entre 1 y 6 dÃ­gitos consecutivos
C. MÃ­nimo 1 letra y mÃ¡ximo 6 nÃºmeros
D. Cualquier carÃ¡cter entre 1 y 6 veces

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Los cuantificadores de rango {n,m} definen el nÃºmero mÃ­nimo y mÃ¡ximo de repeticiones del elemento anterior.

ğŸ§  Pregunta 5
Â¿QuÃ© efecto tiene (activo|inactivo) en una regex de Behave?

A. Captura ambos estados como un solo parÃ¡metro
B. Valida que el texto contenga ambas palabras
C. Excluye las palabras "activo" e "inactivo"
D. Genera un error de sintaxis

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: La disyunciÃ³n | permite capturar alternativas especÃ­ficas, y los parÃ©ntesis agrupan las opciones para capturarlas como un parÃ¡metro.

ğŸ§  Pregunta 6
Â¿QuÃ© valida la clase de caracteres [A-Za-z0-9]?

A. Solo letras mayÃºsculas
B. Letras (mayÃºsculas/minÃºsculas) y dÃ­gitos
C. Solo caracteres especiales
D. NÃºmeros hexadecimales

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Las clases de caracteres definen un conjunto de caracteres aceptados. A-Za-z0-9 incluye letras y nÃºmeros.

ğŸ§  Pregunta 7
Â¿QuÃ© representa r'^el mensaje termina con un punto \.$'?

A. Un punto literal al final del mensaje
B. Cualquier carÃ¡cter especial
C. Un parÃ¡metro opcional
D. Un error de sintaxis por escape incorrecto

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: \. escapa el punto para que coincida con el carÃ¡cter literal en lugar de actuar como comodÃ­n.

ğŸ§  Pregunta 8
Â¿Para quÃ© se usa \b en la regex \bError\b?

A. Coincidir con "Error" como palabra completa
B. Capturar errores de sintaxis
C. Validar un formato de cÃ³digo binario
D. Ignorar mayÃºsculas/minÃºsculas

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: \b marca un lÃ­mite de palabra, asegurando que "Error" no sea parte de otra palabra (ej: "Error404").

ğŸ§  Pregunta 9
Â¿QuÃ© ventaja ofrece usar r'...' (raw strings) en Python para regex?

A. Convertir automÃ¡ticamente a mayÃºsculas
B. Evitar el escape doble de barras invertidas
C. Permitir interpolaciÃ³n de variables
D. Validar patrones sin anclajes

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Las raw strings simplifican la escritura de regex al no requerir escapar barras invertidas (ej: \d en lugar de \\d).

ğŸ§  Pregunta 10
Â¿QuÃ© hace el lookahead positivo (?=\d) en la regex @when(r'^el mÃ³dulo "([^"]+)"(?=\d)Version(\d+)$')?

A. Captura el dÃ­gito de la versiÃ³n como parte del nombre
B. Asegura que el nombre del mÃ³dulo termina con un dÃ­gito
C. Valida que haya un dÃ­gito despuÃ©s del nombre, sin incluirlo en la captura
D. Excluye mÃ³dulos con nÃºmeros en el nombre

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El lookahead positivo (?=...) verifica que el patrÃ³n exista pero no lo consume para la captura.

ğŸ§  Pregunta 11
Â¿QuÃ© patrÃ³n valida un correo electrÃ³nico correctamente?

A. r'^[\w\.-]+@[\w\.-]+.[a-z]{2,}$'
B. r'^[a-zA-Z0-9]+@[a-zA-Z0-9]+$'
C. r'^.*@.*$'
D. r'^[\w]+@[\w]+$'

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: Este patrÃ³n permite caracteres vÃ¡lidos (letras, nÃºmeros, puntos, guiones) en ambas partes del correo y un dominio de al menos 2 letras.

ğŸ§  Pregunta 12
Â¿QuÃ© representa \w en una regex?

A. Cualquier carÃ¡cter de espacio en blanco
B. Un dÃ­gito numÃ©rico
C. Un carÃ¡cter alfanumÃ©rico o guiÃ³n bajo
D. Un carÃ¡cter especial

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: \w es equivalente a [A-Za-z0-9_], incluyendo letras, nÃºmeros y guiones bajos.

ğŸ§  Pregunta 13
Â¿QuÃ© valida r'^campo\s+valor\s*$'?

A. "campo valor" con exactamente un espacio
B. "campo" seguido de uno o mÃ¡s espacios y "valor" con espacios opcionales al final
C. "campo-valor" sin espacios
D. "campo valor" en cualquier orden

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: \s+ coincide con uno o mÃ¡s espacios, y \s* con cero o mÃ¡s espacios al final.

ğŸ§  Pregunta 14
Â¿QuÃ© permite la regex r'^la clave tiene exactamente [A-Fa-f0-9]{8}$'?

A. Claves de 8 caracteres hexadecimales
B. Claves de 8 letras mayÃºsculas
C. Claves con 8 dÃ­gitos decimales
D. Claves de longitud variable

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: [A-Fa-f0-9] acepta dÃ­gitos hexadecimales (0-9, A-F, a-f), y {8} exige exactamente 8 caracteres.

ğŸ§  Pregunta 15
Â¿QuÃ© representa r'^(?!TMP)[A-Z]{3}\d{4}$'?

A. CÃ³digos que empiezan con "TMP" seguido de 4 dÃ­gitos
B. CÃ³digos de 3 letras (excluyendo "TMP") y 4 dÃ­gitos
C. CÃ³digos que contienen "TMP" en cualquier posiciÃ³n
D. CÃ³digos con 3 dÃ­gitos y 4 letras

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El lookahead negativo (?!TMP) excluye cÃ³digos que empiezan con "TMP", seguido de 3 letras mayÃºsculas y 4 dÃ­gitos.

ğŸ§  Pregunta 16
Â¿QuÃ© se logra con @given(r'^el carro contiene \d+ artÃ­culo?s?$')?

A. Capturar nÃºmeros decimales
B. Manejar singular/plural en "artÃ­culo(s)"
C. Validar un formato de fecha
D. Excluir artÃ­culos del carro

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El ? hace opcional la "s", permitiendo tanto "artÃ­culo" como "artÃ­culos".

ğŸ§  Pregunta 17
Â¿QuÃ© prÃ¡ctica mejora la mantenibilidad de las regex en Behave?

A. Evitar el uso de anclajes
B. Centralizar patrones comunes en constantes
C. Usar comentarios complejos dentro de las regex
D. No validar ejemplos en Gherkin

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Definir patrones comunes (como EMAIL_PATTERN) en constantes reutilizables facilita actualizaciones y reduce duplicaciÃ³n.

ğŸ§  Pregunta 18
Â¿QuÃ© valida r'[^A-Za-z0-9\s]' en un paso?

A. Presencia de caracteres no alfanumÃ©ricos ni espacios
B. Ausencia de letras mayÃºsculas
C. Solo nÃºmeros y espacios
D. Textos en minÃºsculas

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: La clase negada [^...] coincide con cualquier carÃ¡cter fuera del conjunto especificado (no alfanumÃ©ricos ni espacios).

ğŸ§  Pregunta 19
Â¿QuÃ© representa r'^.{6,12}$' en una validaciÃ³n de contraseÃ±a?

A. Exactamente 12 caracteres
B. Entre 6 y 12 caracteres cualesquiera
C. Solo letras y nÃºmeros
D. MÃ­nimo 6 dÃ­gitos

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: . coincide con cualquier carÃ¡cter (excepto saltos de lÃ­nea), y {6,12} define la longitud permitida.

ğŸ§  Pregunta 20
Â¿Por quÃ© es importante anclar regex con ^ y $ en Behave?

A. Para permitir coincidencias parciales en medio del texto
B. Para garantizar que el paso completo coincida con el patrÃ³n
C. Para ignorar mayÃºsculas/minÃºsculas
D. Para capturar mÃºltiples grupos opcionales

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Los anclajes aseguran que el patrÃ³n se aplique a toda la lÃ­nea del step, evitando coincidencias no deseadas por texto adicional.