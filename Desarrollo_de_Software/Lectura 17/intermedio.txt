ğŸ§  Pregunta 1
Â¿QuÃ© rol cumplen las expresiones regulares dentro de los Git hooks?

A. Modifican el historial de commits.
B. Definen la estructura del repositorio.
C. Garantizan la calidad y consistencia mediante validaciones.
D. Automatizan la creaciÃ³n de ramas.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Las regex en Git hooks permiten validar aspectos como el formato de los mensajes de commit o los tipos de archivos incluidos, asegurando la consistencia del repositorio.

ğŸ§  Pregunta 2
En un hook pre-commit, Â¿quÃ© propÃ³sito tiene la siguiente expresiÃ³n regular: \.(py|js|ts|java)$?

A. Busca archivos con esas extensiones para eliminarlos del commit.
B. Asegura que solo se incluyan archivos con las extensiones especificadas.
C. Renombra los archivos con esas extensiones antes del commit.
D. Comprime los archivos con esas extensiones para optimizar el repositorio.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La regex verifica que la ruta del archivo termine ($) con alguna de las extensiones listadas (.py, .js, .ts, .java).

ğŸ§  Pregunta 3
Â¿QuÃ© parte de la siguiente expresiÃ³n regular en commit-msg es opcional: ^(feat|fix|docs|style|refactor|perf|test|chore)(\([a-z0-9\-]+\))?:(\s).{1,72}$?

A. El tipo de commit (feat|fix|...).
B. Los dos puntos y el espacio que siguen al tipo y scope.
C. El scope encerrado entre parÃ©ntesis (\([a-z0-9\-]+\))?.
D. La descripciÃ³n del commit .{1,72}.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El signo de interrogaciÃ³n ? al final del grupo (\([a-z0-9\-]+\)) indica que este grupo (el scope) puede o no estar presente en el mensaje de commit.

ğŸ§  Pregunta 4
En el contexto del hook post-merge, Â¿quÃ© se busca con la expresiÃ³n regular '^(.*):[0-9]+: trailing whitespace'?

A. LÃ­neas que contengan mÃ¡s de un espacio en blanco.
B. LÃ­neas que finalicen con espacios en blanco.
C. LÃ­neas que comiencen con espacios en blanco.
D. La presencia de cualquier tipo de espacio en blanco en las lÃ­neas modificadas.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El patrÃ³n busca lÃ­neas que, segÃºn la salida de git diff --check, contengan la indicaciÃ³n "trailing whitespace" al final de la lÃ­nea.

ğŸ§  Pregunta 5
Dentro del script de generaciÃ³n de reportes, Â¿quÃ© funciÃ³n cumple grep -Po 'Duration: \K[0-9]+\.[0-9]+s'?

A. Busca la lÃ­nea que contiene la palabra "Duration" y la imprime completa.
B. Extrae Ãºnicamente el valor numÃ©rico de la duraciÃ³n, excluyendo "Duration: " y "s".
C. Cuenta el nÃºmero de lÃ­neas que contienen la palabra "Duration".
D. Reemplaza la palabra "Duration" por "Tiempo total".

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: -Po habilita la coincidencia solo de la parte del patrÃ³n que sigue a \K, en este caso, el nÃºmero con decimales representando la duraciÃ³n.

ğŸ§  Pregunta 6
En la configuraciÃ³n de GitHub Actions, Â¿para quÃ© se utiliza la siguiente expresiÃ³n regular dentro de on.tags: 'v[0-9]+.[0-9]+.[0-9]+'?

A. Para nombrar automÃ¡ticamente las etiquetas de las versiones.
B. Para disparar el workflow solo cuando se crea una etiqueta con formato de versionado semÃ¡ntico (vX.Y.Z).
C. Para validar que las etiquetas existentes sigan ese formato.
D. Para eliminar las etiquetas que no coincidan con ese formato.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La regex define un patrÃ³n que deben seguir los nombres de las etiquetas para que el workflow se ejecute en eventos de push de esas etiquetas.

ğŸ§  Pregunta 7
Dentro de la condiciÃ³n if en un paso de GitHub Actions, Â¿quÃ© extrae la siguiente expresiÃ³n regular: 'RELEASE\-\K[0-9]{4}' del mensaje de commit?

A. La palabra completa "RELEASE".
B. Los cuatro dÃ­gitos que siguen a "RELEASE-".
C. Cualquier nÃºmero de cuatro dÃ­gitos dentro del mensaje.
D. La lÃ­nea completa que contiene "RELEASE-".

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: \K hace que grep -Po omita la parte coincidente anterior ("RELEASE-") y solo capture los cuatro dÃ­gitos siguientes.

ğŸ§  Pregunta 8
En el patrÃ³n Arrange-Act-Assert (AAA), Â¿cuÃ¡l es el propÃ³sito de la fase "Act"?

A. Preparar los datos y el contexto necesarios para la prueba.
B. Verificar que el resultado de la acciÃ³n sea el esperado.
C. Ejecutar la acciÃ³n o la funciÃ³n que se estÃ¡ probando.
D. Limpiar cualquier estado modificado durante la prueba.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La fase "Act" se centra en la ejecuciÃ³n del cÃ³digo que se estÃ¡ probando, que en este contexto podrÃ­a ser la aplicaciÃ³n de una expresiÃ³n regular.

ğŸ§  Pregunta 9
En el ejemplo de prueba con pytest, Â¿quÃ© valida la expresiÃ³n regular ^[\w\.-]+@[\w\.-]+\.(com|net|org|co)$?

A. Que una cadena contenga al menos una letra, un nÃºmero y un sÃ­mbolo.
B. Que una cadena tenga un formato de correo electrÃ³nico vÃ¡lido con ciertos dominios de nivel superior.
C. Que una cadena contenga la arroba (@) y un punto (.).
D. Que una cadena no contenga caracteres especiales.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La regex define un patrÃ³n para verificar la estructura bÃ¡sica de una direcciÃ³n de correo electrÃ³nico con restricciones en los dominios finales.

ğŸ§  Pregunta 10
Â¿QuÃ© beneficio aporta la bandera re.VERBOSE al definir expresiones regulares en Python?

A. Mejora el rendimiento de la bÃºsqueda de coincidencias.
B. Permite incluir espacios en blanco y comentarios dentro del patrÃ³n para mejorar la legibilidad.
C. Hace que la coincidencia de patrones no distinga entre mayÃºsculas y minÃºsculas.
D. Permite que el patrÃ³n coincida en mÃºltiples lÃ­neas.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: re.VERBOSE ignora los espacios en blanco y los comentarios (precedidos por #) dentro de la cadena del patrÃ³n, facilitando su documentaciÃ³n y comprensiÃ³n.

ğŸ§  Pregunta 11
SegÃºn el principio FIRST en pruebas, Â¿quÃ© significa que una prueba debe ser "Fast"?

A. Que la prueba debe escribirse rÃ¡pidamente.
B. Que la prueba debe ejecutarse en un tiempo mÃ­nimo.
C. Que la prueba debe fallar rÃ¡pidamente si la condiciÃ³n no se cumple.
D. Que la prueba debe cubrir la mayor cantidad de cÃ³digo posible en el menor tiempo.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Una prueba "Fast" se ejecuta rÃ¡pidamente para no ralentizar el ciclo de desarrollo y permitir una retroalimentaciÃ³n Ã¡gil.

ğŸ§  Pregunta 12
En el ciclo RGR (Red-Green-Refactor), Â¿cuÃ¡l es el objetivo del paso "Green"?

A. Escribir una prueba que inicialmente falle.
B. Mejorar la estructura o legibilidad del cÃ³digo sin cambiar su comportamiento.
C. Modificar el cÃ³digo de la manera mÃ¡s sencilla posible para que la prueba falle.
D. Modificar el cÃ³digo de la manera mÃ¡s sencilla posible para que la prueba pase.

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: El objetivo de la fase "Green" es implementar la funcionalidad necesaria para que la prueba previamente fallida en la fase "Red" ahora pase.

ğŸ§  Pregunta 13
En el primer ciclo RGR del ejemplo ("cat" o "dog"), Â¿por quÃ© la primera versiÃ³n del patrÃ³n r'cat|dog' no era suficiente en la fase "Green"?

A. Porque no coincidÃ­a con las palabras completas "cat" o "dog".
B. Porque tambiÃ©n coincidÃ­a con la palabra "cow".
C. Porque no permitÃ­a plurales como "cats" o "dogs".
D. Porque no distinguÃ­a entre mayÃºsculas y minÃºsculas.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Aunque coincidÃ­a con "cat" y "dog", tambiÃ©n coincidirÃ­a con "cow" si estuviera dentro de una cadena mÃ¡s larga, por lo que no cumplÃ­a con la restricciÃ³n implÃ­cita de ser solo "cat" o "dog".

ğŸ§  Pregunta 14
Â¿QuÃ© problema se intentÃ³ resolver en el tercer ciclo RGR al cambiar .match() por .fullmatch() en las pruebas?

A. Asegurar que la coincidencia no distinguiera entre mayÃºsculas y minÃºsculas.
B. Asegurar que el patrÃ³n coincidiera con la cadena completa y no solo con una parte de ella.
C. Mejorar el rendimiento de la bÃºsqueda de coincidencias.
D. Permitir la bÃºsqueda del patrÃ³n dentro de cadenas mÃ¡s largas.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: .fullmatch() requiere que toda la cadena coincida con el patrÃ³n, a diferencia de .match() que solo requiere una coincidencia al inicio.

ğŸ§  Pregunta 15
Â¿QuÃ© representa el metacaracter \b en la expresiÃ³n regular r'\b(?:cat|dog)s?\b' utilizada en el cuarto ciclo RGR?

A. Un espacio en blanco.
B. El inicio o el final de una palabra.
C. Cualquier carÃ¡cter alfanumÃ©rico.
D. Una nueva lÃ­nea.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: \b es una "ancla de lÃ­mite de palabra" que asegura que el patrÃ³n coincida solo con las palabras completas "cat" o "dog" (y sus plurales), evitando coincidencias dentro de otras palabras.

ğŸ§  Pregunta 16
En el quinto ciclo RGR, Â¿cuÃ¡l fue la principal razÃ³n para considerar reemplazar la expresiÃ³n regular con un conjunto (set) para la validaciÃ³n de animales?

A. Para simplificar la sintaxis del patrÃ³n.
B. Para mejorar el rendimiento en validaciones masivas.
C. Para permitir la coincidencia con variaciones idiomÃ¡ticas mÃ¡s fÃ¡cilmente.
D. Para integrar la validaciÃ³n directamente en la lÃ³gica de la interfaz de usuario.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La bÃºsqueda en un conjunto (con la conversiÃ³n a minÃºsculas) tiene una complejidad temporal promedio de O(1), lo que es mÃ¡s eficiente para grandes volÃºmenes de validaciones en comparaciÃ³n con la bÃºsqueda de patrones en una regex compleja.

ğŸ§  Pregunta 17
Â¿CuÃ¡l de los siguientes es un caso de uso tÃ­pico de las expresiones regulares en el desarrollo de software, segÃºn el texto?

A. Definir la estructura de bases de datos relacionales.
B. Validar el formato de archivos de configuraciÃ³n YAML.
C. Extraer informaciÃ³n especÃ­fica de archivos de log.
D. Generar documentaciÃ³n automÃ¡tica a partir del cÃ³digo fuente.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El texto menciona explÃ­citamente la extracciÃ³n de datos de logs con timestamps y niveles como un caso de uso comÃºn de regex.

ğŸ§  Pregunta 18
Â¿QuÃ© funciÃ³n cumplen los "lookahead" positivos como (?=.*[A-Z]) en una expresiÃ³n regular para validar contraseÃ±as?

A. Aseguran que la cadena coincida completamente con el patrÃ³n principal.
B. Verifican la presencia de un patrÃ³n especÃ­fico en la cadena sin consumir esos caracteres.
C. Definen grupos de captura para extraer partes especÃ­ficas de la contraseÃ±a.
D. Permiten que la contraseÃ±a contenga cualquier carÃ¡cter alfanumÃ©rico.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Los lookahead positivos ((?=...)) realizan una aserciÃ³n sobre lo que debe seguir en la cadena, pero la posiciÃ³n de bÃºsqueda no avanza despuÃ©s de la aserciÃ³n. En este caso, aseguran la presencia de al menos una mayÃºscula, una minÃºscula y un dÃ­gito en cualquier parte de la cadena.

ğŸ§  Pregunta 19
Â¿QuÃ© se busca lograr al integrar expresiones regulares en un pipeline de TDD y CI?

A. Reducir la cantidad de cÃ³digo escrito.
B. Automatizar la implementaciÃ³n de nuevas funcionalidades.
C. Asegurar que cada expresiÃ³n regular evolucione bajo cobertura de pruebas, manteniendo la confiabilidad.
D. Optimizar el tiempo de compilaciÃ³n de la aplicaciÃ³n.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La integraciÃ³n de regex en TDD y CI busca garantizar que las expresiones regulares sean probadas exhaustivamente a medida que se desarrollan y modifican, lo que conduce a patrones mÃ¡s robustos y confiables.

ğŸ§  Pregunta 20
En el contexto de la validaciÃ³n de contraseÃ±as con la regex ^(?=.*[A-Z])(?=.*[a-z])(?=.*\d)[A-Za-z\d]{8,16}$, Â¿quÃ© asegura la parte [A-Za-z\d]{8,16}$?

A. Que la contraseÃ±a contenga al menos una mayÃºscula, una minÃºscula y un dÃ­gito.
B. Que la contraseÃ±a tenga una longitud entre 8 y 16 caracteres y solo contenga letras y nÃºmeros.
C. Que la contraseÃ±a no contenga caracteres especiales.
D. Que la contraseÃ±a termine con un dÃ­gito.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: [A-Za-z\d] define el conjunto de caracteres permitidos (letras mayÃºsculas, minÃºsculas y dÃ­gitos), y {8,16} especifica que la cadena debe tener una longitud mÃ­nima de 8 y mÃ¡xima de 16 caracteres. El anclaje $ asegura que esta restricciÃ³n se aplique al final de la cadena.

ğŸ§  Pregunta 21
Â¿CuÃ¡l es la principal ventaja de utilizar expresiones regulares en los Git hooks en lugar de validaciones mÃ¡s simples?

A. Mayor velocidad de ejecuciÃ³n de los hooks.
B. Mayor flexibilidad y capacidad para definir patrones de validaciÃ³n complejos.
C. IntegraciÃ³n automÃ¡tica con todas las plataformas de Git.
D. ReducciÃ³n del tamaÃ±o del repositorio Git.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Las regex ofrecen un lenguaje potente para describir patrones complejos, lo que permite realizar validaciones mÃ¡s sofisticadas que las simples comparaciones de cadenas.

ğŸ§  Pregunta 22
Si en un hook pre-commit se quisiera permitir tambiÃ©n archivos con extensiÃ³n .css, Â¿cÃ³mo se modificarÃ­a la siguiente regex: \.(py|js|ts|java)$?

A. \.(py|js|ts|java|css)
B. \.(py|js|ts|java\.css)$
C. \.(py|js|ts|java|css)$
D. \.(py,js,ts,java,css)$

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Se agrega |css dentro del grupo de disyunciÃ³n (...) para incluir la nueva extensiÃ³n permitida.

ğŸ§  Pregunta 23
En la expresiÃ³n regular para commit-msg: ^(feat|fix|docs|style|refactor|perf|test|chore)(\([a-z0-9\-]+\))?:(\s).{1,72}$, Â¿quÃ© representa [a-z0-9\-]+ dentro del scope opcional?

A. Cualquier carÃ¡cter alfabÃ©tico o numÃ©rico exactamente una vez.
B. Uno o mÃ¡s caracteres alfabÃ©ticos en minÃºscula, nÃºmeros o guiones.
C. Cero o mÃ¡s caracteres alfabÃ©ticos en minÃºscula, nÃºmeros o guiones.
D. Un rango de caracteres alfabÃ©ticos y numÃ©ricos.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: [a-z0-9\-] define un conjunto de caracteres permitidos (minÃºsculas, nÃºmeros y guion), y + indica que debe haber al menos uno de estos caracteres.

ğŸ§  Pregunta 24
Â¿QuÃ© indica la ausencia de anclajes (^ o $) en la expresiÃ³n regular 'trailing whitespace' utilizada por git diff --check?

A. Que solo se buscarÃ¡n espacios en blanco al inicio y al final de la lÃ­nea.
B. Que se buscarÃ¡n espacios en blanco en cualquier parte de la lÃ­nea.
C. Que se buscarÃ¡n lÃ­neas que contengan la secuencia literal "trailing whitespace".
D. Que se buscarÃ¡n lÃ­neas que no contengan espacios en blanco.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Sin los anclajes, la regex buscarÃ¡ la secuencia "trailing whitespace" en cualquier lugar de la lÃ­nea de salida de git diff --check.

ğŸ§  Pregunta 25
En el script de reportes, Â¿quÃ© funciÃ³n cumple el operador || true al final de las lÃ­neas que usan grep para ERRORS y WARNINGS?

A. Asegura que el script se detenga si no se encuentran errores o advertencias.
B. Hace que el comando grep siempre devuelva un cÃ³digo de salida exitoso (0), incluso si no encuentra coincidencias.
C. Imprime un mensaje indicando que no se encontraron errores o advertencias.
D. Guarda la salida de grep en una variable incluso si estÃ¡ vacÃ­a.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Si grep no encuentra coincidencias, devuelve un cÃ³digo de salida distinto de cero, lo que en un script con set -e harÃ­a que se detuviera. || true asegura que siempre se ejecute un comando exitoso despuÃ©s de grep, evitando la detenciÃ³n del script.

ğŸ§  Pregunta 26
En GitHub Actions, Â¿quÃ© propÃ³sito tiene paths-ignore al definir los disparadores de un workflow?

A. Especificar los archivos que deben incluirse para disparar el workflow.
B. Definir patrones de nombres de archivos que deben ser ignorados para no disparar el workflow.
C. Establecer las rutas donde se guardarÃ¡n los artefactos generados por el workflow.
D. Indicar los directorios donde el workflow buscarÃ¡ los archivos YAML de configuraciÃ³n.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: paths-ignore permite definir patrones de rutas de archivos; si los cambios en un push solo afectan a estos archivos, el workflow no se ejecutarÃ¡.

ğŸ§  Pregunta 27
Â¿QuÃ© significa el cuantificador {4} en la expresiÃ³n regular 'RELEASE\-[0-9]{4}' utilizada en la condiciÃ³n if de GitHub Actions?

A. Que debe haber exactamente cuatro ocurrencias de cualquier carÃ¡cter.
B. Que debe haber entre uno y cuatro dÃ­gitos.
C. Que debe haber exactamente cuatro dÃ­gitos.
D. Que debe haber como mÃ¡ximo cuatro dÃ­gitos.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El cuantificador {n} especifica que el elemento precedente (en este caso, [0-9], cualquier dÃ­gito) debe ocurrir exactamente n veces.

ğŸ§  Pregunta 28
En el patrÃ³n AAA, Â¿cuÃ¡l es el objetivo de la fase "Assert"?

A. Ejecutar la acciÃ³n que se va a probar.
B. Preparar los datos necesarios para la prueba.
C. Verificar si el resultado de la acciÃ³n coincide con el resultado esperado.
D. Limpiar el entorno despuÃ©s de la ejecuciÃ³n de la prueba.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La fase "Assert" es crucial para determinar si la acciÃ³n realizada en la fase "Act" produjo el resultado correcto segÃºn lo definido en la fase "Arrange".

ğŸ§  Pregunta 29
En la expresiÃ³n regular ^[\w\.-]+@[\w\.-]+\.(com|net|org|co)$, Â¿quÃ© representa \w?

A. Cualquier carÃ¡cter de espacio en blanco.
B. Cualquier dÃ­gito.
C. Cualquier carÃ¡cter alfanumÃ©rico (letras, nÃºmeros y guion bajo).
D. Cualquier carÃ¡cter que no sea alfanumÃ©rico.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: \w es una clase de carÃ¡cter predefinida que coincide con letras (mayÃºsculas y minÃºsculas), dÃ­gitos (0-9) y el guion bajo (_).

ğŸ§  Pregunta 30
Â¿Por quÃ© se recomienda usar raw strings (prefijo r) al definir expresiones regulares en Python?

A. Para mejorar el rendimiento de la bÃºsqueda de patrones.
B. Para evitar la necesidad de escapar ciertos caracteres especiales de regex con barras invertidas.
C. Para habilitar la funcionalidad de comentarios y espacios en blanco con re.VERBOSE.
D. Para que las expresiones regulares sean compatibles con otros lenguajes de programaciÃ³n.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Los raw strings tratan las barras invertidas como caracteres literales, lo que es Ãºtil en regex donde la barra invertida tiene un significado especial. Esto evita tener que escribir doble barra invertida para escapar metacaracteres como . o \.

ğŸ§  Pregunta 31
SegÃºn el principio FIRST, Â¿quÃ© implica que una prueba debe ser "Isolated"?

A. Que la prueba debe probar mÃºltiples aspectos de una funcionalidad al mismo tiempo.
B. Que cada prueba debe depender de los resultados de otras pruebas para asegurar la coherencia.
C. Que cada prueba debe validar un Ãºnico aspecto de la funcionalidad y no depender de un estado global o de otras pruebas.
D. Que las pruebas deben ejecutarse en un entorno de pruebas separado del entorno de desarrollo.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El aislamiento asegura que el fallo de una prueba no se deba a efectos secundarios de otras pruebas o a un estado compartido inconsistente, facilitando la identificaciÃ³n de la causa del fallo.

ğŸ§  Pregunta 32
En el ciclo RGR, Â¿cuÃ¡l es el propÃ³sito del paso "Refactor"?

A. Escribir la primera versiÃ³n de una prueba para una nueva funcionalidad.
B. Hacer que una prueba previamente fallida pase utilizando la soluciÃ³n mÃ¡s rÃ¡pida posible.
C. Mejorar la estructura, legibilidad o eficiencia del cÃ³digo (incluyendo la regex) sin alterar su comportamiento funcional.
D. Eliminar las pruebas que ya no son relevantes.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La refactorizaciÃ³n busca mejorar la calidad del cÃ³digo despuÃ©s de que la prueba pasa, haciÃ©ndolo mÃ¡s mantenible y comprensible, sin introducir nuevos errores.

ğŸ§  Pregunta 33
En el ejemplo del primer ciclo RGR, Â¿quÃ© se aÃ±adiÃ³ en la fase "Refactor" a la regex r'^(cat|dog)$'?

A. La capacidad de ignorar mayÃºsculas y minÃºsculas.
B. La validaciÃ³n de que "cat" o "dog" no aparezcan dentro de otras palabras.
C. La opciÃ³n de que las palabras "cat" o "dog" puedan estar en plural.
D. La restricciÃ³n de que solo se acepten las palabras "cat" o "dog" al inicio de la lÃ­nea.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Se aÃ±adiÃ³ s? para hacer que la "s" al final de "cat" o "dog" sea opcional, permitiendo asÃ­ la coincidencia con los plurales.

ğŸ§  Pregunta 34
Â¿QuÃ© funciÃ³n tiene .fullmatch() en Python al trabajar con expresiones regulares?

A. Busca cualquier ocurrencia del patrÃ³n dentro de la cadena.
B. Verifica si el patrÃ³n coincide con el inicio de la cadena.
C. Verifica si el patrÃ³n coincide con toda la cadena, desde el principio hasta el final.
D. Reemplaza todas las ocurrencias del patrÃ³n en la cadena.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: .fullmatch() requiere que la totalidad de la cadena de entrada coincida con el patrÃ³n de la expresiÃ³n regular para que la coincidencia sea exitosa.

ğŸ§  Pregunta 35
Â¿QuÃ© se logrÃ³ al refactorizar la regex para incluir acentos y variaciones idiomÃ¡ticas en el cuarto ciclo RGR?

A. Se simplificÃ³ la expresiÃ³n regular original.
B. Se mejorÃ³ el rendimiento de la bÃºsqueda de coincidencias.
C. Se hizo el patrÃ³n mÃ¡s especÃ­fico para evitar coincidencias no deseadas.
D. Se ampliÃ³ el patrÃ³n para aceptar "gato" y "perro" ademÃ¡s de "cat" y "dog".

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: La refactorizaciÃ³n en este ciclo se centrÃ³ en extender la funcionalidad del patrÃ³n para que pudiera coincidir con las traducciones de las palabras clave en espaÃ±ol.

ğŸ§  Pregunta 36
Â¿QuÃ© posible problema de rendimiento se menciona en el texto al trabajar con expresiones regulares complejas, especÃ­ficamente con el patrÃ³n (a|aa)+b?

A. Un consumo excesivo de memoria durante la compilaciÃ³n del patrÃ³n.
B. Un bucle infinito en el motor de regex al intentar encontrar una coincidencia.
C. Un backtracking costoso que puede llevar a una "explosiÃ³n de estados" y un tiempo de ejecuciÃ³n muy largo.
D. La incompatibilidad del patrÃ³n con diferentes motores de regex.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El patrÃ³n (a|aa)+b es un ejemplo de una regex que puede generar una gran cantidad de posibles caminos de coincidencia (backtracking), lo que puede hacer que el motor de regex tarde mucho tiempo en procesar ciertas entradas o incluso parecer que se "cuelga".

ğŸ§  Pregunta 37
En el contexto de TDD con regex, Â¿por quÃ© es importante escribir las pruebas antes de implementar la expresiÃ³n regular (Timely en FIRST)?

A. Para que las pruebas sirvan como documentaciÃ³n de la regex.
B. Para asegurarse de que la regex sea lo mÃ¡s compleja posible desde el inicio.
C. Para guiar el desarrollo de la regex y asegurar que cumpla con los requisitos definidos por las pruebas.
D. Para optimizar el rendimiento de la regex antes de su uso.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Escribir las pruebas primero (TDD) ayuda a definir claramente quÃ© debe hacer la regex y permite verificar que la implementaciÃ³n cumpla con esos requisitos. Las pruebas guÃ­an el desarrollo de la regex paso a paso.

ğŸ§  Pregunta 38
Â¿QuÃ© tipo de aserciÃ³n se recomienda utilizar en las pruebas de regex segÃºn el principio Self-validating de FIRST?

A. Aserciones que solo verifican si la regex encuentra alguna coincidencia.
B. Aserciones que imprimen un mensaje en caso de fallo, pero no detienen la prueba.
C. Aserciones claras y especÃ­ficas que verifican el resultado esperado de la aplicaciÃ³n de la regex (ej., assert patron.fullmatch(x)).
D. Aserciones que dependen del estado de variables globales definidas fuera de la prueba.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Las aserciones auto-validadas son explÃ­citas sobre lo que se espera y facilitan la identificaciÃ³n de la causa de un fallo en la prueba. assert patron.fullmatch(x) es un ejemplo claro de esto.

ğŸ§  Pregunta 39
En el primer paso del flujo RGR (Red), Â¿cuÃ¡l es el objetivo principal al escribir una prueba?

A. Asegurarse de que la prueba pase inmediatamente.
B. Documentar el comportamiento esperado de la funcionalidad.
C. Crear una prueba que falle porque la funcionalidad aÃºn no estÃ¡ implementada o la implementaciÃ³n actual es incorrecta.
D. Optimizar el rendimiento de la prueba para futuras ejecuciones.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La fase "Red" busca establecer una prueba que demuestre la necesidad de la nueva funcionalidad o la correcciÃ³n de un error, y que inicialmente falle.

ğŸ§  Pregunta 40
En el segundo paso del flujo RGR (Green), Â¿cuÃ¡l es la estrategia recomendada al modificar la expresiÃ³n regular (o el cÃ³digo)?

A. Implementar la soluciÃ³n mÃ¡s robusta y completa posible desde el principio.
B. Modificar la regex de la manera mÃ¡s sencilla posible para que la prueba escrita en la fase "Red" pase.
C. Refactorizar la regex existente para mejorar su legibilidad antes de hacer que la prueba pase.
D. Buscar la soluciÃ³n mÃ¡s eficiente en tÃ©rminos de rendimiento, incluso si es mÃ¡s compleja.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La fase "Green" se centra en hacer que la prueba pase rÃ¡pidamente, incluso si la soluciÃ³n inicial no es la mÃ¡s elegante o eficiente. La refactorizaciÃ³n viene despuÃ©s.

ğŸ§  Pregunta 41
Â¿QuÃ© se buscaba evitar al aÃ±adir la bandera re.IGNORECASE en el segundo ciclo RGR del ejemplo?

A. Que el patrÃ³n coincidiera con caracteres especiales.
B. Que el patrÃ³n distinguiera entre letras mayÃºsculas y minÃºsculas.
C. Que el patrÃ³n solo coincidiera al inicio de la cadena.
D. Que el patrÃ³n permitiera mÃºltiples ocurrencias de las palabras clave.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La bandera re.IGNORECASE hace que la bÃºsqueda de coincidencias no distinga entre mayÃºsculas y minÃºsculas, permitiendo que el patrÃ³n coincida con "Cat" y "cat", por ejemplo.

ğŸ§  Pregunta 42
Â¿Por quÃ© se cambiÃ³ .match() a .fullmatch() en el tercer ciclo RGR del ejemplo?

A. Para que la bÃºsqueda del patrÃ³n fuera mÃ¡s eficiente.
B. Para asegurar que solo se encontraran coincidencias al inicio de la cadena.
C. Para garantizar que la expresiÃ³n regular coincidiera con toda la cadena de prueba y no solo con una parte.
D. Para permitir la bÃºsqueda del patrÃ³n en mÃºltiples lÃ­neas.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: .fullmatch() exige que la totalidad de la cadena coincida con el patrÃ³n, lo que era necesario para evitar coincidencias dentro de palabras mÃ¡s largas como "scatter".

ğŸ§  Pregunta 43
Â¿QuÃ© ventaja principal ofrecÃ­a la refactorizaciÃ³n en el cuarto ciclo RGR al extraer el sufijo opcional s? a una subexpresiÃ³n comÃºn?

A. MejorÃ³ significativamente el rendimiento de la regex.
B. Hizo que el patrÃ³n fuera mÃ¡s fÃ¡cil de entender y mantener, especialmente si se aÃ±adÃ­an mÃ¡s idiomas en el futuro.
C. PermitiÃ³ que el patrÃ³n coincidiera con un mayor nÃºmero de variaciones de las palabras clave.
D. Redujo la longitud total de la expresiÃ³n regular.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Al extraer el sufijo opcional, se hizo el patrÃ³n mÃ¡s modular y fÃ¡cil de modificar si se necesitaban aÃ±adir mÃ¡s palabras clave en el futuro, manteniendo la consistencia del sufijo opcional.

ğŸ§  Pregunta 44
En el quinto ciclo RGR, Â¿cuÃ¡l fue la principal motivaciÃ³n para considerar reemplazar la regex con un conjunto para la validaciÃ³n de animales?

A. Para simplificar la lÃ³gica de las pruebas unitarias.
B. Para mejorar la legibilidad del cÃ³digo de validaciÃ³n.
C. Para optimizar el rendimiento en el caso de un gran nÃºmero de validaciones.
D. Para facilitar la integraciÃ³n con otras partes del sistema.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El uso de un conjunto para la bÃºsqueda (con conversiÃ³n a minÃºsculas) ofrece una complejidad temporal promedio de O(1), lo que es mucho mÃ¡s eficiente para grandes volÃºmenes de datos en comparaciÃ³n con la bÃºsqueda de patrones con una regex compleja.

ğŸ§  Pregunta 45
Â¿QuÃ© se menciona como una posible acciÃ³n en la fase de "Refactor" si despuÃ©s de varios cambios la regex se vuelve compleja y afecta el rendimiento?

A. Eliminar la regex y usar mÃ©todos de string mÃ¡s simples.
B. Convertir el patrÃ³n en un autÃ³mata simplificado o usar una lista precompilada para la validaciÃ³n masiva.
C. Aumentar los recursos computacionales para ejecutar la regex mÃ¡s rÃ¡pidamente.
D. Dividir la regex compleja en varias regex mÃ¡s pequeÃ±as.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La refactorizaciÃ³n puede implicar simplificar el patrÃ³n o, si el rendimiento es crÃ­tico para grandes conjuntos de datos, considerar alternativas como un autÃ³mata o una estructura de datos mÃ¡s eficiente (como un conjunto o un diccionario).

ğŸ§  Pregunta 46
Â¿CuÃ¡l de los siguientes es un ejemplo de validaciÃ³n de formato utilizando regex mencionado en el texto?

A. Verificar que un archivo tenga la extensiÃ³n correcta.
B. Asegurar que el mensaje de un commit siga una convenciÃ³n.
C. Validar el formato de fechas ISO (ej., ^\d{4}-\d{2}-\d{2}$).
D. Extraer niveles de log de un archivo de texto.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El texto proporciona ^\d{4}-\d{2}-\d{2}$ como un ejemplo especÃ­fico de una regex utilizada para validar el formato de fechas ISO.

ğŸ§  Pregunta 47
Â¿QuÃ© se utiliza en la regex para validar contraseÃ±as ^(?=.*[A-Z])(?=.*[a-z])(?=.*\d)[A-Za-z\d]{8,16}$ para asegurar la presencia de al menos una letra mayÃºscula, una minÃºscula y un dÃ­gito sin consumir esos caracteres en la coincidencia principal?

A. Grupos de captura (...).
B. Cuantificadores *, +, ?.
C. Lookahead positivos (?=...).
D. Clases de caracteres [A-Z], [a-z], \d.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Los lookahead positivos (?=.*[A-Z]), (?=.*[a-z]), y (?=.*\d) verifican si existe al menos una mayÃºscula, una minÃºscula y un dÃ­gito respectivamente en cualquier parte de la cadena, sin que estos caracteres formen parte de la coincidencia principal que luego es restringida por [A-Za-z\d]{8,16}.

ğŸ§  Pregunta 48
Â¿QuÃ© se busca lograr al integrar la metodologÃ­a RGR en el desarrollo de expresiones regulares?

A. Escribir la regex mÃ¡s corta posible.
B. Asegurar que la regex sea fÃ¡cil de leer y entender desde el principio.
C. Desarrollar la regex de forma incremental y bajo la guÃ­a de pruebas automatizadas, lo que lleva a patrones mÃ¡s robustos y confiables.
D. Optimizar el rendimiento de la regex antes de escribir cualquier cÃ³digo que la utilice.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El flujo RGR aplicado a las regex permite un desarrollo iterativo donde cada cambio en el patrÃ³n estÃ¡ respaldado por una prueba, lo que ayuda a construir regex complejas de manera mÃ¡s segura y con mayor confianza en su correcciÃ³n.

ğŸ§  Pregunta 49
En un pipeline de calidad que integra regex, Â¿en quÃ© etapa se suelen utilizar los Git hooks con validaciones de patrones en mensajes y nombres de ramas?

A. En la etapa de construcciÃ³n (build).
B. En la etapa de pruebas (test).
C. En la etapa de pre-commit y otros momentos del flujo de trabajo local.
D. En la etapa de despliegue (deploy).

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Los Git hooks se ejecutan localmente en el entorno del desarrollador en puntos especÃ­ficos del flujo de trabajo de Git, como antes de un commit (pre-commit) o despuÃ©s de un merge (post-merge), permitiendo validaciones tempranas.

ğŸ§  Pregunta 50
Â¿CuÃ¡l es el beneficio de utilizar pruebas parametrizadas (como con @pytest.mark.parametrize) al probar expresiones regulares?

A. Reduce la cantidad de cÃ³digo de prueba necesario para cubrir diferentes casos de entrada.
B. Mejora el rendimiento de la ejecuciÃ³n de las pruebas.
C. Permite generar automÃ¡ticamente la documentaciÃ³n de la expresiÃ³n regular.
D. Asegura que todas las pruebas se ejecuten en el mismo orden.

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: La parametrizaciÃ³n permite ejecutar la misma prueba con diferentes conjuntos de datos de entrada y resultados esperados, lo que facilita la cobertura de mÃºltiples casos de prueba con menos cÃ³digo repetitivo.