ğŸ§  Pregunta 1
Â¿QuÃ© beneficio aporta usar un Makefile en proyectos DevOps?

A. Permite ejecutar cÃ³digo sin necesidad de Python
B. Sirve como interfaz grÃ¡fica para el usuario
C. Orquesta tareas repetitivas de forma declarativa y estandarizada
D. Reemplaza completamente a pytest y Git

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El Makefile permite definir comandos complejos de forma declarativa y reproducible, promoviendo automatizaciÃ³n, eficiencia y estandarizaciÃ³n.

ğŸ§  Pregunta 2
Â¿QuÃ© propÃ³sito cumple la variable ACTIVITY en el Makefile presentado?

A. Ejecutar todos los tests en paralelo
B. Definir quÃ© versiÃ³n de Python se usarÃ¡
C. Seleccionar la carpeta especÃ­fica de pruebas a ejecutar
D. Activar el entorno virtual

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: ACTIVITY permite al usuario enfocar las pruebas en una subcarpeta determinada, como aserciones_pruebas, facilitando una ejecuciÃ³n granular.

ğŸ§  Pregunta 3
Â¿CuÃ¡l es el objetivo principal del comando make test_all?

A. Ejecutar flake8 sobre todas las actividades
B. Correr todos los tests en paralelo sin detenerse si fallan
C. Ejecutar pytest en todas las actividades y detenerse si alguna falla
D. Generar reportes de cobertura combinados

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El target test_all itera sobre todas las carpetas de pruebas (ACTIVITIES), ejecutando pytest y deteniendo el proceso si alguna prueba falla, ideal para entornos CI.

ğŸ§  Pregunta 4
Â¿QuÃ© hace la directiva .PHONY en un Makefile?

A. Ejecuta Python automÃ¡ticamente
B. Indica que un objetivo puede ser sobrescrito por otro
C. Impide que un archivo del mismo nombre interfiera con la regla
D. Elimina variables de entorno del sistema

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: .PHONY se usa para declarar que un target no representa un archivo real, evitando conflictos con archivos del mismo nombre.

ğŸ§  Pregunta 5
Â¿QuÃ© comando se sugiere para limpiar datos de cobertura antes de una nueva ejecuciÃ³n?

A. rm -rf htmlcov
B. pytest --clean
C. coverage erase
D. clear coverage

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: coverage erase elimina datos de cobertura anteriores, asegurando que los nuevos resultados sean precisos y actualizados.

ğŸ§  Pregunta 6
Â¿QuÃ© ventaja ofrece el uso de fixtures con autouse=True en pytest?

A. Permite pruebas paralelas sin conflictos
B. Automatiza su ejecuciÃ³n en cada prueba sin necesidad de invocarla explÃ­citamente
C. Reduce el tiempo de ejecuciÃ³n de los tests
D. Evita el uso de asserts en las pruebas

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Al definir un fixture con autouse=True, pytest lo inyecta automÃ¡ticamente en cada test, ideal para configuraciones o setups globales.

ğŸ§  Pregunta 7
Â¿Para quÃ© sirve el target make clean en un entorno de desarrollo?

A. Crea un nuevo entorno virtual limpio
B. Elimina archivos temporales, cachÃ©s y reportes antiguos
C. Reinicia el sistema operativo
D. Borra los archivos de cÃ³digo fuente

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: make clean se encarga de eliminar carpetas como __pycache__, .pytest_cache y reportes de cobertura para limpiar el entorno.

ğŸ§  Pregunta 8
Â¿QuÃ© patrÃ³n de prueba pertenece al enfoque "Four Test Patterns"?

A. run-lint
B. assert-clean
C. setup â†’ exercise â†’ verify â†’ teardown
D. build â†’ run â†’ deploy â†’ monitor

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Los Four Test Patterns definen un flujo claro para las pruebas: preparar datos (setup), ejecutar acciones (exercise), verificar resultados (verify) y limpiar (teardown).

ğŸ§  Pregunta 9
Â¿CuÃ¡l es el objetivo del target make tdd?

A. Automatizar la generaciÃ³n de cÃ³digo
B. Ejecutar pruebas, detenerse si fallan, permitir implementaciÃ³n y volver a probar
C. Crear una interfaz grÃ¡fica para pruebas
D. Subir los cambios al repositorio

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: make tdd simula el ciclo Red-Green-Refactor de TDD: fallar primero, implementar lo mÃ­nimo, pasar los tests y refactorizar.

ğŸ§  Pregunta 10
Â¿CuÃ¡l es la utilidad de integrar Make con Git Hooks, como en el pre-commit?

A. Ejecutar pruebas solo despuÃ©s del merge
B. Permitir commits con errores
C. Automatizar validaciones antes del commit, como lint y test
D. Actualizar automÃ¡ticamente la versiÃ³n del Makefile

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Los hooks pre-commit permiten ejecutar acciones como make lint y make test, bloqueando commits que no pasen ciertas validaciones

ğŸ§  Pregunta 11
Â¿QuÃ© herramienta ejecuta el objetivo make lint segÃºn el Makefile?

A. unittest
B. flake8
C. black
D. behave

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El objetivo make lint ejecuta flake8, una herramienta que analiza errores de estilo y sintaxis en el cÃ³digo Python.

ğŸ§  Pregunta 12
Â¿QuÃ© ventaja ofrece make help en el flujo de trabajo?

A. Ejecuta todas las pruebas automÃ¡ticamente
B. Muestra las actividades disponibles y comandos definidos
C. Instala las dependencias de forma oculta
D. Resuelve conflictos de git automÃ¡ticamente

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: make help muestra todos los comandos disponibles en el Makefile, funcionando como una documentaciÃ³n viva del proyecto.

ğŸ§  Pregunta 13
Â¿QuÃ© sucede si un archivo se llama igual que un target sin .PHONY?

A. El target se ejecuta sin problemas
B. El Makefile lo ignora automÃ¡ticamente
C. Se ejecuta el archivo en lugar de la regla
D. Se elimina el archivo al ejecutar make

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Sin .PHONY, Make puede confundirse y creer que el archivo ya cumple el objetivo, evitando que la regla se ejecute.

ğŸ§  Pregunta 14
Â¿QuÃ© hace PYTHONWARNINGS="ignore::DeprecationWarning" en make test?

A. Muestra advertencias detalladas en los tests
B. Ignora los errores de importaciÃ³n
C. Suprime las advertencias de funciones obsoletas
D. Desactiva el pytest temporalmente

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Esta variable suprime los warnings de funciones obsoletas para que la salida de pytest sea mÃ¡s clara y enfocada.

ğŸ§  Pregunta 15
Â¿Por quÃ© se usa cd - >/dev/null al final de test_all?

A. Elimina la carpeta actual
B. Cambia a la raÃ­z del sistema
C. Regresa al directorio anterior sin mostrar la ruta
D. Borra archivos temporales

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: cd - retorna al directorio anterior, y >/dev/null suprime su salida para mantener la terminal limpia.

ğŸ§  Pregunta 16
Â¿QuÃ© objetivo se recomienda para generar reportes visuales de cobertura?

A. make lint
B. make help
C. make coverage
D. make tdd

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El objetivo make coverage ejecuta coverage html, generando un informe visual en HTML con las lÃ­neas cubiertas por los tests.

ğŸ§  Pregunta 17
Â¿QuÃ© permite el uso de ?= en ACTIVITY ?= aserciones_pruebas?

A. Fijar la actividad como obligatoria
B. Sobrescribir el valor por defecto desde lÃ­nea de comandos
C. Asignar siempre el valor a ACTIVITY
D. Prevenir que se reemplace la variable

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: ?= asigna un valor por defecto solo si la variable no fue definida previamente, lo que permite personalizarla al ejecutar make.

ğŸ§  Pregunta 18
Â¿QuÃ© ventaja tiene usar coverage_individual frente a coverage?

A. Ejecuta menos pruebas
B. Genera un solo archivo HTML de cobertura
C. Permite analizar cobertura por cada carpeta de actividad
D. No requiere instalar coverage

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El objetivo coverage_individual evalÃºa la cobertura de cada actividad por separado y genera un HTML especÃ­fico por cada una.

ğŸ§  Pregunta 19
Â¿QuÃ© librerÃ­a se sugiere para escaneo de vulnerabilidades en el proyecto?

A. requests
B. safety
C. pytest
D. matplotlib

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: safety y pip-audit son herramientas que analizan las dependencias del proyecto para detectar vulnerabilidades conocidas.

ğŸ§  Pregunta 20
Â¿QuÃ© tag se usa en Behave para filtrar escenarios?

A. #Scenario
B. @pytest
C. --filter
D. --tags=@smoke

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: Behave permite ejecutar escenarios especÃ­ficos mediante la opciÃ³n --tags, como --tags=@smoke.

ğŸ§  Pregunta 21
Â¿QuÃ© acciÃ³n hace make docker-test en un flujo DevOps?

A. Ejecuta pruebas sobre una mÃ¡quina local
B. Ejecuta pytest sobre todas las carpetas sin aislar el entorno
C. Ejecuta make test_all dentro de un contenedor Docker
D. Borra imÃ¡genes Docker antiguas

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El objetivo docker-test construye y ejecuta el contenedor miapp:dev y corre dentro de Ã©l make test_all, aislando el entorno.

ğŸ§  Pregunta 22
Â¿QuÃ© paso representa el patrÃ³n "Stimulus" en los Four Test Patterns?

A. Preparar datos
B. Ejecutar la acciÃ³n que se desea probar
C. Comparar resultados
D. Limpiar entorno

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: "Stimulus" se refiere a ejecutar la funciÃ³n o interacciÃ³n que se quiere probar, como una divisiÃ³n o un inicio de sesiÃ³n.

ğŸ§  Pregunta 23
Â¿QuÃ© patrÃ³n se utiliza en test_division_por_cero para verificar una excepciÃ³n?

A. assert equal
B. try-catch
C. with pytest.raises
D. assert not None

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La funciÃ³n with pytest.raises permite verificar que una excepciÃ³n especÃ­fica, como ZeroDivisionError, se haya lanzado.

ğŸ§  Pregunta 24
Â¿QuÃ© herramienta se menciona para cargar resultados de cobertura en GitHub Actions?

A. flake8
B. pipenv
C. codecov-action
D. github-linter

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: codecov/codecov-action es una acciÃ³n que permite subir los reportes generados por coverage a Codecov para su anÃ¡lisis en lÃ­nea.

ğŸ§  Pregunta 25
Â¿QuÃ© prÃ¡ctica permite reproducir una build exactamente?

A. Ejecutar pytest sin fixtures
B. Usar random.seed(42)
C. Guardar el timestamp y commit hash
D. Instalar make con sudo

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Incluir el timestamp y commit hash en los reportes garantiza que se puede reproducir exactamente el estado de una compilaciÃ³n.

ğŸ§  Pregunta 26
Â¿QuÃ© hace el siguiente cÃ³digo en un hook pre-commit?
make test ACTIVITY=pruebas_pytest

A. Crea un entorno virtual
B. Ejecuta todos los escenarios de BDD
C. Ejecuta pytest en una carpeta especÃ­fica antes del commit
D. Borra los archivos de test

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Esta instrucciÃ³n ejecuta las pruebas unitarias localizadas en la carpeta pruebas_pytest como parte de las validaciones previas al commit.

ğŸ§  Pregunta 27
Â¿QuÃ© comando de Make se usa para combinar BDD, TDD, lint y coverage?

A. make tdd
B. make help
C. make ci
D. make docker-test

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: make ci combina los targets lint, test, bdd y coverage, integrando todas las validaciones clave en un solo flujo de integraciÃ³n.

ğŸ§  Pregunta 28
Â¿DÃ³nde deben colocarse las definiciones de pasos (step definitions) de Behave?

A. En conftest.py
B. En el archivo .feature
C. En la carpeta steps/steps.py
D. En requirements.txt

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Behave busca las definiciones de pasos dentro del archivo steps.py ubicado en la subcarpeta steps del directorio features.

ğŸ§  Pregunta 29
Â¿CuÃ¡l de los siguientes es un ejemplo vÃ¡lido de expresiÃ³n regular nombrada en Behave?

A. ".*"
B. (?<email>)
C. (?P<email>[^"]+)
D. ?P="email"

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: (?P<email>[^"]+) es una expresiÃ³n regular nombrada que permite capturar el valor del parÃ¡metro email con claridad y reutilizaciÃ³n.

ğŸ§  Pregunta 30
Â¿QuÃ© significa la prÃ¡ctica DevOps de "idempotencia" aplicada a targets de Make?

A. Cada target se ejecuta solo una vez por sesiÃ³n
B. El target solo puede ejecutarse si no hay errores
C. Ejecutar un target varias veces no produce efectos colaterales adicionales
D. Un target que se autoelimina al terminar

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La idempotencia garantiza que ejecutar un mismo target mÃºltiples veces produzca el mismo resultado, sin duplicar efectos o introducir errores.

ğŸ§  Pregunta 31
Â¿QuÃ© efecto tiene make install en un entorno DevOps?

A. Instala Make en el sistema
B. Crea un contenedor Docker
C. Instala las dependencias del proyecto desde requirements.txt
D. Ejecuta todos los tests automÃ¡ticamente

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: make install ejecuta pip install -r requirements.txt, asegurando que el entorno tenga todas las dependencias del proyecto.

ğŸ§  Pregunta 32
Â¿QuÃ© ventaja ofrece Git al permitir mÃºltiples flujos de trabajo como Git Flow o GitHub Flow?

A. Facilita el uso sin ramas
B. Impide que dos usuarios trabajen en paralelo
C. Permite adaptar el flujo de trabajo al estilo del equipo
D. Requiere siempre trabajar en la rama main

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Git es flexible y permite aplicar diferentes flujos de trabajo segÃºn el tamaÃ±o y estilo del equipo, como ramas cortas o estructuras formales.

ğŸ§  Pregunta 33
Â¿CuÃ¡l es el propÃ³sito de usar @pytest.fixture(scope="module")?

A. Ejecutar la fixture despuÃ©s de cada prueba
B. Compartir la fixture entre mÃºltiples funciones de prueba en el mismo mÃ³dulo
C. Evitar que se ejecute mÃ¡s de una vez
D. Inyectar variables del sistema

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El scope "module" indica que la fixture se ejecuta una vez por mÃ³dulo, siendo compartida por todas las pruebas dentro de Ã©l.

ğŸ§  Pregunta 34
Â¿QuÃ© ocurre si una de las pruebas falla en make test_all?

A. Se ignora y continÃºa
B. Se elimina el directorio
C. Se detiene todo el proceso
D. Se reinicia la ejecuciÃ³n de pruebas automÃ¡ticamente

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: || exit 1 hace que el proceso se detenga al fallar una actividad, ideal para validar calidad antes de un merge en CI/CD.

ğŸ§  Pregunta 35
Â¿CuÃ¡l es la funciÃ³n del comando find . -type d -name "__pycache__"?

A. Buscar archivos ocultos
B. Listar dependencias del proyecto
C. Buscar carpetas de cachÃ© para eliminarlas
D. Encontrar errores en el cÃ³digo

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El comando busca y elimina directorios __pycache__ generados por Python, Ãºtiles para limpiar el entorno antes de una nueva ejecuciÃ³n.

ğŸ§  Pregunta 36
Â¿QuÃ© patrÃ³n de prueba representa mejor el step @then en Behave?

A. Setup
B. Teardown
C. Exercise
D. Verify

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: El step @then se usa para verificar que el resultado de una acciÃ³n coincide con lo esperado, cumpliendo el patrÃ³n de verificaciÃ³n (Verify).

ğŸ§  Pregunta 37
Â¿CuÃ¡l es el objetivo de usar yield dentro de una fixture?

A. Ejecutar dos pruebas al mismo tiempo
B. Declarar que la funciÃ³n es una prueba
C. Separar la fase de setup de la de teardown
D. Eliminar cÃ³digo duplicado

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El uso de yield en una fixture permite definir acciones que ocurren antes (setup) y despuÃ©s (teardown) de cada prueba.

ğŸ§  Pregunta 38
Â¿Para quÃ© sirve coverage report -m?

A. Ejecuta pruebas paralelas
B. Genera mÃ©tricas de rendimiento
C. Muestra el porcentaje de cobertura con detalles de lÃ­nea
D. Crea archivos HTML con los errores

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Este comando muestra un reporte detallado en consola con mÃ©tricas de cobertura lÃ­nea por lÃ­nea para cada archivo del proyecto.

ğŸ§  Pregunta 39
Â¿QuÃ© permite el uso de make scan?

A. Verificar versiones antiguas de Python
B. Hacer un anÃ¡lisis de vulnerabilidades en las dependencias
C. Ejecutar los tests en contenedores
D. Subir resultados a GitHub

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: make scan es un objetivo que puede invocar herramientas como Bandit o safety para detectar vulnerabilidades conocidas en el proyecto.

ğŸ§  Pregunta 40
Â¿QuÃ© representa este bloque en un Makefile?

make
Copiar
Editar
ACTIVITY ?= aserciones_pruebas  
A. La variable es obligatoria
B. La variable ACTIVITY no puede ser modificada
C. Se asigna un valor por defecto si no estÃ¡ definido
D. Es una constante del sistema

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: ?= define un valor por defecto que puede ser sobrescrito al momento de ejecutar make.

ğŸ§  Pregunta 41
Â¿DÃ³nde deben definirse los escenarios de Gherkin en Behave?

A. En conftest.py
B. En archivos .py
C. En archivos .feature
D. En __init__.py

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Los escenarios escritos en lenguaje Gherkin deben almacenarse en archivos .feature dentro del directorio features/.

ğŸ§  Pregunta 42
Â¿QuÃ© representa este paso en Behave?

gherkin
Copiar
Editar
Then debo ver el mensaje "Bienvenido, Cesar"
A. Es una configuraciÃ³n
B. Es un escenario de setup
C. Es una afirmaciÃ³n esperada
D. Es un nombre de feature

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El paso Then representa una afirmaciÃ³n que debe cumplirse despuÃ©s de ejecutar una acciÃ³n, como verificar un mensaje de bienvenida.

ğŸ§  Pregunta 43
Â¿QuÃ© comando genera un reporte visual de cobertura por cada actividad?

A. make coverage
B. make coverage_individual
C. make test_all
D. make pytest-report

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: make coverage_individual ejecuta pruebas y genera reportes de cobertura HTML por cada carpeta de actividad listada en ACTIVITIES.

ğŸ§  Pregunta 44
Â¿CuÃ¡l es el propÃ³sito del target release?

A. Subir resultados de test a un servidor
B. Crear un entorno virtual
C. Generar una etiqueta (tag) en Git con una nueva versiÃ³n
D. Lanzar una versiÃ³n en producciÃ³n automÃ¡ticamente

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El objetivo release permite etiquetar versiones del cÃ³digo fuente en Git con git tag, facilitando la trazabilidad del software.

ğŸ§  Pregunta 45
Â¿QuÃ© herramienta se usa para el anÃ¡lisis estÃ¡tico de cÃ³digo Python en este Makefile?

A. pytest
B. safety
C. flake8
D. behave

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: flake8 se encarga de verificar el estilo del cÃ³digo y errores estÃ¡ticos como nombres no usados, ayudando a mantener estÃ¡ndares de calidad.

ğŸ§  Pregunta 46
Â¿QuÃ© representa el patrÃ³n Red-Green-Refactor?

A. Tres etapas de validaciÃ³n de BDD
B. Tres tipos de entornos de desarrollo
C. Ciclo de TDD: fallo, implementaciÃ³n mÃ­nima y mejora del cÃ³digo
D. Estados de un test hook

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El patrÃ³n Red-Green-Refactor es parte del TDD: primero se escribe un test que falla (Red), luego el cÃ³digo para pasarlo (Green), y finalmente se mejora (Refactor).

ğŸ§  Pregunta 47
Â¿CuÃ¡l es el orden correcto de los Four Test Patterns?

A. Refactor, Commit, Deploy, Merge
B. Init, Verify, Test, Clean
C. Setup, Exercise, Verify, Teardown
D. Create, Launch, Debug, Delete

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El ciclo correcto para escribir pruebas robustas es: preparar el entorno (setup), ejecutar la acciÃ³n (exercise), validar (verify) y limpiar (teardown).

ğŸ§  Pregunta 48
Â¿CuÃ¡l es el objetivo de @then(r'debo ver el mensaje "(?P<mensaje>.+)"') en Behave?

A. Filtrar mensajes de error
B. Validar el mensaje devuelto por el sistema
C. Llamar una funciÃ³n externa
D. Compilar el proyecto

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Este step de Behave verifica que la respuesta del sistema incluya un mensaje esperado, como parte del patrÃ³n de verificaciÃ³n.

ğŸ§  Pregunta 49
Â¿QuÃ© significa usar make -j en contextos DevOps?

A. Ejecutar una prueba especÃ­fica
B. Saltar todos los errores
C. Ejecutar mÃºltiples objetivos de Make en paralelo
D. Generar un journal de logs

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: make -j permite la ejecuciÃ³n paralela de tareas independientes, acelerando builds y validaciones en sistemas con mÃºltiples nÃºcleos.

ğŸ§  Pregunta 50
Â¿QuÃ© sucede si no se definen correctamente los targets .PHONY?

A. Se ejecutan mÃ¡s rÃ¡pido
B. Se sobreescriben automÃ¡ticamente
C. El Makefile puede comportarse de forma inesperada si existe un archivo con el mismo nombre del target
D. Se ignoran todas las reglas

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Sin .PHONY, si hay un archivo con el mismo nombre del target, Make podrÃ­a asumir que ya estÃ¡ actualizado y no ejecutarlo.

