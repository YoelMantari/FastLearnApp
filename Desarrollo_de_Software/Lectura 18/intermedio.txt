üß† Pregunta 1
¬øCu√°l es la principal ventaja de utilizar un Makefile en flujos DevOps, seg√∫n el texto?

A. Simplifica la sintaxis de Python.
B. Ofrece un punto de entrada estandarizado y declarativo para la automatizaci√≥n de tareas.
C. Reemplaza la necesidad de utilizar entornos virtuales.
D. Limita la capacidad de integrar diferentes herramientas de prueba.

‚úÖ Correcta: B
üßæ Explicaci√≥n: El Makefile centraliza y documenta la ejecuci√≥n de comandos complejos, promoviendo la reproducibilidad y eficiencia en los flujos de trabajo DevOps.

üß† Pregunta 2
Seg√∫n el Makefile de ejemplo, ¬øpara qu√© se utiliza la variable ACTIVITIES?

A. Para definir la actividad de prueba por defecto.
B. Para especificar las dependencias del proyecto.
C. Para listar todos los directorios de actividades, facilitando bucles en objetivos como test_all y coverage_individual.
D. Para configurar las opciones de ejecuci√≥n de flake8.

‚úÖ Correcta: C
üßæ Explicaci√≥n: La variable ACTIVITIES proporciona una lista exhaustiva de las carpetas de actividades, lo que permite iterar sobre ellas para ejecutar pruebas o generar informes de cobertura de manera automatizada.

üß† Pregunta 3
¬øQu√© funci√≥n cumple el objetivo .PHONY en un Makefile?

A. Define variables de entorno globales.
B. Ejecuta comandos en segundo plano.
C. Evita conflictos con archivos que tengan el mismo nombre que los objetivos definidos.
D. Especifica las dependencias entre diferentes objetivos.

‚úÖ Correcta: C
üßæ Explicaci√≥n: .PHONY se utiliza para declarar que un objetivo no representa un archivo real, sino una acci√≥n a ejecutar, previniendo errores si existiera un archivo con el mismo nombre.

üß† Pregunta 4
¬øQu√© herramienta de an√°lisis est√°tico de c√≥digo se menciona en el Makefile de ejemplo?

A. pytest
B. coverage
C. flake8
D. pip

‚úÖ Correcta: C
üßæ Explicaci√≥n: El objetivo lint del Makefile utiliza flake8 para verificar el estilo del c√≥digo y detectar errores sint√°cticos o variables no utilizadas.

üß† Pregunta 5
¬øCu√°l es el prop√≥sito del comando PYTHONWARNINGS="ignore::DeprecationWarning" pytest . dentro del objetivo test?

A. Ejecutar solo las pruebas marcadas con DeprecationWarning.
B. Mostrar todos los warnings de deprecaci√≥n durante la ejecuci√≥n de las pruebas.
C. Ignorar los warnings de deprecaci√≥n para mantener una salida de prueba m√°s limpia.
D. Detener la ejecuci√≥n de las pruebas si se encuentra un DeprecationWarning.

‚úÖ Correcta: C
üßæ Explicaci√≥n: La variable de entorno PYTHONWARNINGS se configura para ignorar los warnings de deprecaci√≥n, evitando que estos contaminen la salida de los tests de pytest.

üß† Pregunta 6
En el contexto de la medici√≥n de cobertura de c√≥digo con coverage, ¬øqu√© hace el comando coverage html?

A. Ejecuta las pruebas bajo la herramienta de cobertura.
B. Muestra el porcentaje de cobertura en la terminal.
C. Genera un reporte visual de la cobertura en formato HTML.
D. Elimina los datos de cobertura recopilados previamente.

‚úÖ Correcta: C
üßæ Explicaci√≥n: El comando coverage html procesa los datos de cobertura recopilados y genera un informe detallado en formato HTML, facilitando la visualizaci√≥n de qu√© partes del c√≥digo est√°n cubiertas por las pruebas.

üß† Pregunta 7
¬øQu√© utilidad tienen las fixtures en pytest, seg√∫n el texto?

A. Permiten definir el orden en que se ejecutan las pruebas.
B. Se utilizan para marcar pruebas como lentas o que deben omitirse.
C. Facilitan la compartici√≥n de datos de prueba, clientes simulados o conexiones falsas, reduciendo la duplicaci√≥n de c√≥digo de setup/teardown.
D. Generan autom√°ticamente documentaci√≥n de las pruebas.

‚úÖ Correcta: C
üßæ Explicaci√≥n: Las fixtures en pytest son funciones que se ejecutan antes de las funciones de prueba para proporcionarles los recursos necesarios, como datos o dependencias simuladas, mejorando la eficiencia y legibilidad de las pruebas.

üß† Pregunta 8
¬øCu√°l de las siguientes NO es una buena pr√°ctica DevOps relacionada con el uso de Make, mencionada en el texto?

A. Asegurar la idempotencia de los objetivos.
B. Utilizar variables para ajustar la verbosidad de la salida.
C. Depender exclusivamente de variables de entorno para informaci√≥n sensible.
D. Integrar con herramientas de contenedizaci√≥n como Docker.

‚úÖ Correcta: C
üßæ Explicaci√≥n: El texto expl√≠citamente menciona que la informaci√≥n sensible como contrase√±as o tokens no debe incluirse directamente en el Makefile, sino gestionarse de forma segura a trav√©s de mecanismos como los secrets en entornos de CI/CD.

üß† Pregunta 9
¬øQu√© se logra al integrar Git Hooks con un Makefile, como se describe en el texto?

A. Se automatiza la creaci√≥n de ramas Git basadas en las actividades del Makefile.
B. Se ejecutan autom√°ticamente ciertos targets del Makefile (como lint y test) antes de operaciones Git cr√≠ticas como el commit.
C. Se sincronizan autom√°ticamente los objetivos del Makefile con los comandos de Git.
D. Se utilizan los hooks de Git para definir los targets del Makefile.

‚úÖ Correcta: B
üßæ Explicaci√≥n: Los Git Hooks permiten automatizar la ejecuci√≥n de scripts antes o despu√©s de eventos de Git. Al invocar targets del Makefile desde hooks como pre-commit, se pueden asegurar est√°ndares de calidad y pruebas antes de cada commit.

üß† Pregunta 10
En el contexto de BDD con behave, ¬øqu√© funci√≥n cumplen las expresiones regulares en las definiciones de los pasos (steps.py)?

A. Definen el orden en que se ejecutan los escenarios.
B. Permiten que las funciones de Python (`step_impl`) capturen datos espec√≠ficos del texto en lenguaje natural de los escenarios Gherkin.
C. Se utilizan para generar autom√°ticamente la documentaci√≥n de los escenarios.
D. Validan la estructura sint√°ctica de los archivos `.feature`.

‚úÖ Correcta: B
üßæ Explicaci√≥n: Las expresiones regulares en las definiciones de los pasos de `behave` permiten extraer informaci√≥n relevante del texto de los escenarios Gherkin y pasarla como argumentos a las funciones de Python que implementan la l√≥gica de esos pasos.

üß† Pregunta 11
¬øCu√°l es el prop√≥sito del objetivo install en el Makefile proporcionado?

A. Instalar el sistema operativo base necesario para ejecutar el proyecto.
B. Instalar las dependencias del proyecto listadas en el archivo requirements.txt.
C. Instalar la herramienta make si no est√° presente en el sistema.
D. Instalar un entorno virtual de Python para el proyecto.

‚úÖ Correcta: B
üßæ Explicaci√≥n: El objetivo install utiliza pip para instalar todas las librer√≠as y dependencias requeridas por el proyecto, las cuales est√°n especificadas en el archivo requirements.txt.

üß† Pregunta 12
¬øQu√© beneficio principal aporta la documentaci√≥n integrada a trav√©s del objetivo help en el Makefile?

A. Genera autom√°ticamente diagramas de flujo del proyecto.
B. Permite a cualquier miembro del equipo conocer r√°pidamente las acciones disponibles y c√≥mo ejecutarlas.
C. Realiza una revisi√≥n gramatical de todos los comentarios en el Makefile.
D. Publica la documentaci√≥n del proyecto en un sitio web.

‚úÖ Correcta: B
üßæ Explicaci√≥n: El objetivo help proporciona una lista clara y concisa de los comandos disponibles en el Makefile, junto con una breve descripci√≥n de su uso, lo que facilita la incorporaci√≥n de nuevos miembros al equipo y la comprensi√≥n de las tareas automatizadas.

üß† Pregunta 13
¬øQu√© herramientas podr√≠an complementarse con flake8 dentro del objetivo lint para un an√°lisis de c√≥digo m√°s exhaustivo?

A. pytest y coverage.
B. black y mypy.
C. git y docker.
D. behave y selenium.

‚úÖ Correcta: B
üßæ Explicaci√≥n: black es un formateador de c√≥digo que asegura la consistencia del estilo, mientras que mypy realiza un chequeo est√°tico de tipos, lo que a√±ade una capa adicional de verificaci√≥n de la calidad del c√≥digo al an√°lisis de flake8.

üß† Pregunta 14
¬øQu√© diferencia fundamental existe entre los objetivos test y test_all en el Makefile?

A. test ejecuta pruebas solo en los archivos modificados recientemente, mientras que test_all ejecuta todas las pruebas.
B. test permite especificar una actividad o subdirectorio de pruebas, mientras que test_all ejecuta pruebas en todas las actividades definidas.
C. test genera un reporte de cobertura detallado, mientras que test_all solo indica si las pruebas pasaron o fallaron.
D. test requiere una configuraci√≥n espec√≠fica del entorno, mientras que test_all se ejecuta en un entorno aislado.

‚úÖ Correcta: B
üßæ Explicaci√≥n: El objetivo test est√° dise√±ado para ejecutar pruebas de manera granular en una actividad espec√≠fica, mientras que test_all itera sobre todas las actividades definidas en la variable ACTIVITIES y ejecuta las pruebas en cada una de ellas.

üß† Pregunta 15
¬øCu√°l es la funci√≥n del comando cd - >/dev/null utilizado en el objetivo test_all?

A. Cambia al directorio ra√≠z del proyecto y oculta cualquier salida.
B. Regresa al directorio anterior despu√©s de ejecutar las pruebas en una actividad y suprime la salida de la ruta.
C. Crea un nuevo directorio llamado /dev/null y se mueve a √©l.
D. Elimina todos los archivos temporales generados durante la ejecuci√≥n de las pruebas.

‚úÖ Correcta: B
üßæ Explicaci√≥n: cd - regresa al directorio previamente visitado, y >/dev/null redirige la salida est√°ndar (en este caso, la ruta del directorio) a un "agujero negro", evitando que se muestre en la consola y manteniendo la salida m√°s limpia.

üß† Pregunta 16
En el contexto de la cobertura de c√≥digo, ¬øpor qu√© es √∫til tener un objetivo coverage_individual que genera reportes por actividad?

A. Permite fusionar los reportes de cobertura de diferentes actividades en un √∫nico archivo.
B. Facilita la identificaci√≥n de qu√© √°reas espec√≠ficas del c√≥digo dentro de cada m√≥dulo tienen una cobertura de pruebas deficiente.
C. Reduce el tiempo necesario para generar el reporte de cobertura total del proyecto.
D. Asegura que la cobertura de c√≥digo se mida utilizando diferentes herramientas para cada actividad.

‚úÖ Correcta: B
üßæ Explicaci√≥n: Generar reportes de cobertura individuales por actividad permite un an√°lisis m√°s detallado y espec√≠fico, facilitando que los equipos responsables de componentes particulares identifiquen y mejoren la cobertura de pruebas en su √°rea de responsabilidad.

üß† Pregunta 17
¬øQu√© acciones realiza el objetivo clean en el Makefile de ejemplo?

A. Elimina solo los archivos de cach√© de Python (__pycache__).
B. Elimina archivos de cach√© de Python, la cach√© de pytest, los reportes de cobertura y los datos de cobertura generados.
C. Revierte todos los cambios realizados en el c√≥digo desde la √∫ltima confirmaci√≥n.
D. Detiene todos los contenedores Docker asociados al proyecto.

‚úÖ Correcta: B
üßæ Explicaci√≥n: El objetivo clean est√° dise√±ado para eliminar los artefactos generados durante el desarrollo y las pruebas, como las cach√©s de Python y pytest, as√≠ como los reportes y datos de cobertura, proporcionando un estado limpio para futuras ejecuciones.

üß† Pregunta 18
¬øC√≥mo se puede especificar una actividad de prueba diferente a la predeterminada al ejecutar el objetivo test desde la l√≠nea de comandos con make?

A. Utilizando la opci√≥n -a seguida del nombre de la actividad (e.g., make test -a factories_fakes).
B. Estableciendo la variable de entorno ACTIVITY al invocar make (e.g., make test ACTIVITY=factories_fakes).
C. Modificando directamente el valor de la variable ACTIVITY en el Makefile antes de ejecutar el comando.
D. Utilizando un argumento posicional despu√©s del objetivo test (e.g., make test factories_fakes).

‚úÖ Correcta: B
üßæ Explicaci√≥n: La sintaxis ACTIVITY ?= aserciones_pruebas en el Makefile define un valor por defecto para la variable ACTIVITY, pero permite que este sea sobrescrito proporcionando un nuevo valor directamente en la l√≠nea de comandos al ejecutar make.

üß† Pregunta 19
¬øCu√°l es el prop√≥sito principal de utilizar fixtures con el alcance de "session" (@pytest.fixture(scope="session")) en pytest?

A. Ejecutar la fixture antes y despu√©s de cada test individual dentro de una sesi√≥n.
B. Ejecutar la fixture una sola vez al inicio y al final de toda la sesi√≥n de pruebas, compartiendo los recursos creados entre todos los tests.
C. Ejecutar la fixture autom√°ticamente para todos los tests sin necesidad de declararla en cada funci√≥n de prueba.
D. Limitar el tiempo de ejecuci√≥n de los tests que utilizan esta fixture.

‚úÖ Correcta: B
üßæ Explicaci√≥n: Las fixtures con alcance de "session" se ejecutan una √∫nica vez durante toda la sesi√≥n de pruebas, lo que es √∫til para configurar y liberar recursos costosos (como conexiones a bases de datos o inicializaci√≥n de servicios) que pueden ser compartidos por m√∫ltiples tests, optimizando el tiempo de ejecuci√≥n.

üß† Pregunta 20
¬øQu√© ventaja ofrece el uso de Git Hooks combinados con Make en un flujo de desarrollo?

A. Permite personalizar los comandos de Git utilizando la sintaxis de Makefile.
B. Automatiza la ejecuci√≥n de tareas definidas en el Makefile (como linting y pruebas) en puntos clave del flujo de trabajo de Git, asegurando la calidad del c√≥digo antes de acciones como el commit o el push.
C. Simplifica la gesti√≥n de m√∫ltiples ramas de Git directamente desde el Makefile.
D. Genera autom√°ticamente la documentaci√≥n del repositorio Git en base a los targets del Makefile.

‚úÖ Correcta: B
üßæ Explicaci√≥n: La integraci√≥n de Git Hooks con Make permite automatizar la aplicaci√≥n de pol√≠ticas de calidad y la ejecuci√≥n de verificaciones importantes (como el estilo del c√≥digo y las pruebas unitarias) justo en el momento en que los desarrolladores interact√∫an con Git, como antes de hacer un commit, asegurando una mayor consistencia y calidad en el c√≥digo base.

üß† Pregunta 21
En el contexto de BDD, ¬øcu√°l es la funci√≥n principal de los archivos con extensi√≥n .feature?

A. Contienen las definiciones de los pasos de prueba en c√≥digo Python.
B. Describen el comportamiento esperado del sistema en lenguaje natural, utilizando la sintaxis de Gherkin.
C. Almacenan los resultados de la ejecuci√≥n de los escenarios BDD.
D. Definen la configuraci√≥n del entorno para la ejecuci√≥n de las pruebas de comportamiento.

‚úÖ Correcta: B
üßæ Explicaci√≥n: Los archivos `.feature` son la base de la especificaci√≥n en BDD. Utilizan el lenguaje Gherkin para describir los escenarios de comportamiento desde la perspectiva del usuario o del negocio, facilitando la comprensi√≥n y la colaboraci√≥n entre los diferentes roles del equipo.
üß† Pregunta 22
¬øQu√© representan las anotaciones @given, @when y @then en el contexto de behave?

A. Son directivas para definir el orden de ejecuci√≥n de los escenarios.
B. Marcan funciones de Python que implementan las diferentes fases de un escenario BDD (preparaci√≥n, acci√≥n y resultado).
C. Se utilizan para definir variables de entorno espec√≠ficas para cada escenario.
D. Indican la prioridad de cada paso dentro de un escenario.

‚úÖ Correcta: B
üßæ Explicaci√≥n: Estas anotaciones de `behave` se utilizan en los archivos de definici√≥n de pasos (`steps.py`) para vincular las l√≠neas de los escenarios Gherkin con las funciones de Python que contienen la l√≥gica de implementaci√≥n para la fase de preparaci√≥n (`@given`), la acci√≥n (`@when`) y la verificaci√≥n del resultado (`@then`).
üß† Pregunta 23
Seg√∫n el texto, ¬øcu√°l es el primer paso del ciclo TDD (Red‚ÜíGreen‚ÜíRefactor) que se busca automatizar con el Makefile?

A. La implementaci√≥n de la funcionalidad necesaria para pasar las pruebas.
B. La refactorizaci√≥n del c√≥digo para mejorar su estructura y legibilidad.
C. La ejecuci√≥n de las pruebas existentes, que se espera que fallen inicialmente.
D. La escritura de nuevas pruebas basadas en los requisitos.

‚úÖ Correcta: C
üßæ Explicaci√≥n: El objetivo `tdd` en el `Makefile` primero ejecuta las pruebas existentes con la expectativa de que fallen (`--maxfail=1 && exit 1 || true`), lo que corresponde a la fase "Red" del ciclo TDD, donde se verifica que las pruebas fallan antes de implementar la funcionalidad.
üß† Pregunta 24
En el ejemplo de la clase TestDividir con pytest, ¬øpara qu√© se utiliza la fixture setup_teardown con yield?

A. Para definir el orden en que se ejecutan los m√©todos de prueba dentro de la clase.
B. Para realizar acciones de configuraci√≥n antes de cada prueba y, opcionalmente, acciones de limpieza despu√©s.
C. Para marcar la clase de prueba como dependiente de otras clases de prueba.
D. Para parametrizar los datos de entrada de las pruebas de divisi√≥n.

‚úÖ Correcta: B
üßæ Explicaci√≥n: La estructura con `yield` en una fixture de `pytest` permite definir una parte que se ejecuta antes de cada test (la configuraci√≥n) y una parte opcional que se ejecuta despu√©s de cada test (la limpieza o teardown), siguiendo el patr√≥n Setup/Teardown de las pruebas.
üß† Pregunta 25
¬øQu√© comando make se podr√≠a utilizar para ejecutar tanto las pruebas unitarias como los escenarios BDD y generar un reporte de cobertura, seg√∫n el ejemplo de integraci√≥n h√≠brida?

A. `make test && make bdd && make coverage`
B. `make all`
C. `make ci`
D. `make test_bdd_coverage`

‚úÖ Correcta: C
üßæ Explicaci√≥n: El ejemplo define un objetivo `ci` que agrupa la ejecuci√≥n de `lint`, `test`, `bdd` y `coverage`, permitiendo una validaci√≥n completa de la calidad del c√≥digo con un solo comando `make ci`.
üß† Pregunta 26
¬øCu√°l es una consideraci√≥n de seguridad importante al utilizar Makefiles en entornos DevOps, seg√∫n el texto?

A. Asegurarse de que todos los desarrolladores tengan los mismos permisos para ejecutar los comandos de `make`.
B. Evitar incluir informaci√≥n sensible como contrase√±as o tokens directamente en el `Makefile`, utilizando mecanismos seguros proporcionados por el entorno de CI/CD.
C. Cifrar el archivo `Makefile` para proteger su contenido.
D. Limitar el uso de variables de entorno en el `Makefile` para reducir riesgos de seguridad.

‚úÖ Correcta: B
üßæ Explicaci√≥n: El texto enfatiza la importancia de no incluir informaci√≥n sensible directamente en el `Makefile` debido al riesgo de exposici√≥n. En su lugar, se recomienda utilizar mecanismos seguros como los `secrets` proporcionados por las plataformas de integraci√≥n continua.
üß† Pregunta 27
¬øQu√© utilidad tiene el etiquetado (tagging) de versiones desde el Makefile (objetivo release)?

A. Automatiza la publicaci√≥n del c√≥digo en un registro de paquetes.
B. Facilita la creaci√≥n de puntos de referencia inmutables en la historia del repositorio Git, identificando versiones espec√≠ficas del software.
C. Despliega autom√°ticamente la nueva versi√≥n de la aplicaci√≥n a producci√≥n.
D. Genera autom√°ticamente la documentaci√≥n de la nueva versi√≥n.

‚úÖ Correcta: B
üßæ Explicaci√≥n: El etiquetado en Git permite marcar puntos espec√≠ficos en la historia del repositorio con nombres significativos (generalmente n√∫meros de versi√≥n), lo que facilita el seguimiento de las diferentes versiones del software y la posibilidad de volver a un estado anterior si es necesario. El objetivo `release` en el `Makefile` automatiza este proceso.
üß† Pregunta 28
¬øQu√© implica el concepto de "Build reproducible" mencionado en el texto en relaci√≥n con el Makefile?

A. Que la construcci√≥n del software debe ser r√°pida y eficiente.
B. Que cualquier intento de construir el software desde el mismo punto de partida (c√≥digo fuente y entorno) debe producir el mismo resultado.
C. Que el proceso de construcci√≥n debe generar autom√°ticamente la documentaci√≥n del software.
D. Que los builds deben realizarse en contenedores Docker para asegurar la consistencia del entorno.

‚úÖ Correcta: B
üßæ Explicaci√≥n: Un "Build reproducible" significa que, dado el mismo c√≥digo fuente y las mismas condiciones de entorno, el proceso de construcci√≥n siempre generar√° el mismo artefacto. Incluir informaci√≥n como el `timestamp` y el `commit hash` en los reportes ayuda a la trazabilidad y a asegurar esta reproducibilidad.
üß† Pregunta 29
¬øC√≥mo se integra un Makefile en un pipeline de GitHub Actions, seg√∫n el ejemplo proporcionado?

A. Se define un target especial en el `Makefile` llamado `github-actions`.
B. Se crea un archivo YAML (`.github/workflows/ci.yml`) donde se definen los pasos del workflow, invocando comandos `make` para ejecutar tareas como instalaci√≥n de dependencias, linting y pruebas.
C. GitHub Actions analiza autom√°ticamente el `Makefile` y ejecuta todos los targets definidos.
D. Se utiliza una acci√≥n predefinida de GitHub Actions que interpreta y ejecuta el `Makefile`.

‚úÖ Correcta: B
üßæ Explicaci√≥n: La integraci√≥n se realiza a trav√©s de un archivo de workflow en GitHub Actions (`.github/workflows/ci.yml`), donde se definen los diferentes jobs y steps. En los steps relevantes, se utiliza el comando `run: make <objetivo>` para invocar los targets definidos en el `Makefile`, orquestando as√≠ las tareas de construcci√≥n, prueba y an√°lisis dentro del pipeline de CI/CD.

üß† Pregunta 30
¬øCu√°l es el beneficio principal de utilizar expresiones regulares con nombres (?P<nombre>) en las definiciones de los pasos de behave?

A. Mejoran el rendimiento de la ejecuci√≥n de los escenarios BDD.
B. Facilitan la captura y el acceso a los valores coincidentes del texto del escenario dentro de la funci√≥n de Python del paso, utilizando el nombre definido.
C. Permiten definir m√∫ltiples patrones para un mismo paso.
D. Se utilizan para validar el formato de los datos de entrada en los escenarios.

‚úÖ Correcta: B
üßæ Explicaci√≥n: Las expresiones regulares con nombres permiten extraer partes espec√≠ficas del texto de un paso en un escenario Gherkin y asignarlas a variables con nombres descriptivos dentro de la funci√≥n de Python que implementa ese paso, lo que mejora la legibilidad y el manejo de los datos de prueba.

üß† Pregunta 31
¬øQu√© se entiende por "idempotencia" en el contexto de los targets de un Makefile para DevOps?

A. Que un target solo puede ejecutarse una vez durante la vida del proyecto.
B. Que la ejecuci√≥n repetida de un target produce el mismo resultado y no tiene efectos secundarios no deseados.
C. Que los targets deben ejecutarse en un orden espec√≠fico para evitar errores.
D. Que cada target debe tener una √∫nica dependencia.

‚úÖ Correcta: B
üßæ Explicaci√≥n: La idempotencia es crucial en la automatizaci√≥n, especialmente en entornos de CI/CD. Un target idempotente puede ejecutarse varias veces sin alterar el estado del sistema de manera inesperada, asegurando la consistencia y la fiabilidad.
üß† Pregunta 32
¬øC√≥mo se podr√≠a alternar entre una salida silenciosa y una salida detallada al ejecutar comandos make, seg√∫n las buenas pr√°cticas mencionadas?

A. Utilizando diferentes objetivos como `test_verbose` y `test_silent`.
B. Definiendo una variable en el `Makefile` (e.g., `VERBOSE`) y utiliz√°ndola en los comandos con condicionales o pasando su valor a las herramientas de l√≠nea de comandos.
C. Modificando la configuraci√≥n global de `make` en el sistema.
D. Utilizando flags espec√≠ficos de `make` al invocar los comandos desde la terminal.

‚úÖ Correcta: B
üßæ Explicaci√≥n: El uso de variables como `VERBOSE` permite controlar el nivel de detalle de la salida de los comandos. Se pueden usar condicionales dentro del `Makefile` o pasar el valor de la variable a las herramientas subyacentes para ajustar la verbosidad.
üß† Pregunta 33
¬øQu√© ventaja ofrece la ejecuci√≥n paralela de targets independientes en make (e.g., con make -j)?

A. Reduce la complejidad del `Makefile`.
B. Acelera el tiempo total de ejecuci√≥n al realizar m√∫ltiples tareas simult√°neamente.
C. Asegura que los targets se ejecuten en un orden espec√≠fico.
D. Permite una mejor gesti√≥n de las dependencias entre targets.

‚úÖ Correcta: B
üßæ Explicaci√≥n: La opci√≥n `-j` de `make` permite ejecutar m√∫ltiples targets en paralelo, siempre que sus dependencias lo permitan. Esto puede reducir significativamente el tiempo total necesario para completar todas las tareas, especialmente en proyectos con muchas pruebas o an√°lisis independientes.
üß† Pregunta 34
¬øPor qu√© es recomendable integrar el Makefile con entornos virtuales de Python (como venv) o contenedores Docker?

A. Para reducir el tama√±o del repositorio del proyecto.
B. Para asegurar un entorno de ejecuci√≥n aislado y consistente, evitando problemas de dependencias entre diferentes proyectos o el sistema base.
C. Para mejorar la seguridad del c√≥digo fuente.
D. Para facilitar la edici√≥n del `Makefile` en diferentes sistemas operativos.

‚úÖ Correcta: B
üßæ Explicaci√≥n: Los entornos virtuales y los contenedores proporcionan aislamiento, asegurando que el proyecto se ejecute con las dependencias y la configuraci√≥n correctas, independientemente del entorno local del desarrollador o del servidor de CI/CD. Esto evita errores relacionados con versiones de librer√≠as o configuraciones del sistema.
üß† Pregunta 35
¬øQu√© funci√≥n cumple el comando set -e en scripts shell invocados desde un Makefile?

A. Establece variables de entorno para el script.
B. Ejecuta el script en modo de depuraci√≥n.
C. Hace que el script se detenga inmediatamente si cualquier comando dentro del script falla (devuelve un c√≥digo de salida diferente de cero).
D. Redirige la salida de error del script a un archivo espec√≠fico.

‚úÖ Correcta: C
üßæ Explicaci√≥n: `set -e` es una pr√°ctica importante para el control de errores en scripts. Al activarlo, el script se detendr√° en el primer comando que falle, lo que ayuda a detectar y solucionar problemas de manera m√°s temprana en los procesos automatizados.
üß† Pregunta 36
¬øQu√© tipo de informaci√≥n se recomienda exponer como variables parametrizables en un Makefile?

A. Contrase√±as y tokens de acceso.
B. Nombres de archivos fuente sensibles.
C. Rutas de directorios, versiones de lenguajes de programaci√≥n y ubicaciones de artefactos generados.
D. La estructura interna del c√≥digo fuente.

‚úÖ Correcta: C
üßæ Explicaci√≥n: Exponer rutas, versiones de herramientas y directorios de salida como variables facilita la configuraci√≥n y adaptaci√≥n del `Makefile` a diferentes entornos o necesidades sin tener que modificar la l√≥gica de los targets.
üß† Pregunta 37
¬øQu√© herramienta se menciona para auditar las dependencias de Python en busca de vulnerabilidades de seguridad?

A. `flake8`
B. `mypy`
C. `pip-audit` o `safety`
D. `coverage`

‚úÖ Correcta: C
üßæ Explicaci√≥n: `pip-audit` y `safety` son herramientas dise√±adas espec√≠ficamente para analizar las dependencias de un proyecto de Python y detectar vulnerabilidades de seguridad conocidas, lo cual es crucial en las consideraciones de seguridad en DevOps.
üß† Pregunta 38
¬øQu√© tipo de vulnerabilidades podr√≠a ayudar a detectar la integraci√≥n de objetivos como make scan que ejecutan OWASP Dependency-Check o Bandit?

A. Errores de sintaxis en el c√≥digo Python.
B. Problemas de estilo de c√≥digo que no cumplen con PEP 8.
C. Vulnerabilidades en las dependencias del proyecto (OWASP Dependency-Check) y problemas de seguridad en el c√≥digo fuente (Bandit).
D. Errores de tipo en el c√≥digo Python.

‚úÖ Correcta: C
üßæ Explicaci√≥n: OWASP Dependency-Check se centra en identificar vulnerabilidades conocidas en las dependencias del proyecto, mientras que Bandit es una herramienta que analiza el c√≥digo fuente en busca de problemas de seguridad comunes. Integrar ambos en un `make scan` proporciona una capa robusta de an√°lisis de seguridad.
üß† Pregunta 39
¬øCu√°l es el prop√≥sito de copiar un script en .git/hooks/pre-commit y darle permisos de ejecuci√≥n (chmod +x)?

A. Definir alias personalizados para los comandos de Git.
B. Automatizar la ejecuci√≥n de ese script cada vez que se intenta realizar un commit en Git.
C. Crear un acceso directo ejecutable a un script que se encuentra en otro directorio.
D. Modificar el comportamiento predeterminado del comando `git commit`.

‚úÖ Correcta: B
üßæ Explicaci√≥n: Los scripts colocados en el directorio `.git/hooks` y marcados como ejecutables se activan autom√°ticamente en puntos espec√≠ficos del flujo de trabajo de Git. El hook `pre-commit` se ejecuta justo antes de que se realice un commit, lo que permite realizar verificaciones autom√°ticas (como linting y pruebas) y abortar el commit si alguna falla.
üß† Pregunta 40
¬øQu√© tipo de verificaciones se ejemplifican en el script del hook pre-commit proporcionado en el texto?

A. Verificaci√≥n de la firma digital del commit y an√°lisis de la complejidad ciclom√°tica del c√≥digo.
B. Ejecuci√≥n de linting (con `make lint`) y pruebas unitarias r√°pidas (con `make test`).
C. Generaci√≥n autom√°tica de mensajes de commit y actualizaci√≥n del changelog.
D. Creaci√≥n de una rama de desarrollo basada en los cambios del commit y despliegue a un entorno de pruebas.

‚úÖ Correcta: B
üßæ Explicaci√≥n: El script de ejemplo para el hook `pre-commit` invoca los targets `make lint` para realizar un an√°lisis de estilo y posibles errores en el c√≥digo, y `make test ACTIVITY=pruebas_pytest` para ejecutar un subconjunto de pruebas unitarias r√°pidas, asegurando un nivel b√°sico de calidad antes de permitir el commit.
üß† Pregunta 41
En el contexto de BDD, ¬øqu√© rol cumplen las "step definitions" (definiciones de pasos) en steps/steps.py?

A. Describen los escenarios de comportamiento en lenguaje natural.
B. Contienen el c√≥digo Python que implementa la l√≥gica de cada paso definido en los archivos `.feature`.
C. Definen la estructura y la sintaxis de los archivos `.feature`.
D. Generan autom√°ticamente los archivos `.feature` a partir del c√≥digo Python.

‚úÖ Correcta: B
üßæ Explicaci√≥n: Los archivos `steps/steps.py` contienen las funciones de Python que se ejecutan cuando `behave` encuentra un paso coincidente en un archivo `.feature`. Estas funciones contienen la l√≥gica de prueba espec√≠fica para cada paso.
üß† Pregunta 42
¬øQu√© significa la etiqueta @smoke utilizada en el ejemplo de ejecuci√≥n de behave (behave --tags=@smoke)?

A. Indica que los escenarios marcados con esta etiqueta deben ejecutarse en un entorno de alto rendimiento.
B. Selecciona y ejecuta solo los escenarios que han sido etiquetados con `@smoke`, t√≠picamente representando pruebas r√°pidas y esenciales para verificar la funcionalidad b√°sica.
C. Aplica un formato de salida espec√≠fico para los escenarios que fallan.
D. Define un conjunto de variables de entorno que se aplicar√°n solo a estos escenarios.

‚úÖ Correcta: B
üßæ Explicaci√≥n: Las etiquetas (`@`) en Gherkin permiten organizar y seleccionar escenarios espec√≠ficos para su ejecuci√≥n. `@smoke` es una convenci√≥n com√∫n para marcar pruebas de humo, que son un conjunto peque√±o de pruebas r√°pidas dise√±adas para verificar la funcionalidad m√°s cr√≠tica del sistema.
üß† Pregunta 43
¬øQu√© representan las "Four Test Patterns" en el contexto de las pruebas unitarias?

A. Cuatro tipos diferentes de errores comunes en el software.
B. Un modelo para estructurar cada prueba unitaria en cuatro fases: Setup, Exercise, Verify y Teardown.
C. Cuatro herramientas esenciales para realizar pruebas unitarias efectivas.
D. Cuatro niveles de granularidad en las pruebas: unitarias, de integraci√≥n, de sistema y de aceptaci√≥n.

‚úÖ Correcta: B
üßæ Explicaci√≥n: Las "Four Test Patterns" son un modelo conceptual para estructurar una prueba unitaria de manera clara y organizada, asegurando que cada prueba siga un flujo l√≥gico de preparaci√≥n, ejecuci√≥n de la acci√≥n a probar, verificaci√≥n del resultado esperado y limpieza del entorno si es necesario.
üß† Pregunta 44
En el flujo de trabajo TDD con Make, ¬øcu√°l es el objetivo de la fase "Red"?

A. Escribir el c√≥digo de producci√≥n que implementar√° la funcionalidad.
B. Refactorizar el c√≥digo existente para mejorar su calidad.
C. Ejecutar las pruebas reci√©n escritas (o existentes para una nueva funcionalidad) y verificar que fallan, confirmando que la prueba est√° configurada correctamente para detectar la ausencia de la funcionalidad.
D. Asegurarse de que todas las pruebas pasen despu√©s de implementar la funcionalidad.

‚úÖ Correcta: C
üßæ Explicaci√≥n: La fase "Red" del TDD se centra en escribir una prueba para una funcionalidad que a√∫n no existe y luego ejecutar esa prueba para confirmar que falla. Esto asegura que la prueba es v√°lida y que realmente probar√° el comportamiento esperado una vez que se implemente la funcionalidad.
üß† Pregunta 45
¬øQu√© se espera que haga el desarrollador en la fase "Green" del ciclo TDD descrito en el Makefile?

A. Escribir m√°s pruebas para cubrir diferentes casos de uso.
B. Refactorizar el c√≥digo de prueba para mejorar su legibilidad.
C. Implementar la funcionalidad m√≠nima necesaria para que las pruebas que fallaron en la fase "Red" pasen.
D. Documentar el c√≥digo reci√©n implementado.

‚úÖ Correcta: C
üßæ Explicaci√≥n: La fase "Green" del TDD consiste en escribir el c√≥digo de producci√≥n necesario para satisfacer los requisitos de las pruebas que fallaron en la fase "Red". El objetivo es hacer que las pruebas pasen lo m√°s r√°pido posible, sin preocuparse demasiado por la perfecci√≥n del c√≥digo en esta etapa.
üß† Pregunta 46
¬øCu√°l es el prop√≥sito de la fase "Refactor" en el ciclo TDD?

A. A√±adir nuevas funcionalidades al c√≥digo.
B. Optimizar el rendimiento del c√≥digo.
C. Mejorar la estructura, legibilidad y mantenibilidad del c√≥digo productivo sin alterar su comportamiento (es decir, sin romper las pruebas existentes).
D. Escribir la documentaci√≥n del c√≥digo.

‚úÖ Correcta: C
üßæ Explicaci√≥n: La fase "Refactor" se realiza despu√©s de que las pruebas pasan (fase "Green"). El objetivo es limpiar y mejorar el c√≥digo productivo, eliminando duplicaciones, mejorando la claridad y asegurando que el c√≥digo sea f√°cil de mantener a largo plazo, siempre verificando que las pruebas sigan pasando despu√©s de la refactorizaci√≥n.
üß† Pregunta 47
En el ejemplo de la clase TestDividir en pytest, ¬øqu√© prop√≥sito tiene el uso de with pytest.raises(ZeroDivisionError)?

A. Permite que la prueba pase solo si la funci√≥n `dividir` lanza una excepci√≥n de tipo `ZeroDivisionError` al intentar dividir por cero.
B. Captura la excepci√≥n `ZeroDivisionError` si ocurre y la ignora, haciendo que la prueba siempre pase.
C. Obliga a la funci√≥n `dividir` a lanzar una excepci√≥n de tipo `ZeroDivisionError` durante la prueba.
D. Muestra un mensaje de error espec√≠fico si no se lanza una excepci√≥n `ZeroDivisionError`.

‚úÖ Correcta: A
üßæ Explicaci√≥n: `with pytest.raises(ZeroDivisionError)` es una forma idiom√°tica en `pytest` de probar el comportamiento esperado de una funci√≥n cuando debe lanzar una excepci√≥n. La prueba pasar√° solo si la excepci√≥n del tipo especificado (en este caso, `ZeroDivisionError`) es efectivamente raised por el c√≥digo bajo prueba.
üß† Pregunta 48
¬øQu√© se busca lograr al integrar BDD y TDD en un flujo de trabajo de desarrollo?

A. Reducir la cantidad total de pruebas necesarias.
B. Asegurar que las pruebas de unidad est√©n escritas en lenguaje natural.
C. Cubrir la validaci√≥n de la calidad desde las pruebas de unidad (TDD) hasta las pruebas de aceptaci√≥n del negocio (BDD), asegurando que el software cumpla tanto con los requisitos t√©cnicos como con las necesidades del negocio.
D. Simplificar la configuraci√≥n del entorno de pruebas.

‚úÖ Correcta: C
üßæ Explicaci√≥n: La integraci√≥n de BDD y TDD proporciona una estrategia de pruebas completa. TDD asegura que el c√≥digo se desarrolle de manera probada y con una alta cobertura a nivel de unidad, mientras que BDD valida que el software cumple con los requisitos del negocio y las expectativas del usuario a trav√©s de escenarios descritos en lenguaje natural.
üß† Pregunta 49
¬øQu√© comando make se utiliza en el ejemplo para ejecutar la bater√≠a completa de verificaciones de calidad (linting, pruebas unitarias, pruebas BDD y cobertura)?

A. `make all`
B. `make check`
C. `make quality`
D. `make ci`

‚úÖ Correcta: D
üßæ Explicaci√≥n: El ejemplo define un target `ci` (Continuous Integration) que agrupa la ejecuci√≥n de `lint`, `test`, `bdd` y `coverage`, representando un conjunto completo de verificaciones de calidad que t√≠picamente se ejecutan en un pipeline de integraci√≥n continua.
üß† Pregunta 50
¬øCu√°l es el beneficio de incluir el timestamp y el commit hash en los reportes generados por el Makefile?

A. Reducir el tama√±o de los archivos de reporte.
B. Facilitar la identificaci√≥n precisa de la versi√≥n del c√≥digo y el momento en que se gener√≥ el reporte, lo que es √∫til para la trazabilidad y la depuraci√≥n.
C. Mejorar la legibilidad de los reportes para usuarios no t√©cnicos.
D. Asegurar que los reportes sean compatibles con diferentes herramientas de an√°lisis.

‚úÖ Correcta: B
üßæ Explicaci√≥n: Incluir el `timestamp` y el `commit hash` en los reportes proporciona un contexto crucial sobre cu√°ndo y desde qu√© versi√≥n espec√≠fica del c√≥digo se generaron los resultados. Esto es fundamental para la trazabilidad, la auditor√≠a y la reproducci√≥n de los resultados en el futuro.
