ğŸ§  Pregunta 1
Â¿CuÃ¡l es la principal ventaja de utilizar un Makefile en flujos DevOps, segÃºn el texto?

A. Simplifica la sintaxis de Python.
B. Ofrece un punto de entrada estandarizado y declarativo para la automatizaciÃ³n de tareas.
C. Reemplaza la necesidad de utilizar entornos virtuales.
D. Limita la capacidad de integrar diferentes herramientas de prueba.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El Makefile centraliza y documenta la ejecuciÃ³n de comandos complejos, promoviendo la reproducibilidad y eficiencia en los flujos de trabajo DevOps.

ğŸ§  Pregunta 2
SegÃºn el Makefile de ejemplo, Â¿para quÃ© se utiliza la variable ACTIVITIES?

A. Para definir la actividad de prueba por defecto.
B. Para especificar las dependencias del proyecto.
C. Para listar todos los directorios de actividades, facilitando bucles en objetivos como test_all y coverage_individual.
D. Para configurar las opciones de ejecuciÃ³n de flake8.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La variable ACTIVITIES proporciona una lista exhaustiva de las carpetas de actividades, lo que permite iterar sobre ellas para ejecutar pruebas o generar informes de cobertura de manera automatizada.

ğŸ§  Pregunta 3
Â¿QuÃ© funciÃ³n cumple el objetivo .PHONY en un Makefile?

A. Define variables de entorno globales.
B. Ejecuta comandos en segundo plano.
C. Evita conflictos con archivos que tengan el mismo nombre que los objetivos definidos.
D. Especifica las dependencias entre diferentes objetivos.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: .PHONY se utiliza para declarar que un objetivo no representa un archivo real, sino una acciÃ³n a ejecutar, previniendo errores si existiera un archivo con el mismo nombre.

ğŸ§  Pregunta 4
Â¿QuÃ© herramienta de anÃ¡lisis estÃ¡tico de cÃ³digo se menciona en el Makefile de ejemplo?

A. pytest
B. coverage
C. flake8
D. pip

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El objetivo lint del Makefile utiliza flake8 para verificar el estilo del cÃ³digo y detectar errores sintÃ¡cticos o variables no utilizadas.

ğŸ§  Pregunta 5
Â¿CuÃ¡l es el propÃ³sito del comando PYTHONWARNINGS="ignore::DeprecationWarning" pytest . dentro del objetivo test?

A. Ejecutar solo las pruebas marcadas con DeprecationWarning.
B. Mostrar todos los warnings de deprecaciÃ³n durante la ejecuciÃ³n de las pruebas.
C. Ignorar los warnings de deprecaciÃ³n para mantener una salida de prueba mÃ¡s limpia.
D. Detener la ejecuciÃ³n de las pruebas si se encuentra un DeprecationWarning.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La variable de entorno PYTHONWARNINGS se configura para ignorar los warnings de deprecaciÃ³n, evitando que estos contaminen la salida de los tests de pytest.

ğŸ§  Pregunta 6
En el contexto de la mediciÃ³n de cobertura de cÃ³digo con coverage, Â¿quÃ© hace el comando coverage html?

A. Ejecuta las pruebas bajo la herramienta de cobertura.
B. Muestra el porcentaje de cobertura en la terminal.
C. Genera un reporte visual de la cobertura en formato HTML.
D. Elimina los datos de cobertura recopilados previamente.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El comando coverage html procesa los datos de cobertura recopilados y genera un informe detallado en formato HTML, facilitando la visualizaciÃ³n de quÃ© partes del cÃ³digo estÃ¡n cubiertas por las pruebas.

ğŸ§  Pregunta 7
Â¿QuÃ© utilidad tienen las fixtures en pytest, segÃºn el texto?

A. Permiten definir el orden en que se ejecutan las pruebas.
B. Se utilizan para marcar pruebas como lentas o que deben omitirse.
C. Facilitan la comparticiÃ³n de datos de prueba, clientes simulados o conexiones falsas, reduciendo la duplicaciÃ³n de cÃ³digo de setup/teardown.
D. Generan automÃ¡ticamente documentaciÃ³n de las pruebas.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Las fixtures en pytest son funciones que se ejecutan antes de las funciones de prueba para proporcionarles los recursos necesarios, como datos o dependencias simuladas, mejorando la eficiencia y legibilidad de las pruebas.

ğŸ§  Pregunta 8
Â¿CuÃ¡l de las siguientes NO es una buena prÃ¡ctica DevOps relacionada con el uso de Make, mencionada en el texto?

A. Asegurar la idempotencia de los objetivos.
B. Utilizar variables para ajustar la verbosidad de la salida.
C. Depender exclusivamente de variables de entorno para informaciÃ³n sensible.
D. Integrar con herramientas de contenedizaciÃ³n como Docker.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El texto explÃ­citamente menciona que la informaciÃ³n sensible como contraseÃ±as o tokens no debe incluirse directamente en el Makefile, sino gestionarse de forma segura a travÃ©s de mecanismos como los secrets en entornos de CI/CD.

ğŸ§  Pregunta 9
Â¿QuÃ© se logra al integrar Git Hooks con un Makefile, como se describe en el texto?

A. Se automatiza la creaciÃ³n de ramas Git basadas en las actividades del Makefile.
B. Se ejecutan automÃ¡ticamente ciertos targets del Makefile (como lint y test) antes de operaciones Git crÃ­ticas como el commit.
C. Se sincronizan automÃ¡ticamente los objetivos del Makefile con los comandos de Git.
D. Se utilizan los hooks de Git para definir los targets del Makefile.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Los Git Hooks permiten automatizar la ejecuciÃ³n de scripts antes o despuÃ©s de eventos de Git. Al invocar targets del Makefile desde hooks como pre-commit, se pueden asegurar estÃ¡ndares de calidad y pruebas antes de cada commit.

ğŸ§  Pregunta 10
En el contexto de BDD con behave, Â¿quÃ© funciÃ³n cumplen las expresiones regulares en las definiciones de los pasos (steps.py)?

A. Definen el orden en que se ejecutan los escenarios.
B. Permiten que las funciones de Python (`step_impl`) capturen datos especÃ­ficos del texto en lenguaje natural de los escenarios Gherkin.
C. Se utilizan para generar automÃ¡ticamente la documentaciÃ³n de los escenarios.
D. Validan la estructura sintÃ¡ctica de los archivos `.feature`.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Las expresiones regulares en las definiciones de los pasos de `behave` permiten extraer informaciÃ³n relevante del texto de los escenarios Gherkin y pasarla como argumentos a las funciones de Python que implementan la lÃ³gica de esos pasos.

ğŸ§  Pregunta 11
Â¿CuÃ¡l es el propÃ³sito del objetivo install en el Makefile proporcionado?

A. Instalar el sistema operativo base necesario para ejecutar el proyecto.
B. Instalar las dependencias del proyecto listadas en el archivo requirements.txt.
C. Instalar la herramienta make si no estÃ¡ presente en el sistema.
D. Instalar un entorno virtual de Python para el proyecto.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El objetivo install utiliza pip para instalar todas las librerÃ­as y dependencias requeridas por el proyecto, las cuales estÃ¡n especificadas en el archivo requirements.txt.

ğŸ§  Pregunta 12
Â¿QuÃ© beneficio principal aporta la documentaciÃ³n integrada a travÃ©s del objetivo help en el Makefile?

A. Genera automÃ¡ticamente diagramas de flujo del proyecto.
B. Permite a cualquier miembro del equipo conocer rÃ¡pidamente las acciones disponibles y cÃ³mo ejecutarlas.
C. Realiza una revisiÃ³n gramatical de todos los comentarios en el Makefile.
D. Publica la documentaciÃ³n del proyecto en un sitio web.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El objetivo help proporciona una lista clara y concisa de los comandos disponibles en el Makefile, junto con una breve descripciÃ³n de su uso, lo que facilita la incorporaciÃ³n de nuevos miembros al equipo y la comprensiÃ³n de las tareas automatizadas.

ğŸ§  Pregunta 13
Â¿QuÃ© herramientas podrÃ­an complementarse con flake8 dentro del objetivo lint para un anÃ¡lisis de cÃ³digo mÃ¡s exhaustivo?

A. pytest y coverage.
B. black y mypy.
C. git y docker.
D. behave y selenium.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: black es un formateador de cÃ³digo que asegura la consistencia del estilo, mientras que mypy realiza un chequeo estÃ¡tico de tipos, lo que aÃ±ade una capa adicional de verificaciÃ³n de la calidad del cÃ³digo al anÃ¡lisis de flake8.

ğŸ§  Pregunta 14
Â¿QuÃ© diferencia fundamental existe entre los objetivos test y test_all en el Makefile?

A. test ejecuta pruebas solo en los archivos modificados recientemente, mientras que test_all ejecuta todas las pruebas.
B. test permite especificar una actividad o subdirectorio de pruebas, mientras que test_all ejecuta pruebas en todas las actividades definidas.
C. test genera un reporte de cobertura detallado, mientras que test_all solo indica si las pruebas pasaron o fallaron.
D. test requiere una configuraciÃ³n especÃ­fica del entorno, mientras que test_all se ejecuta en un entorno aislado.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El objetivo test estÃ¡ diseÃ±ado para ejecutar pruebas de manera granular en una actividad especÃ­fica, mientras que test_all itera sobre todas las actividades definidas en la variable ACTIVITIES y ejecuta las pruebas en cada una de ellas.

ğŸ§  Pregunta 15
Â¿CuÃ¡l es la funciÃ³n del comando cd - >/dev/null utilizado en el objetivo test_all?

A. Cambia al directorio raÃ­z del proyecto y oculta cualquier salida.
B. Regresa al directorio anterior despuÃ©s de ejecutar las pruebas en una actividad y suprime la salida de la ruta.
C. Crea un nuevo directorio llamado /dev/null y se mueve a Ã©l.
D. Elimina todos los archivos temporales generados durante la ejecuciÃ³n de las pruebas.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: cd - regresa al directorio previamente visitado, y >/dev/null redirige la salida estÃ¡ndar (en este caso, la ruta del directorio) a un "agujero negro", evitando que se muestre en la consola y manteniendo la salida mÃ¡s limpia.

ğŸ§  Pregunta 16
En el contexto de la cobertura de cÃ³digo, Â¿por quÃ© es Ãºtil tener un objetivo coverage_individual que genera reportes por actividad?

A. Permite fusionar los reportes de cobertura de diferentes actividades en un Ãºnico archivo.
B. Facilita la identificaciÃ³n de quÃ© Ã¡reas especÃ­ficas del cÃ³digo dentro de cada mÃ³dulo tienen una cobertura de pruebas deficiente.
C. Reduce el tiempo necesario para generar el reporte de cobertura total del proyecto.
D. Asegura que la cobertura de cÃ³digo se mida utilizando diferentes herramientas para cada actividad.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Generar reportes de cobertura individuales por actividad permite un anÃ¡lisis mÃ¡s detallado y especÃ­fico, facilitando que los equipos responsables de componentes particulares identifiquen y mejoren la cobertura de pruebas en su Ã¡rea de responsabilidad.

ğŸ§  Pregunta 17
Â¿QuÃ© acciones realiza el objetivo clean en el Makefile de ejemplo?

A. Elimina solo los archivos de cachÃ© de Python (__pycache__).
B. Elimina archivos de cachÃ© de Python, la cachÃ© de pytest, los reportes de cobertura y los datos de cobertura generados.
C. Revierte todos los cambios realizados en el cÃ³digo desde la Ãºltima confirmaciÃ³n.
D. Detiene todos los contenedores Docker asociados al proyecto.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El objetivo clean estÃ¡ diseÃ±ado para eliminar los artefactos generados durante el desarrollo y las pruebas, como las cachÃ©s de Python y pytest, asÃ­ como los reportes y datos de cobertura, proporcionando un estado limpio para futuras ejecuciones.

ğŸ§  Pregunta 18
Â¿CÃ³mo se puede especificar una actividad de prueba diferente a la predeterminada al ejecutar el objetivo test desde la lÃ­nea de comandos con make?

A. Utilizando la opciÃ³n -a seguida del nombre de la actividad (e.g., make test -a factories_fakes).
B. Estableciendo la variable de entorno ACTIVITY al invocar make (e.g., make test ACTIVITY=factories_fakes).
C. Modificando directamente el valor de la variable ACTIVITY en el Makefile antes de ejecutar el comando.
D. Utilizando un argumento posicional despuÃ©s del objetivo test (e.g., make test factories_fakes).

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La sintaxis ACTIVITY ?= aserciones_pruebas en el Makefile define un valor por defecto para la variable ACTIVITY, pero permite que este sea sobrescrito proporcionando un nuevo valor directamente en la lÃ­nea de comandos al ejecutar make.

ğŸ§  Pregunta 19
Â¿CuÃ¡l es el propÃ³sito principal de utilizar fixtures con el alcance de "session" (@pytest.fixture(scope="session")) en pytest?

A. Ejecutar la fixture antes y despuÃ©s de cada test individual dentro de una sesiÃ³n.
B. Ejecutar la fixture una sola vez al inicio y al final de toda la sesiÃ³n de pruebas, compartiendo los recursos creados entre todos los tests.
C. Ejecutar la fixture automÃ¡ticamente para todos los tests sin necesidad de declararla en cada funciÃ³n de prueba.
D. Limitar el tiempo de ejecuciÃ³n de los tests que utilizan esta fixture.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Las fixtures con alcance de "session" se ejecutan una Ãºnica vez durante toda la sesiÃ³n de pruebas, lo que es Ãºtil para configurar y liberar recursos costosos (como conexiones a bases de datos o inicializaciÃ³n de servicios) que pueden ser compartidos por mÃºltiples tests, optimizando el tiempo de ejecuciÃ³n.

ğŸ§  Pregunta 20
Â¿QuÃ© ventaja ofrece el uso de Git Hooks combinados con Make en un flujo de desarrollo?

A. Permite personalizar los comandos de Git utilizando la sintaxis de Makefile.
B. Automatiza la ejecuciÃ³n de tareas definidas en el Makefile (como linting y pruebas) en puntos clave del flujo de trabajo de Git, asegurando la calidad del cÃ³digo antes de acciones como el commit o el push.
C. Simplifica la gestiÃ³n de mÃºltiples ramas de Git directamente desde el Makefile.
D. Genera automÃ¡ticamente la documentaciÃ³n del repositorio Git en base a los targets del Makefile.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La integraciÃ³n de Git Hooks con Make permite automatizar la aplicaciÃ³n de polÃ­ticas de calidad y la ejecuciÃ³n de verificaciones importantes (como el estilo del cÃ³digo y las pruebas unitarias) justo en el momento en que los desarrolladores interactÃºan con Git, como antes de hacer un commit, asegurando una mayor consistencia y calidad en el cÃ³digo base.

ğŸ§  Pregunta 21
En el contexto de BDD, Â¿cuÃ¡l es la funciÃ³n principal de los archivos con extensiÃ³n .feature?

A. Contienen las definiciones de los pasos de prueba en cÃ³digo Python.
B. Describen el comportamiento esperado del sistema en lenguaje natural, utilizando la sintaxis de Gherkin.
C. Almacenan los resultados de la ejecuciÃ³n de los escenarios BDD.
D. Definen la configuraciÃ³n del entorno para la ejecuciÃ³n de las pruebas de comportamiento.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Los archivos `.feature` son la base de la especificaciÃ³n en BDD. Utilizan el lenguaje Gherkin para describir los escenarios de comportamiento desde la perspectiva del usuario o del negocio, facilitando la comprensiÃ³n y la colaboraciÃ³n entre los diferentes roles del equipo.
ğŸ§  Pregunta 22
Â¿QuÃ© representan las anotaciones @given, @when y @then en el contexto de behave?

A. Son directivas para definir el orden de ejecuciÃ³n de los escenarios.
B. Marcan funciones de Python que implementan las diferentes fases de un escenario BDD (preparaciÃ³n, acciÃ³n y resultado).
C. Se utilizan para definir variables de entorno especÃ­ficas para cada escenario.
D. Indican la prioridad de cada paso dentro de un escenario.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Estas anotaciones de `behave` se utilizan en los archivos de definiciÃ³n de pasos (`steps.py`) para vincular las lÃ­neas de los escenarios Gherkin con las funciones de Python que contienen la lÃ³gica de implementaciÃ³n para la fase de preparaciÃ³n (`@given`), la acciÃ³n (`@when`) y la verificaciÃ³n del resultado (`@then`).
ğŸ§  Pregunta 23
SegÃºn el texto, Â¿cuÃ¡l es el primer paso del ciclo TDD (Redâ†’Greenâ†’Refactor) que se busca automatizar con el Makefile?

A. La implementaciÃ³n de la funcionalidad necesaria para pasar las pruebas.
B. La refactorizaciÃ³n del cÃ³digo para mejorar su estructura y legibilidad.
C. La ejecuciÃ³n de las pruebas existentes, que se espera que fallen inicialmente.
D. La escritura de nuevas pruebas basadas en los requisitos.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El objetivo `tdd` en el `Makefile` primero ejecuta las pruebas existentes con la expectativa de que fallen (`--maxfail=1 && exit 1 || true`), lo que corresponde a la fase "Red" del ciclo TDD, donde se verifica que las pruebas fallan antes de implementar la funcionalidad.
ğŸ§  Pregunta 24
En el ejemplo de la clase TestDividir con pytest, Â¿para quÃ© se utiliza la fixture setup_teardown con yield?

A. Para definir el orden en que se ejecutan los mÃ©todos de prueba dentro de la clase.
B. Para realizar acciones de configuraciÃ³n antes de cada prueba y, opcionalmente, acciones de limpieza despuÃ©s.
C. Para marcar la clase de prueba como dependiente de otras clases de prueba.
D. Para parametrizar los datos de entrada de las pruebas de divisiÃ³n.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La estructura con `yield` en una fixture de `pytest` permite definir una parte que se ejecuta antes de cada test (la configuraciÃ³n) y una parte opcional que se ejecuta despuÃ©s de cada test (la limpieza o teardown), siguiendo el patrÃ³n Setup/Teardown de las pruebas.
ğŸ§  Pregunta 25
Â¿QuÃ© comando make se podrÃ­a utilizar para ejecutar tanto las pruebas unitarias como los escenarios BDD y generar un reporte de cobertura, segÃºn el ejemplo de integraciÃ³n hÃ­brida?

A. `make test && make bdd && make coverage`
B. `make all`
C. `make ci`
D. `make test_bdd_coverage`

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El ejemplo define un objetivo `ci` que agrupa la ejecuciÃ³n de `lint`, `test`, `bdd` y `coverage`, permitiendo una validaciÃ³n completa de la calidad del cÃ³digo con un solo comando `make ci`.
ğŸ§  Pregunta 26
Â¿CuÃ¡l es una consideraciÃ³n de seguridad importante al utilizar Makefiles en entornos DevOps, segÃºn el texto?

A. Asegurarse de que todos los desarrolladores tengan los mismos permisos para ejecutar los comandos de `make`.
B. Evitar incluir informaciÃ³n sensible como contraseÃ±as o tokens directamente en el `Makefile`, utilizando mecanismos seguros proporcionados por el entorno de CI/CD.
C. Cifrar el archivo `Makefile` para proteger su contenido.
D. Limitar el uso de variables de entorno en el `Makefile` para reducir riesgos de seguridad.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El texto enfatiza la importancia de no incluir informaciÃ³n sensible directamente en el `Makefile` debido al riesgo de exposiciÃ³n. En su lugar, se recomienda utilizar mecanismos seguros como los `secrets` proporcionados por las plataformas de integraciÃ³n continua.
ğŸ§  Pregunta 27
Â¿QuÃ© utilidad tiene el etiquetado (tagging) de versiones desde el Makefile (objetivo release)?

A. Automatiza la publicaciÃ³n del cÃ³digo en un registro de paquetes.
B. Facilita la creaciÃ³n de puntos de referencia inmutables en la historia del repositorio Git, identificando versiones especÃ­ficas del software.
C. Despliega automÃ¡ticamente la nueva versiÃ³n de la aplicaciÃ³n a producciÃ³n.
D. Genera automÃ¡ticamente la documentaciÃ³n de la nueva versiÃ³n.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El etiquetado en Git permite marcar puntos especÃ­ficos en la historia del repositorio con nombres significativos (generalmente nÃºmeros de versiÃ³n), lo que facilita el seguimiento de las diferentes versiones del software y la posibilidad de volver a un estado anterior si es necesario. El objetivo `release` en el `Makefile` automatiza este proceso.
ğŸ§  Pregunta 28
Â¿QuÃ© implica el concepto de "Build reproducible" mencionado en el texto en relaciÃ³n con el Makefile?

A. Que la construcciÃ³n del software debe ser rÃ¡pida y eficiente.
B. Que cualquier intento de construir el software desde el mismo punto de partida (cÃ³digo fuente y entorno) debe producir el mismo resultado.
C. Que el proceso de construcciÃ³n debe generar automÃ¡ticamente la documentaciÃ³n del software.
D. Que los builds deben realizarse en contenedores Docker para asegurar la consistencia del entorno.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Un "Build reproducible" significa que, dado el mismo cÃ³digo fuente y las mismas condiciones de entorno, el proceso de construcciÃ³n siempre generarÃ¡ el mismo artefacto. Incluir informaciÃ³n como el `timestamp` y el `commit hash` en los reportes ayuda a la trazabilidad y a asegurar esta reproducibilidad.
ğŸ§  Pregunta 29
Â¿CÃ³mo se integra un Makefile en un pipeline de GitHub Actions, segÃºn el ejemplo proporcionado?

A. Se define un target especial en el `Makefile` llamado `github-actions`.
B. Se crea un archivo YAML (`.github/workflows/ci.yml`) donde se definen los pasos del workflow, invocando comandos `make` para ejecutar tareas como instalaciÃ³n de dependencias, linting y pruebas.
C. GitHub Actions analiza automÃ¡ticamente el `Makefile` y ejecuta todos los targets definidos.
D. Se utiliza una acciÃ³n predefinida de GitHub Actions que interpreta y ejecuta el `Makefile`.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La integraciÃ³n se realiza a travÃ©s de un archivo de workflow en GitHub Actions (`.github/workflows/ci.yml`), donde se definen los diferentes jobs y steps. En los steps relevantes, se utiliza el comando `run: make <objetivo>` para invocar los targets definidos en el `Makefile`, orquestando asÃ­ las tareas de construcciÃ³n, prueba y anÃ¡lisis dentro del pipeline de CI/CD.

ğŸ§  Pregunta 30
Â¿CuÃ¡l es el beneficio principal de utilizar expresiones regulares con nombres (?P<nombre>) en las definiciones de los pasos de behave?

A. Mejoran el rendimiento de la ejecuciÃ³n de los escenarios BDD.
B. Facilitan la captura y el acceso a los valores coincidentes del texto del escenario dentro de la funciÃ³n de Python del paso, utilizando el nombre definido.
C. Permiten definir mÃºltiples patrones para un mismo paso.
D. Se utilizan para validar el formato de los datos de entrada en los escenarios.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Las expresiones regulares con nombres permiten extraer partes especÃ­ficas del texto de un paso en un escenario Gherkin y asignarlas a variables con nombres descriptivos dentro de la funciÃ³n de Python que implementa ese paso, lo que mejora la legibilidad y el manejo de los datos de prueba.

ğŸ§  Pregunta 31
Â¿QuÃ© se entiende por "idempotencia" en el contexto de los targets de un Makefile para DevOps?

A. Que un target solo puede ejecutarse una vez durante la vida del proyecto.
B. Que la ejecuciÃ³n repetida de un target produce el mismo resultado y no tiene efectos secundarios no deseados.
C. Que los targets deben ejecutarse en un orden especÃ­fico para evitar errores.
D. Que cada target debe tener una Ãºnica dependencia.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La idempotencia es crucial en la automatizaciÃ³n, especialmente en entornos de CI/CD. Un target idempotente puede ejecutarse varias veces sin alterar el estado del sistema de manera inesperada, asegurando la consistencia y la fiabilidad.
ğŸ§  Pregunta 32
Â¿CÃ³mo se podrÃ­a alternar entre una salida silenciosa y una salida detallada al ejecutar comandos make, segÃºn las buenas prÃ¡cticas mencionadas?

A. Utilizando diferentes objetivos como `test_verbose` y `test_silent`.
B. Definiendo una variable en el `Makefile` (e.g., `VERBOSE`) y utilizÃ¡ndola en los comandos con condicionales o pasando su valor a las herramientas de lÃ­nea de comandos.
C. Modificando la configuraciÃ³n global de `make` en el sistema.
D. Utilizando flags especÃ­ficos de `make` al invocar los comandos desde la terminal.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El uso de variables como `VERBOSE` permite controlar el nivel de detalle de la salida de los comandos. Se pueden usar condicionales dentro del `Makefile` o pasar el valor de la variable a las herramientas subyacentes para ajustar la verbosidad.
ğŸ§  Pregunta 33
Â¿QuÃ© ventaja ofrece la ejecuciÃ³n paralela de targets independientes en make (e.g., con make -j)?

A. Reduce la complejidad del `Makefile`.
B. Acelera el tiempo total de ejecuciÃ³n al realizar mÃºltiples tareas simultÃ¡neamente.
C. Asegura que los targets se ejecuten en un orden especÃ­fico.
D. Permite una mejor gestiÃ³n de las dependencias entre targets.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La opciÃ³n `-j` de `make` permite ejecutar mÃºltiples targets en paralelo, siempre que sus dependencias lo permitan. Esto puede reducir significativamente el tiempo total necesario para completar todas las tareas, especialmente en proyectos con muchas pruebas o anÃ¡lisis independientes.
ğŸ§  Pregunta 34
Â¿Por quÃ© es recomendable integrar el Makefile con entornos virtuales de Python (como venv) o contenedores Docker?

A. Para reducir el tamaÃ±o del repositorio del proyecto.
B. Para asegurar un entorno de ejecuciÃ³n aislado y consistente, evitando problemas de dependencias entre diferentes proyectos o el sistema base.
C. Para mejorar la seguridad del cÃ³digo fuente.
D. Para facilitar la ediciÃ³n del `Makefile` en diferentes sistemas operativos.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Los entornos virtuales y los contenedores proporcionan aislamiento, asegurando que el proyecto se ejecute con las dependencias y la configuraciÃ³n correctas, independientemente del entorno local del desarrollador o del servidor de CI/CD. Esto evita errores relacionados con versiones de librerÃ­as o configuraciones del sistema.
ğŸ§  Pregunta 35
Â¿QuÃ© funciÃ³n cumple el comando set -e en scripts shell invocados desde un Makefile?

A. Establece variables de entorno para el script.
B. Ejecuta el script en modo de depuraciÃ³n.
C. Hace que el script se detenga inmediatamente si cualquier comando dentro del script falla (devuelve un cÃ³digo de salida diferente de cero).
D. Redirige la salida de error del script a un archivo especÃ­fico.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: `set -e` es una prÃ¡ctica importante para el control de errores en scripts. Al activarlo, el script se detendrÃ¡ en el primer comando que falle, lo que ayuda a detectar y solucionar problemas de manera mÃ¡s temprana en los procesos automatizados.
ğŸ§  Pregunta 36
Â¿QuÃ© tipo de informaciÃ³n se recomienda exponer como variables parametrizables en un Makefile?

A. ContraseÃ±as y tokens de acceso.
B. Nombres de archivos fuente sensibles.
C. Rutas de directorios, versiones de lenguajes de programaciÃ³n y ubicaciones de artefactos generados.
D. La estructura interna del cÃ³digo fuente.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Exponer rutas, versiones de herramientas y directorios de salida como variables facilita la configuraciÃ³n y adaptaciÃ³n del `Makefile` a diferentes entornos o necesidades sin tener que modificar la lÃ³gica de los targets.
ğŸ§  Pregunta 37
Â¿QuÃ© herramienta se menciona para auditar las dependencias de Python en busca de vulnerabilidades de seguridad?

A. `flake8`
B. `mypy`
C. `pip-audit` o `safety`
D. `coverage`

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: `pip-audit` y `safety` son herramientas diseÃ±adas especÃ­ficamente para analizar las dependencias de un proyecto de Python y detectar vulnerabilidades de seguridad conocidas, lo cual es crucial en las consideraciones de seguridad en DevOps.
ğŸ§  Pregunta 38
Â¿QuÃ© tipo de vulnerabilidades podrÃ­a ayudar a detectar la integraciÃ³n de objetivos como make scan que ejecutan OWASP Dependency-Check o Bandit?

A. Errores de sintaxis en el cÃ³digo Python.
B. Problemas de estilo de cÃ³digo que no cumplen con PEP 8.
C. Vulnerabilidades en las dependencias del proyecto (OWASP Dependency-Check) y problemas de seguridad en el cÃ³digo fuente (Bandit).
D. Errores de tipo en el cÃ³digo Python.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: OWASP Dependency-Check se centra en identificar vulnerabilidades conocidas en las dependencias del proyecto, mientras que Bandit es una herramienta que analiza el cÃ³digo fuente en busca de problemas de seguridad comunes. Integrar ambos en un `make scan` proporciona una capa robusta de anÃ¡lisis de seguridad.
ğŸ§  Pregunta 39
Â¿CuÃ¡l es el propÃ³sito de copiar un script en .git/hooks/pre-commit y darle permisos de ejecuciÃ³n (chmod +x)?

A. Definir alias personalizados para los comandos de Git.
B. Automatizar la ejecuciÃ³n de ese script cada vez que se intenta realizar un commit en Git.
C. Crear un acceso directo ejecutable a un script que se encuentra en otro directorio.
D. Modificar el comportamiento predeterminado del comando `git commit`.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Los scripts colocados en el directorio `.git/hooks` y marcados como ejecutables se activan automÃ¡ticamente en puntos especÃ­ficos del flujo de trabajo de Git. El hook `pre-commit` se ejecuta justo antes de que se realice un commit, lo que permite realizar verificaciones automÃ¡ticas (como linting y pruebas) y abortar el commit si alguna falla.
ğŸ§  Pregunta 40
Â¿QuÃ© tipo de verificaciones se ejemplifican en el script del hook pre-commit proporcionado en el texto?

A. VerificaciÃ³n de la firma digital del commit y anÃ¡lisis de la complejidad ciclomÃ¡tica del cÃ³digo.
B. EjecuciÃ³n de linting (con `make lint`) y pruebas unitarias rÃ¡pidas (con `make test`).
C. GeneraciÃ³n automÃ¡tica de mensajes de commit y actualizaciÃ³n del changelog.
D. CreaciÃ³n de una rama de desarrollo basada en los cambios del commit y despliegue a un entorno de pruebas.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El script de ejemplo para el hook `pre-commit` invoca los targets `make lint` para realizar un anÃ¡lisis de estilo y posibles errores en el cÃ³digo, y `make test ACTIVITY=pruebas_pytest` para ejecutar un subconjunto de pruebas unitarias rÃ¡pidas, asegurando un nivel bÃ¡sico de calidad antes de permitir el commit.
ğŸ§  Pregunta 41
En el contexto de BDD, Â¿quÃ© rol cumplen las "step definitions" (definiciones de pasos) en steps/steps.py?

A. Describen los escenarios de comportamiento en lenguaje natural.
B. Contienen el cÃ³digo Python que implementa la lÃ³gica de cada paso definido en los archivos `.feature`.
C. Definen la estructura y la sintaxis de los archivos `.feature`.
D. Generan automÃ¡ticamente los archivos `.feature` a partir del cÃ³digo Python.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Los archivos `steps/steps.py` contienen las funciones de Python que se ejecutan cuando `behave` encuentra un paso coincidente en un archivo `.feature`. Estas funciones contienen la lÃ³gica de prueba especÃ­fica para cada paso.
ğŸ§  Pregunta 42
Â¿QuÃ© significa la etiqueta @smoke utilizada en el ejemplo de ejecuciÃ³n de behave (behave --tags=@smoke)?

A. Indica que los escenarios marcados con esta etiqueta deben ejecutarse en un entorno de alto rendimiento.
B. Selecciona y ejecuta solo los escenarios que han sido etiquetados con `@smoke`, tÃ­picamente representando pruebas rÃ¡pidas y esenciales para verificar la funcionalidad bÃ¡sica.
C. Aplica un formato de salida especÃ­fico para los escenarios que fallan.
D. Define un conjunto de variables de entorno que se aplicarÃ¡n solo a estos escenarios.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Las etiquetas (`@`) en Gherkin permiten organizar y seleccionar escenarios especÃ­ficos para su ejecuciÃ³n. `@smoke` es una convenciÃ³n comÃºn para marcar pruebas de humo, que son un conjunto pequeÃ±o de pruebas rÃ¡pidas diseÃ±adas para verificar la funcionalidad mÃ¡s crÃ­tica del sistema.
ğŸ§  Pregunta 43
Â¿QuÃ© representan las "Four Test Patterns" en el contexto de las pruebas unitarias?

A. Cuatro tipos diferentes de errores comunes en el software.
B. Un modelo para estructurar cada prueba unitaria en cuatro fases: Setup, Exercise, Verify y Teardown.
C. Cuatro herramientas esenciales para realizar pruebas unitarias efectivas.
D. Cuatro niveles de granularidad en las pruebas: unitarias, de integraciÃ³n, de sistema y de aceptaciÃ³n.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Las "Four Test Patterns" son un modelo conceptual para estructurar una prueba unitaria de manera clara y organizada, asegurando que cada prueba siga un flujo lÃ³gico de preparaciÃ³n, ejecuciÃ³n de la acciÃ³n a probar, verificaciÃ³n del resultado esperado y limpieza del entorno si es necesario.
ğŸ§  Pregunta 44
En el flujo de trabajo TDD con Make, Â¿cuÃ¡l es el objetivo de la fase "Red"?

A. Escribir el cÃ³digo de producciÃ³n que implementarÃ¡ la funcionalidad.
B. Refactorizar el cÃ³digo existente para mejorar su calidad.
C. Ejecutar las pruebas reciÃ©n escritas (o existentes para una nueva funcionalidad) y verificar que fallan, confirmando que la prueba estÃ¡ configurada correctamente para detectar la ausencia de la funcionalidad.
D. Asegurarse de que todas las pruebas pasen despuÃ©s de implementar la funcionalidad.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La fase "Red" del TDD se centra en escribir una prueba para una funcionalidad que aÃºn no existe y luego ejecutar esa prueba para confirmar que falla. Esto asegura que la prueba es vÃ¡lida y que realmente probarÃ¡ el comportamiento esperado una vez que se implemente la funcionalidad.
ğŸ§  Pregunta 45
Â¿QuÃ© se espera que haga el desarrollador en la fase "Green" del ciclo TDD descrito en el Makefile?

A. Escribir mÃ¡s pruebas para cubrir diferentes casos de uso.
B. Refactorizar el cÃ³digo de prueba para mejorar su legibilidad.
C. Implementar la funcionalidad mÃ­nima necesaria para que las pruebas que fallaron en la fase "Red" pasen.
D. Documentar el cÃ³digo reciÃ©n implementado.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La fase "Green" del TDD consiste en escribir el cÃ³digo de producciÃ³n necesario para satisfacer los requisitos de las pruebas que fallaron en la fase "Red". El objetivo es hacer que las pruebas pasen lo mÃ¡s rÃ¡pido posible, sin preocuparse demasiado por la perfecciÃ³n del cÃ³digo en esta etapa.
ğŸ§  Pregunta 46
Â¿CuÃ¡l es el propÃ³sito de la fase "Refactor" en el ciclo TDD?

A. AÃ±adir nuevas funcionalidades al cÃ³digo.
B. Optimizar el rendimiento del cÃ³digo.
C. Mejorar la estructura, legibilidad y mantenibilidad del cÃ³digo productivo sin alterar su comportamiento (es decir, sin romper las pruebas existentes).
D. Escribir la documentaciÃ³n del cÃ³digo.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La fase "Refactor" se realiza despuÃ©s de que las pruebas pasan (fase "Green"). El objetivo es limpiar y mejorar el cÃ³digo productivo, eliminando duplicaciones, mejorando la claridad y asegurando que el cÃ³digo sea fÃ¡cil de mantener a largo plazo, siempre verificando que las pruebas sigan pasando despuÃ©s de la refactorizaciÃ³n.
ğŸ§  Pregunta 47
En el ejemplo de la clase TestDividir en pytest, Â¿quÃ© propÃ³sito tiene el uso de with pytest.raises(ZeroDivisionError)?

A. Permite que la prueba pase solo si la funciÃ³n `dividir` lanza una excepciÃ³n de tipo `ZeroDivisionError` al intentar dividir por cero.
B. Captura la excepciÃ³n `ZeroDivisionError` si ocurre y la ignora, haciendo que la prueba siempre pase.
C. Obliga a la funciÃ³n `dividir` a lanzar una excepciÃ³n de tipo `ZeroDivisionError` durante la prueba.
D. Muestra un mensaje de error especÃ­fico si no se lanza una excepciÃ³n `ZeroDivisionError`.

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: `with pytest.raises(ZeroDivisionError)` es una forma idiomÃ¡tica en `pytest` de probar el comportamiento esperado de una funciÃ³n cuando debe lanzar una excepciÃ³n. La prueba pasarÃ¡ solo si la excepciÃ³n del tipo especificado (en este caso, `ZeroDivisionError`) es efectivamente raised por el cÃ³digo bajo prueba.
ğŸ§  Pregunta 48
Â¿QuÃ© se busca lograr al integrar BDD y TDD en un flujo de trabajo de desarrollo?

A. Reducir la cantidad total de pruebas necesarias.
B. Asegurar que las pruebas de unidad estÃ©n escritas en lenguaje natural.
C. Cubrir la validaciÃ³n de la calidad desde las pruebas de unidad (TDD) hasta las pruebas de aceptaciÃ³n del negocio (BDD), asegurando que el software cumpla tanto con los requisitos tÃ©cnicos como con las necesidades del negocio.
D. Simplificar la configuraciÃ³n del entorno de pruebas.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La integraciÃ³n de BDD y TDD proporciona una estrategia de pruebas completa. TDD asegura que el cÃ³digo se desarrolle de manera probada y con una alta cobertura a nivel de unidad, mientras que BDD valida que el software cumple con los requisitos del negocio y las expectativas del usuario a travÃ©s de escenarios descritos en lenguaje natural.
ğŸ§  Pregunta 49
Â¿QuÃ© comando make se utiliza en el ejemplo para ejecutar la baterÃ­a completa de verificaciones de calidad (linting, pruebas unitarias, pruebas BDD y cobertura)?

A. `make all`
B. `make check`
C. `make quality`
D. `make ci`

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: El ejemplo define un target `ci` (Continuous Integration) que agrupa la ejecuciÃ³n de `lint`, `test`, `bdd` y `coverage`, representando un conjunto completo de verificaciones de calidad que tÃ­picamente se ejecutan en un pipeline de integraciÃ³n continua.
ğŸ§  Pregunta 50
Â¿CuÃ¡l es el beneficio de incluir el timestamp y el commit hash en los reportes generados por el Makefile?

A. Reducir el tamaÃ±o de los archivos de reporte.
B. Facilitar la identificaciÃ³n precisa de la versiÃ³n del cÃ³digo y el momento en que se generÃ³ el reporte, lo que es Ãºtil para la trazabilidad y la depuraciÃ³n.
C. Mejorar la legibilidad de los reportes para usuarios no tÃ©cnicos.
D. Asegurar que los reportes sean compatibles con diferentes herramientas de anÃ¡lisis.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Incluir el `timestamp` y el `commit hash` en los reportes proporciona un contexto crucial sobre cuÃ¡ndo y desde quÃ© versiÃ³n especÃ­fica del cÃ³digo se generaron los resultados. Esto es fundamental para la trazabilidad, la auditorÃ­a y la reproducciÃ³n de los resultados en el futuro.
