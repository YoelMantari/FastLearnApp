ğŸ§  Pregunta 1
Â¿CuÃ¡l es el objetivo principal de la automatizaciÃ³n de testing en un entorno DevOps con metodologÃ­as Ã¡giles y microservicios?

A. Reducir la cantidad de cÃ³digo escrito por los desarrolladores.
B. Validar la calidad del software de forma sistemÃ¡tica a lo largo del ciclo de vida del desarrollo.
C. Eliminar por completo la necesidad de pruebas manuales.
D. Acelerar la publicaciÃ³n de nuevas funcionalidades sin considerar la calidad.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La automatizaciÃ³n de testing en DevOps busca asegurar la calidad del software de manera continua e integrada en el proceso de desarrollo.
ğŸ§  Pregunta 2
Â¿QuÃ© tipo de pruebas se encargan de verificar el comportamiento de funciones y mÃ³dulos de manera aislada?

A. Pruebas de aceptaciÃ³n.
B. Pruebas end-to-end.
C. Pruebas de integraciÃ³n.
D. Pruebas unitarias.

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: Las pruebas unitarias se enfocan en la validaciÃ³n individual de los componentes mÃ¡s pequeÃ±os del software.
ğŸ§  Pregunta 3
Â¿QuÃ© principio SOLID se relaciona con la idea de que un test debe responder a una sola pregunta, evitando mÃºltiples aserciones y lÃ³gica compleja?

A. Principio de InversiÃ³n de Dependencias (DIP).
B. Principio de Responsabilidad Ãšnica (SRP).
C. Principio de Abierto/Cerrado (OCP).
D. Principio de SustituciÃ³n de Liskov (LSP).

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El Principio de Responsabilidad Ãšnica (SRP) aplicado a las pruebas implica que cada test debe tener un Ãºnico motivo para fallar.
ğŸ§  Pregunta 4
Â¿CÃ³mo ayuda la parametrizaciÃ³n en el testing, como la ofrecida por pytest, a cumplir con el Principio Abierto/Cerrado (OCP)?

A. Permite modificar la lÃ³gica de las pruebas directamente para cubrir nuevos casos.
B. Facilita la adiciÃ³n de nuevos casos de prueba mediante la inclusiÃ³n de mÃ¡s datos sin alterar el cÃ³digo del test.
C. Asegura que todos los tests se ejecuten con la misma configuraciÃ³n.
D. Reduce la necesidad de escribir pruebas para diferentes escenarios.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La parametrizaciÃ³n permite extender la cobertura de las pruebas aÃ±adiendo nuevos datos de entrada y resultados esperados sin necesidad de modificar la estructura del test.
ğŸ§  Pregunta 5
Â¿QuÃ© utilidad tiene create_autospec al aplicar el Principio de SustituciÃ³n de Liskov (LSP) en el testing?

A. Permite crear mocks con comportamientos predefinidos complejos.
B. Asegura que los dobles de prueba (mocks) respeten la interfaz exacta del componente real.
C. Facilita la inyecciÃ³n de dependencias sin necesidad de definir interfaces.
D. Acelera la creaciÃ³n de mocks al inferir automÃ¡ticamente sus mÃ©todos.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: `create_autospec` fuerza que los mocks implementen la misma firma que la clase real, garantizando la sustituibilidad segÃºn el Principio de SustituciÃ³n de Liskov.
ğŸ§  Pregunta 6
Â¿QuÃ© ventaja ofrece el uso de fixtures pequeÃ±as y composables en el testing, en relaciÃ³n con el Principio de SegregaciÃ³n de la Interfaz (ISP)?

A. Reduce la cantidad total de fixtures necesarias en un proyecto.
B. Permite que los tests dependan solo de las funcionalidades que realmente necesitan, evitando dependencias innecesarias.
C. Asegura que todas las configuraciones necesarias estÃ©n disponibles en una Ãºnica fixture.
D. Facilita la reutilizaciÃ³n de configuraciones complejas entre diferentes tests.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Al crear fixtures con interfaces especÃ­ficas, los tests solo dependen de lo que usan, disminuyendo el acoplamiento y cumpliendo con el Principio de SegregaciÃ³n de la Interfaz.
ğŸ§  Pregunta 7
Â¿CuÃ¡l es el objetivo principal del Principio de InversiÃ³n de Dependencias (DIP) en el contexto del testing?

A. Asegurar que las dependencias concretas se creen directamente dentro de las clases que las utilizan.
B. Trasladar la responsabilidad de conocer las implementaciones concretas a un punto de ensamblaje externo, permitiendo la inyecciÃ³n de fakes o stubs en los tests.
C. Evitar el uso de abstracciones y depender directamente de las implementaciones concretas para mayor eficiencia.
D. Reducir la complejidad del cÃ³digo de producciÃ³n al eliminar las interfaces.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: DIP promueve que las dependencias se inyecten externamente, lo que facilita el uso de implementaciones de prueba (fakes, stubs) en lugar de las reales.
ğŸ§  Pregunta 8
Â¿CÃ³mo contribuyen las fixtures de pytest a la aplicaciÃ³n del Principio de InversiÃ³n de Dependencias (DIP)?

A. Definen la lÃ³gica de negocio directamente dentro de las funciones de prueba.
B. ActÃºan como abstracciones que proporcionan las dependencias necesarias a los tests sin que estos conozcan los detalles de su creaciÃ³n o configuraciÃ³n.
C. Aseguran que todas las dependencias se inicialicen al comienzo de cada sesiÃ³n de prueba.
D. Permiten acceder directamente a las variables de entorno y configuraciones del sistema.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Las fixtures permiten que los tests declaren sus necesidades (las dependencias) sin especificar cÃ³mo se obtienen, lo cual es un aspecto clave de la InversiÃ³n de Dependencias.
ğŸ§  Pregunta 9
Â¿QuÃ© caracteriza a las fixtures "Constructor-like" en pytest y cÃ³mo se utilizan en entornos DevOps?

A. Proporcionan funciones para parchear dinÃ¡micamente el comportamiento de las dependencias.
B. ActÃºan como fÃ¡bricas preconfiguradas que devuelven instancias listas para usar de componentes complejos, como clientes HTTP o conexiones a bases de datos.
C. Implementan solo los mÃ©todos exigidos por la capa de dominio, siendo ligeras y aisladas.
D. Permiten definir el orden en que se ejecutan los tests dentro de una clase o mÃ³dulo.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Las fixtures "Constructor-like" centralizan la creaciÃ³n y configuraciÃ³n de objetos complejos, facilitando la adaptaciÃ³n a diferentes entornos DevOps (local, CI, staging) mediante la configuraciÃ³n.
ğŸ§  Pregunta 10
Â¿CuÃ¡l es la funciÃ³n principal de las fixtures "Setter-like" en pytest y en quÃ© escenarios de testing son particularmente Ãºtiles?

A. Devolver instancias preconfiguradas de dependencias para su uso directo en los tests.
B. Exponer funciones u objetos para modificar dinÃ¡micamente el comportamiento de dependencias o el cÃ³digo bajo prueba, siendo Ãºtiles para simular fallos o escenarios de borde.
C. Proporcionar implementaciones ligeras de interfaces para aislar los tests de dependencias externas.
D. Definir el ciclo de vida de los recursos compartidos entre mÃºltiples tests.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Las fixtures "Setter-like" ofrecen la flexibilidad de alterar comportamientos durante la ejecuciÃ³n de un test, lo que es crucial para probar la robustez ante diferentes condiciones.
ğŸ§  Pregunta 11
Â¿QuÃ© ventaja ofrecen las fixtures "Interface-driven" en tÃ©rminos de velocidad y aislamiento en las pruebas?

A. Permiten interactuar con servicios externos reales para pruebas de integraciÃ³n mÃ¡s completas.
B. Cargan todas las librerÃ­as y dependencias necesarias al inicio de la sesiÃ³n de pruebas para un acceso rÃ¡pido.
C. Proporcionan implementaciones mÃ­nimas (fakes o stubs) que satisfacen solo la interfaz pÃºblica esperada, evitando la carga de librerÃ­as pesadas y la necesidad de conexiones externas.
D. Aseguran que las pruebas se ejecuten en un orden especÃ­fico para mantener la coherencia del estado.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Al ser implementaciones ligeras y enfocadas en la interfaz, las fixtures "Interface-driven" minimizan el consumo de recursos y aÃ­slan los tests de dependencias complejas, acelerando su ejecuciÃ³n.
ğŸ§  Pregunta 12
Â¿CÃ³mo se puede lograr la reutilizaciÃ³n del cÃ³digo de test en diferentes etapas de un pipeline DevOps (unit vs. integration) utilizando fixtures de pytest?
A. Escribiendo funciones de prueba separadas para cada etapa con la misma lÃ³gica pero diferentes configuraciones.
B. Utilizando condicionales dentro de las funciones de prueba para adaptar su comportamiento segÃºn la etapa del pipeline.
C. Creando fixtures que adaptan su implementaciÃ³n (de stubs a instancias reales con contenedores) basÃ¡ndose en variables de entorno o flags de configuraciÃ³n del pipeline.
D. Ejecutando siempre todas las pruebas en todas las etapas del pipeline para asegurar la mÃ¡xima cobertura.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La clave para la reutilizaciÃ³n estÃ¡ en la configuraciÃ³n dinÃ¡mica de las fixtures, que pueden proporcionar stubs en pruebas unitarias y conexiones reales en pruebas de integraciÃ³n, manteniendo la misma lÃ³gica de aserciones en los tests.

ğŸ§  Pregunta 13
Â¿QuÃ© principio SOLID se ve reforzado al utilizar pytest-cov para establecer umbrales de cobertura automÃ¡tica en el pipeline de pruebas?

A. Principio de Responsabilidad Ãšnica (SRP).
B. Principio de Abierto/Cerrado (OCP).
C. Principio de SustituciÃ³n de Liskov (LSP).
D. Ninguno directamente, pero fomenta la calidad general del cÃ³digo probado.

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: Si bien `pytest-cov` no se alinea directamente con un principio SOLID especÃ­fico, ayuda a asegurar que el cÃ³digo estÃ© adecuadamente probado, lo que indirectamente apoya los objetivos de estos principios (como la robustez y la mantenibilidad).
ğŸ§  Pregunta 14
Â¿CuÃ¡l es la estrategia "Boy-Scout" mencionada en el texto para refactorizar suites de pruebas heredadas?

A. Eliminar todas las pruebas acopladas y lentas de una sola vez.
B. Refactorizar completamente un mÃ³dulo de cÃ³digo y su test correspondiente en cada sprint.
C. Identificar el test correspondiente a cada mÃ³dulo de cÃ³digo tocado y aplicar principios SOLID de forma progresiva.
D. Documentar las pruebas heredadas sin modificarlas para entender su funcionamiento.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La estrategia "Boy-Scout" implica mejorar gradualmente la suite de pruebas al refactorizar los tests relacionados con el cÃ³digo que se estÃ¡ modificando.
ğŸ§  Pregunta 15
SegÃºn el texto, Â¿hacia dÃ³nde traslada la responsabilidad de conocer las implementaciones concretas el Principio de InversiÃ³n de Dependencias (DIP)?

A. Hacia las capas de alto nivel o reglas de negocio.
B. Hacia los tests unitarios, que deben configurar las dependencias.
C. Hacia un punto de ensamblaje externo, como los fixtures en pytest.
D. Hacia las implementaciones concretas, que deben ser autoconfigurables.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: DIP promueve que la creaciÃ³n y configuraciÃ³n de las dependencias se realice en un lugar separado de la lÃ³gica de negocio, facilitando la sustituciÃ³n de implementaciones en los tests.
ğŸ§  Pregunta 16
Â¿De quÃ© manera la declaraciÃ³n explÃ­cita de necesidades en los tests de pytest (a travÃ©s de los nombres de las fixtures en la firma de la funciÃ³n) materializa el Principio de InversiÃ³n de Dependencias (DIP)?

A. Obliga a los desarrolladores a crear mocks complejos para cada dependencia.
B. Permite que los tests indiquen *quÃ©* necesitan sin especificar *cÃ³mo* obtenerlo, delegando la creaciÃ³n de las dependencias a pytest.
C. Asegura que todas las dependencias se resuelvan al inicio de la sesiÃ³n de pruebas.
D. Reduce la necesidad de definir explÃ­citamente las dependencias en los tests.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Al declarar las dependencias como parÃ¡metros de las funciones de prueba, se establece una abstracciÃ³n (la fixture) sin que el test se preocupe por la implementaciÃ³n concreta.
ğŸ§  Pregunta 17
Â¿QuÃ© beneficio principal se obtiene al centralizar la lÃ³gica de preparaciÃ³n y liberaciÃ³n de recursos dentro de las fixtures de pytest, en lugar de hacerlo directamente en los tests?

A. Acelera la ejecuciÃ³n de las pruebas al evitar la repeticiÃ³n de cÃ³digo de setup.
B. Permite versionar, revisar y endurecer la lÃ³gica de setup y teardown de manera similar a otros artefactos de la infraestructura.
C. Asegura que los recursos se liberen automÃ¡ticamente despuÃ©s de cada test, incluso en caso de fallo.
D. Facilita la creaciÃ³n de entornos de prueba mÃ¡s complejos y personalizados para cada test.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Centralizar la lÃ³gica en fixtures mejora la mantenibilidad y la seguridad del cÃ³digo de prueba, permitiendo un tratamiento consistente de la preparaciÃ³n y limpieza de los recursos.
ğŸ§  Pregunta 18
Â¿CuÃ¡l de las siguientes NO es una caracterÃ­stica clave de las fixtures "Constructor-like" en pytest mencionada en el texto?

A. InicializaciÃ³n Ãºnica por sesiÃ³n o mÃ³dulo.
B. ReutilizaciÃ³n a nivel de suite de pruebas.
C. Flexibilidad puntual para modificar el estado durante el test.
D. ConfiguraciÃ³n centralizada de los objetos creados.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La flexibilidad puntual para modificar el estado es una caracterÃ­stica de las fixtures "Setter-like", no de las "Constructor-like", que se centran en la creaciÃ³n y configuraciÃ³n inicial de objetos.
ğŸ§  Pregunta 19
Â¿En quÃ© se diferencian principalmente las fixtures "Setter-like" de las "Constructor-like" en pytest?

A. Las "Setter-like" crean instancias de objetos, mientras que las "Constructor-like" modifican su comportamiento.
B. Las "Setter-like" tienen un scope mÃ¡s amplio (sesiÃ³n o mÃ³dulo) que las "Constructor-like" (funciÃ³n).
C. Las "Setter-like" proporcionan funciones para parchear o ajustar comportamientos dinÃ¡micamente, mientras que las "Constructor-like" devuelven instancias ya configuradas.
D. Las "Setter-like" se utilizan principalmente en pruebas de integraciÃ³n, y las "Constructor-like" en pruebas unitarias.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La distinciÃ³n clave radica en su propÃ³sito: las "Setter-like" modifican el comportamiento, y las "Constructor-like" crean y configuran objetos.
ğŸ§  Pregunta 20
Â¿QuÃ© ventaja principal ofrecen las fixtures "Interface-driven" en tÃ©rminos de recursos y dependencias en el testing?

A. Permiten simular interacciones complejas con mÃºltiples servicios externos.
B. Requieren la configuraciÃ³n de bases de datos y otros servicios para su funcionamiento.
C. Consumen pocos recursos y no necesitan conexiones externas al limitarse a implementaciones mÃ­nimas (fakes o stubs).
D. Aseguran que las pruebas se ejecuten en el mismo entorno que la aplicaciÃ³n en producciÃ³n.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La ligereza y el aislamiento de las "Interface-driven" fixtures las hacen ideales para pruebas rÃ¡pidas y confiables sin dependencias externas.
ğŸ§  Pregunta 21
Â¿CÃ³mo se relaciona el uso de fixtures "Interface-driven" con el Principio de SustituciÃ³n de Liskov (LSP)?

A. Aseguran que los fakes o stubs creados por estas fixtures tengan un comportamiento idÃ©ntico a las implementaciones reales.
B. Definen claramente las interfaces que deben cumplir las dependencias, permitiendo la intercambiabilidad de implementaciones.
C. Facilitan la inyecciÃ³n de diferentes implementaciones de una interfaz sin necesidad de modificar los tests.
D. Permiten probar diferentes escenarios de error al simular fallos en las implementaciones de las interfaces.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Al proporcionar implementaciones que cumplen con las interfaces esperadas, las "Interface-driven" fixtures permiten sustituir las implementaciones reales por fakes o stubs sin que los tests lo noten, lo cual es fundamental para LSP.
ğŸ§  Pregunta 22
En una etapa de pruebas unitarias de un pipeline DevOps, Â¿quÃ© tipo de fixtures serÃ­an mÃ¡s apropiadas para maximizar la velocidad de ejecuciÃ³n segÃºn el texto?

A. Fixtures "Constructor-like" que levantan contenedores Docker.
B. Fixtures "Setter-like" que parchean llamadas a servicios externos con stubs.
C. Fixtures "Interface-driven" que proporcionan implementaciones ligeras en memoria.
D. Tanto las fixtures "Setter-like" como las "Interface-driven".

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: Ambas ("Setter-like" para simular dependencias y "Interface-driven" para proporcionar implementaciones ligeras) contribuyen a la rapidez de las pruebas unitarias al evitar la interacciÃ³n con sistemas externos o la inicializaciÃ³n de componentes pesados.
ğŸ§  Pregunta 23
Â¿CÃ³mo se pueden reutilizar las fixtures "Constructor-like" en diferentes etapas del pipeline (por ejemplo, unit e integraciÃ³n) para interactuar con diferentes entornos (stubs vs. contenedores reales)?

A. Creando fixtures completamente separadas para cada entorno.
B. Utilizando condicionales dentro de la fixture para determinar quÃ© tipo de instancia crear basÃ¡ndose en variables de entorno o flags de configuraciÃ³n.
C. Asegurando que las fixtures siempre devuelvan stubs, independientemente del entorno.
D. Modificando directamente el cÃ³digo de las fixtures antes de cada ejecuciÃ³n del pipeline.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La adaptaciÃ³n basada en el entorno permite que la misma fixture proporcione diferentes implementaciones (stubs para unit tests, clientes reales para integraciÃ³n) sin necesidad de duplicar cÃ³digo de prueba.
ğŸ§  Pregunta 24
SegÃºn el texto, Â¿quÃ© tipo de pruebas se benefician mÃ¡s del uso de fixtures "Constructor-like" que levantan contenedores Docker en la etapa de integraciÃ³n de un pipeline DevOps?

A. Pruebas unitarias que necesitan un entorno aislado.
B. Pruebas de rendimiento que requieren simular carga real.
C. Pruebas de integraciÃ³n que verifican la interacciÃ³n entre diferentes servicios.
D. Pruebas de interfaz de usuario que necesitan un navegador web especÃ­fico.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Las fixtures "Constructor-like" que gestionan contenedores son ideales para las pruebas de integraciÃ³n, ya que permiten levantar las dependencias necesarias (bases de datos, colas, etc.) en un entorno controlado y efÃ­mero.
ğŸ§  Pregunta 25
Â¿De quÃ© manera la abstracciÃ³n lograda mediante el uso de fixtures contribuye a la reutilizaciÃ³n del cÃ³digo de test en diferentes etapas del pipeline?

A. Permite que las funciones de prueba sean mÃ¡s especÃ­ficas y dependan de menos fixtures.
B. Asegura que cada test se ejecute en un entorno completamente aislado, evitando dependencias entre pruebas.
C. Permite que el mismo conjunto de tests (funciones y aserciones) se ejecute con diferentes implementaciones de las dependencias proporcionadas por las fixtures (stubs vs. reales).
D. Reduce la necesidad de escribir aserciones detalladas al confiar en el comportamiento predefinido de las fixtures.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Al abstraer la obtenciÃ³n de las dependencias a travÃ©s de fixtures, la lÃ³gica de los tests se mantiene independiente de la implementaciÃ³n concreta, lo que facilita su reutilizaciÃ³n en diferentes contextos.
ğŸ§  Pregunta 26
Â¿QuÃ© ventaja ofrece la integraciÃ³n de mÃ©tricas como la cobertura de cÃ³digo (pytest-cov) y el rendimiento (pytest-benchmark) en un pipeline SOLID de testing?

A. Acelera la ejecuciÃ³n de las pruebas al optimizar la selecciÃ³n de casos de prueba.
B. Genera automÃ¡ticamente documentaciÃ³n detallada del cÃ³digo probado y su rendimiento.
C. Permite establecer umbrales automÃ¡ticos que pueden bloquear el pipeline si se detectan degradaciones o falta de cobertura, manteniendo la calidad sin intervenciÃ³n manual constante.
D. Facilita la identificaciÃ³n de pruebas "flaky" al registrar la variabilidad en los tiempos de ejecuciÃ³n.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La integraciÃ³n de mÃ©tricas permite una vigilancia continua de la calidad y el rendimiento, automatizando la prevenciÃ³n de regresiones.
ğŸ§  Pregunta 27
Â¿CÃ³mo facilita una suite de pruebas bien diseÃ±ada bajo los principios SOLID la instrumentaciÃ³n de mÃ©tricas como la cobertura y el rendimiento?

A. Al organizar las pruebas en archivos separados por tipo (unit, integration, benchmark).
B. Al hacer que cada prueba sea mÃ¡s compleja y evalÃºe mÃºltiples aspectos del cÃ³digo simultÃ¡neamente.
C. Al tener pruebas mÃ¡s enfocadas y modulares, lo que permite analizar la cobertura y el rendimiento de unidades especÃ­ficas de manera mÃ¡s clara.
D. Al reducir la cantidad total de cÃ³digo de prueba necesario para una cobertura completa.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La claridad y el enfoque de las pruebas SOLID facilitan el anÃ¡lisis de mÃ©tricas especÃ­ficas por componente o funcionalidad.
ğŸ§  Pregunta 28
Â¿QuÃ© significa el tÃ©rmino "flakiness" en el contexto de las pruebas automatizadas y cÃ³mo podrÃ­a una suite bien diseÃ±ada bajo principios SOLID ayudar a mitigar este problema?

A. Se refiere a la lentitud en la ejecuciÃ³n de las pruebas, y SOLID ayuda a optimizar el rendimiento.
B. Describe pruebas que producen resultados inconsistentes (pasan o fallan sin cambios en el cÃ³digo), y SOLID, al promover el aislamiento y la claridad, reduce las dependencias ocultas y los efectos secundarios que pueden causar flakiness.
C. Se refiere a la falta de cobertura de cÃ³digo, y SOLID guÃ­a sobre cÃ³mo escribir pruebas mÃ¡s exhaustivas.
D. Describe pruebas que son difÃ­ciles de entender y mantener, y SOLID promueve la claridad y la simplicidad.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La flakiness a menudo se debe a dependencias no gestionadas o efectos secundarios inesperados. Los principios SOLID, al fomentar el aislamiento y la claridad, ayudan a construir pruebas mÃ¡s deterministas.

ğŸ§  Pregunta 29
Â¿CuÃ¡l es el principio fundamental detrÃ¡s de la InversiÃ³n de Dependencias (DIP) aplicado al diseÃ±o de software y cÃ³mo se manifiesta en el testing a travÃ©s de fixtures?

A. Las clases de alto nivel deben depender de clases de bajo nivel. En testing, esto significa usar las implementaciones reales en las pruebas.
B. Las clases de bajo nivel deben depender de clases de alto nivel. En testing, esto implica mockear las dependencias de la lÃ³gica de negocio.
C. Las abstracciones no deben depender de los detalles. Los detalles deben depender de las abstracciones. En testing, esto se traduce en que los tests interactÃºan con abstracciones (fixtures) sin conocer los detalles de las implementaciones reales.
D. Las abstracciones deben depender de los detalles. Los detalles no deben depender de las abstracciones. En testing, esto sugiere que los tests deben conocer las implementaciones concretas para ser precisos.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: DIP invierte la dependencia tradicional, haciendo que las capas de alto nivel dependan de abstracciones, no de implementaciones concretas. En testing, las fixtures actÃºan como estas abstracciones.
ğŸ§  Pregunta 30
Â¿CÃ³mo contribuye la elasticidad de los entornos efÃ­meros en un pipeline DevOps a la efectividad de las pruebas que utilizan fixtures con InversiÃ³n de Dependencias (DIP)?

A. Reduce la necesidad de usar stubs y mocks, ya que siempre se dispone de entornos reales.
B. Permite que las mismas fixtures se configuren dinÃ¡micamente mediante variables de entorno para interactuar con diferentes tipos de entornos (embebidos, contenedores, gestionados) en distintas fases del pipeline.
C. Asegura que todas las pruebas se ejecuten en el mismo entorno de producciÃ³n para mayor realismo.
D. Simplifica la gestiÃ³n de secretos y credenciales al estar todo centralizado en el entorno efÃ­mero.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La capacidad de configurar las fixtures segÃºn el entorno permite una gran flexibilidad y reutilizaciÃ³n de las pruebas a lo largo del ciclo de vida del desarrollo.
ğŸ§  Pregunta 31
Â¿De quÃ© manera la instrumentaciÃ³n de un cliente HTTP con cabeceras de trace-id dentro de una fixture contribuye a la observabilidad y trazabilidad en un entorno DevOps?

A. Permite que los tests se ejecuten mÃ¡s rÃ¡pido al reducir la sobrecarga de las peticiones HTTP.
B. Asegura que todas las peticiones HTTP realizadas durante la ejecuciÃ³n de los tests contengan informaciÃ³n para correlacionarlas con mÃ©tricas de latencia y otros datos en el stack de observabilidad.
C. Simplifica la configuraciÃ³n de la autenticaciÃ³n y autorizaciÃ³n para las llamadas a servicios externos.
D. Genera automÃ¡ticamente documentaciÃ³n sobre las interacciones HTTP realizadas por los tests.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La inclusiÃ³n de `trace-id` en las peticiones HTTP facilita el seguimiento de las transacciones a travÃ©s de diferentes servicios, lo que es crucial para el diagnÃ³stico y la monitorizaciÃ³n.
ğŸ§  Pregunta 32
Â¿CÃ³mo puede la InversiÃ³n de Dependencias (DIP) a travÃ©s de fixtures facilitar la gobernanza de datos en un pipeline DevOps, especialmente en lo referente a la protecciÃ³n de informaciÃ³n sensible (PII)?

A. Al forzar el uso de datos reales de producciÃ³n en todas las etapas del pipeline para detectar problemas reales.
B. Al permitir que las fixtures elijan dinÃ¡micamente entre un dataset anonimizado para pre-producciÃ³n y un generador sintÃ©tico de registros GDPR-safe para CI, garantizando el cumplimiento normativo sin exponer PII.
C. Al cifrar automÃ¡ticamente todos los datos utilizados por las pruebas en todas las etapas del pipeline.
D. Al limitar el acceso a los datos de prueba solo a los desarrolladores autorizados.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: DIP permite inyectar diferentes implementaciones de la gestiÃ³n de datos segÃºn el entorno, asegurando la protecciÃ³n de datos sensibles en las etapas adecuadas del pipeline.
ğŸ§  Pregunta 33
Â¿QuÃ© son las estrategias "chaos-friendly" en el contexto del testing y cÃ³mo pueden las fixtures parametrizadas contribuir a su implementaciÃ³n en un pipeline DevOps?

A. Son estrategias para acelerar la ejecuciÃ³n de las pruebas mediante la paralelizaciÃ³n masiva. Las fixtures parametrizadas permiten definir diferentes configuraciones de paralelizaciÃ³n.
B. Son estrategias para simular fallos e inestabilidad en las dependencias para validar la resiliencia de la aplicaciÃ³n. Las fixtures parametrizadas pueden envolver las dependencias con proxies que introducen fallos probabilÃ­sticos.
C. Son estrategias para reducir la complejidad del cÃ³digo de prueba mediante la abstracciÃ³n de las interacciones con las dependencias. Las fixtures parametrizadas simplifican la creaciÃ³n de mocks.
D. Son estrategias para mejorar la cobertura del cÃ³digo mediante la generaciÃ³n automÃ¡tica de casos de prueba. Las fixtures parametrizadas permiten definir diferentes escenarios de entrada.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Las pruebas de caos buscan verificar cÃ³mo la aplicaciÃ³n se comporta ante fallos. Las fixtures parametrizadas pueden inyectar proxies que simulan estos fallos de manera controlada.
ğŸ§  Pregunta 34
Â¿CÃ³mo puede la InversiÃ³n de Dependencias (DIP) a travÃ©s de fixtures facilitar el versionado progresivo de librerÃ­as de dominio en un pipeline DevOps?

A. Al obligar a detener el desarrollo funcional hasta que todas las dependencias se hayan actualizado a la nueva versiÃ³n.
B. Al permitir la creaciÃ³n de fixtures "adaptadoras" que implementan ambas versiones de una interfaz, ejecutando los tests contra cada versiÃ³n para detectar incompatibilidades.
C. Al eliminar la necesidad de actualizar las dependencias hasta que todos los tests hayan sido migrados a la nueva versiÃ³n.
D. Al generar automÃ¡ticamente cÃ³digo de adaptaciÃ³n entre diferentes versiones de las dependencias.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Las fixtures adaptadoras actÃºan como un puente entre las diferentes versiones de una dependencia, permitiendo una transiciÃ³n gradual y la detecciÃ³n temprana de problemas de compatibilidad.
ğŸ§  Pregunta 35
Â¿CuÃ¡l de los principios SOLID se alinea mÃ¡s directamente con la idea de que los tests deben formular sus expectativas respecto a contratos semÃ¡nticos (fixtures) y no respecto a tipos concretos ni detalles de infraestructura?

A. Principio de Responsabilidad Ãšnica (SRP).
B. Principio de Abierto/Cerrado (OCP).
C. Principio de SustituciÃ³n de Liskov (LSP).
D. Principio de InversiÃ³n de Dependencias (DIP).

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: DIP promueve la dependencia de abstracciones (contratos definidos por las fixtures) en lugar de implementaciones concretas.
ğŸ§  Pregunta 36
Â¿CÃ³mo contribuye el Principio de Responsabilidad Ãšnica (SRP) aplicado al diseÃ±o de fixtures a la mantenibilidad y legibilidad de la suite de pruebas?

A. Asegura que cada fixture proporcione todas las dependencias necesarias para un grupo de tests relacionados.
B. Permite que cada fixture se centre en una Ãºnica responsabilidad operativa (por ejemplo, abrir una conexiÃ³n a la base de datos o autenticar a un usuario), manteniendo los tests pequeÃ±os y fÃ¡ciles de entender.
C. Reduce la cantidad total de fixtures necesarias al combinar funcionalidades relacionadas en una sola fixture.
D. Facilita la reutilizaciÃ³n de fixtures complejas en diferentes partes de la suite de pruebas.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Fixtures con una Ãºnica responsabilidad son mÃ¡s fÃ¡ciles de entender, mantener y reutilizar, lo que mejora la calidad general de la suite de pruebas.
ğŸ§  Pregunta 37
Â¿De quÃ© manera el Principio de Abierto/Cerrado (OCP) se aplica al diseÃ±o de fixtures en pytest cuando se necesita soportar un nuevo backend o una nueva variante de inyecciÃ³n de dependencias?

A. Se modifica la fixture existente para incluir la lÃ³gica del nuevo backend o variante de inyecciÃ³n.
B. Se crea una nueva fixture que reemplaza la existente con la lÃ³gica para el nuevo backend o variante.
C. Se aÃ±ade una ruta condicional a la fixture existente o se crea una fixture adicional sin necesidad de modificar los tests ya aprobados.
D. Se requiere la modificaciÃ³n de todos los tests que utilizan la fixture para que sean compatibles con el nuevo backend o variante.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: OCP busca extender la funcionalidad sin modificar el cÃ³digo existente. En el caso de las fixtures, esto implica aÃ±adir nuevas capacidades sin romper los tests que ya funcionan.
ğŸ§  Pregunta 38
Â¿CÃ³mo se relaciona el Principio de SustituciÃ³n de Liskov (LSP) con el diseÃ±o de fixtures "fake" o "spy" en pytest?

A. Asegura que estos tipos de fixtures tengan un rendimiento similar a las implementaciones reales.
B. Garantiza que cumplan la misma interfaz mÃ­nima que el recurso de producciÃ³n, permitiendo su intercambiabilidad sin afectar el comportamiento de los tests.
C. Facilita la inspecciÃ³n del estado interno de las dependencias durante la ejecuciÃ³n de los tests.
D. Permite simular fallos complejos en las dependencias para probar la robustez del cÃ³digo.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: LSP establece que los subtipos deben ser sustituibles por sus tipos base. En testing, esto significa que los fakes o spies deben comportarse de manera compatible con las dependencias reales.
ğŸ§  Pregunta 39
Â¿CÃ³mo contribuye el Principio de SegregaciÃ³n de la Interfaz (ISP) al diseÃ±o de fixtures en pytest?

A. Fomenta la creaciÃ³n de fixtures grandes que proporcionen todas las dependencias posibles para un grupo de tests.
B. Promueve la creaciÃ³n de fixtures que exponen solo la funcionalidad que la capa de negocio invoca, minimizando el acoplamiento y evitando exponer funcionalidad innecesaria.
C. Asegura que todas las fixtures tengan el mismo ciclo de vida y scope dentro de la suite de pruebas.
D. Facilita la comparticiÃ³n de la misma instancia de una dependencia entre mÃºltiples tests.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: ISP aboga por interfaces especÃ­ficas para los clientes. En el caso de las fixtures, esto significa que cada fixture debe proporcionar solo lo necesario para los tests que la utilizan.
ğŸ§  Pregunta 40
Â¿CuÃ¡l es el objetivo principal de integrar la InversiÃ³n de Dependencias (DIP) en los pipelines DevOps a travÃ©s del uso de fixtures?

A. Reducir la cantidad de cÃ³digo de prueba necesario para una cobertura completa.
B. Acelerar la ejecuciÃ³n de las pruebas al eliminar la necesidad de configurar entornos complejos.
C. Habilitar pipelines reproducibles, enriquecer la observabilidad y acelerar la detecciÃ³n de regresiones, al tiempo que se facilita el despliegue continuo confiable.
D. Asegurar que todas las pruebas se ejecuten en un entorno lo mÃ¡s similar posible al de producciÃ³n.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La integraciÃ³n de DIP con fixtures busca mejorar la robustez, la mantenibilidad y la eficiencia de todo el proceso de desarrollo y despliegue.
ğŸ§  Pregunta 41
Â¿QuÃ© papel juegan las variables de entorno en la configuraciÃ³n dinÃ¡mica de fixtures "Constructor-like" para diferentes etapas de un pipeline DevOps?

A. Se utilizan para definir el orden en que se ejecutan las fixtures.
B. Permiten especificar los nombres de los servicios y las credenciales necesarias para interactuar con los diferentes entornos (local, CI, staging).
C. Controlan el scope (funciÃ³n, mÃ³dulo, sesiÃ³n) de las fixtures.
D. Definen las marcas (marks) que se pueden utilizar para seleccionar subconjuntos de tests.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Las variables de entorno proporcionan una forma flexible de configurar las fixtures para que apunten a los recursos correctos en cada etapa del pipeline.
ğŸ§  Pregunta 42
Â¿CÃ³mo contribuye la instrumentaciÃ³n de fixtures con etiquetas o spans a la observabilidad dentro de un pipeline DevOps?

A. Permite visualizar la topologÃ­a de las dependencias entre diferentes fixtures.
B. Facilita la correlaciÃ³n de las acciones realizadas por los tests con mÃ©tricas de latencia y otros datos de rendimiento en las herramientas de monitorizaciÃ³n.
C. Asegura que los logs generados por los tests se almacenen en un formato estandarizado.
D. Permite la creaciÃ³n de dashboards personalizados con el estado de ejecuciÃ³n de las fixtures.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Las etiquetas y spans aÃ±aden contexto a las operaciones realizadas por las fixtures, lo que facilita el seguimiento y anÃ¡lisis del comportamiento del sistema durante las pruebas.
ğŸ§  Pregunta 43
Â¿De quÃ© manera el uso de fixtures con InversiÃ³n de Dependencias (DIP) puede mejorar la seguridad en un pipeline DevOps en relaciÃ³n con la gestiÃ³n de credenciales?

A. Al codificar las credenciales directamente en las fixtures para facilitar su acceso.
B. Al permitir que las fixtures obtengan las credenciales de mecanismos seguros como secret managers, en lugar de tenerlas directamente en el cÃ³digo de prueba.
C. Al eliminar la necesidad de utilizar credenciales en los entornos de prueba.
D. Al rotar automÃ¡ticamente las credenciales despuÃ©s de cada ejecuciÃ³n de prueba.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: DIP facilita la separaciÃ³n de la lÃ³gica de prueba de la gestiÃ³n de secretos, permitiendo que las fixtures obtengan las credenciales de forma segura.
ğŸ§  Pregunta 44
Â¿CÃ³mo facilita la InversiÃ³n de Dependencias (DIP) a travÃ©s de fixtures la implementaciÃ³n de estrategias "chaos-friendly" en un pipeline DevOps para validar la resiliencia de la aplicaciÃ³n?

A. Al simplificar la lÃ³gica de los tests para que sean menos propensos a fallar ante condiciones inesperadas.
B. Al permitir la inyecciÃ³n de proxies o implementaciones alternativas de las dependencias que introducen comportamientos errÃ¡ticos o latencia controlada.
C. Al asegurar que todas las dependencias estÃ©n siempre disponibles y funcionando correctamente durante las pruebas.
D. Al generar automÃ¡ticamente informes detallados sobre los fallos detectados durante las pruebas de caos.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: DIP permite sustituir las implementaciones reales de las dependencias por versiones que simulan fallos, lo que es esencial para probar la resiliencia.
ğŸ§  Pregunta 45
Â¿QuÃ© ventaja ofrece la reutilizaciÃ³n del mismo conjunto de tests en diferentes etapas del pipeline (unit e integraciÃ³n) mediante la configuraciÃ³n dinÃ¡mica de fixtures?

A. Reduce significativamente el tiempo total de ejecuciÃ³n del pipeline.
B. Asegura que las pruebas unitarias y de integraciÃ³n siempre produzcan los mismos resultados.
C. Permite una validaciÃ³n consistente de la lÃ³gica de negocio en diferentes niveles de integraciÃ³n, con la Ãºnica diferencia en las implementaciones de las dependencias.
D. Simplifica la creaciÃ³n de informes de cobertura al tener un Ãºnico conjunto de tests.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La reutilizaciÃ³n de tests con diferentes configuraciones de fixtures asegura una validaciÃ³n coherente a lo largo del pipeline.
ğŸ§  Pregunta 46
Â¿CÃ³mo contribuye la abstracciÃ³n lograda mediante fixtures a la escalabilidad de la suite de pruebas en un entorno DevOps con mÃºltiples microservicios o repositorios?

A. Al reducir la cantidad total de fixtures necesarias al hacerlas mÃ¡s genÃ©ricas.
B. Al permitir aÃ±adir nuevas variantes de fixtures para nuevos microservicios sin necesidad de modificar los tests existentes que no dependen de ellos.
C. Al asegurar que todas las fixtures se definan en un Ãºnico lugar para facilitar su gestiÃ³n.
D. Al obligar a modificar todas las fixtures cada vez que se aÃ±ade un nuevo microservicio.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La abstracciÃ³n a travÃ©s de fixtures permite extender la suite de pruebas de forma modular, sin afectar el cÃ³digo de prueba existente.
ğŸ§  Pregunta 47
Â¿QuÃ© tipo de errores son mÃ¡s probables de identificar en las pruebas unitarias que utilizan fixtures con stubs e interfaces, en comparaciÃ³n con las pruebas de integraciÃ³n que utilizan contenedores reales?

A. Problemas de configuraciÃ³n en los servicios externos.
B. Incompatibilidades entre diferentes microservicios.
C. Errores en la lÃ³gica de negocio pura dentro de los componentes individuales.
D. Problemas de rendimiento y cuellos de botella en la infraestructura.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Las pruebas unitarias se centran en la lÃ³gica interna de las unidades de cÃ³digo, mientras que las pruebas de integraciÃ³n se enfocan en las interacciones entre componentes.
ğŸ§  Pregunta 48
Â¿CÃ³mo facilita la prÃ¡ctica de la InversiÃ³n de Dependencias (DIP) con fixtures el mantenimiento de una suite de pruebas a largo plazo en un entorno DevOps en constante evoluciÃ³n?

A. Al hacer que los tests dependan directamente de las implementaciones concretas, lo que facilita la detecciÃ³n de cambios en las dependencias.
B. Al desacoplar los tests de los detalles de implementaciÃ³n de las dependencias, reduciendo el impacto de los cambios en las dependencias sobre los tests.
C. Al obligar a reescribir todos los tests cada vez que una dependencia se actualiza.
D. Al eliminar la necesidad de realizar pruebas cuando las dependencias no cambian.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El desacoplamiento proporcionado por DIP hace que los tests sean mÃ¡s resilientes a los cambios en las dependencias, lo que facilita su mantenimiento.

ğŸ§  Pregunta 49
Â¿CuÃ¡l es el beneficio de alcanzar un equilibrio entre velocidad y realismo en las pruebas dentro de un pipeline DevOps, y cÃ³mo contribuye la InversiÃ³n de Dependencias (DIP) a lograr este equilibrio?

A. Un mayor realismo siempre es preferible, incluso si aumenta significativamente el tiempo de ejecuciÃ³n del pipeline. DIP ayuda a simular entornos de producciÃ³n exactos.
B. La velocidad es lo mÃ¡s importante para obtener feedback rÃ¡pido. DIP permite ejecutar solo las pruebas mÃ¡s rÃ¡pidas en cada commit.
C. Un equilibrio permite obtener feedback rÃ¡pido sobre la lÃ³gica de negocio (con pruebas rÃ¡pidas y aisladas) y validar las interacciones en entornos mÃ¡s realistas (con pruebas de integraciÃ³n configurables mediante DIP), asegurando un flujo de entrega continuo y confiable.
D. No es necesario un equilibrio; todas las pruebas deben ser tanto rÃ¡pidas como completamente realistas. DIP no tiene un impacto significativo en esto.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Un buen pipeline equilibra la rapidez de las pruebas unitarias (con DIP facilitando el aislamiento) con el realismo de las pruebas de integraciÃ³n (donde DIP permite configurar entornos mÃ¡s cercanos a producciÃ³n).
ğŸ§  Pregunta 50
En el contexto de un pipeline DevOps, Â¿cÃ³mo la aplicaciÃ³n consistente de los principios SOLID al diseÃ±o de las pruebas, incluyendo la InversiÃ³n de Dependencias (DIP) a travÃ©s de fixtures, impacta la confianza en los despliegues continuos?

A. Disminuye la confianza al introducir mÃ¡s complejidad en el cÃ³digo de prueba.
B. No tiene un impacto significativo en la confianza de los despliegues.
C. Aumenta la confianza al asegurar que el software se valida de manera exhaustiva, modular y mantenible a lo largo del ciclo de vida del desarrollo, reduciendo el riesgo de regresiones y problemas en producciÃ³n.
D. Reduce la necesidad de realizar pruebas manuales despuÃ©s de los despliegues, lo que puede disminuir la confianza si no se detectan todos los problemas automÃ¡ticamente.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Una suite de pruebas bien diseÃ±ada bajo principios SOLID proporciona una validaciÃ³n robusta y confiable del software, lo que genera mayor confianza en la automatizaciÃ³n de los despliegues continuos.
