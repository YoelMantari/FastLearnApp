ğŸ§  Pregunta 1
Â¿CuÃ¡l es el propÃ³sito principal de los mocks en las pruebas?

A. Proveer datos deterministas al cÃ³digo bajo prueba.
B. Simular dependencias y registrar interacciones.
C. Implementar una versiÃ³n simplificada de una dependencia real.
D. Pasar objetos sin funcionalidad para completar parÃ¡metros.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Los mocks no solo suministran respuestas, sino que tambiÃ©n registran informaciÃ³n sobre cÃ³mo se han llamado, lo que permite verificar las interacciones entre componentes.

ğŸ§  Pregunta 2
Â¿CuÃ¡l de las siguientes NO es una caracterÃ­stica clave de los stubs?

A. Respuestas fijas.
B. Simplicidad.
C. Registro de llamadas.
D. Velocidad.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Los stubs se centran en proveer datos deterministas y son simples, rÃ¡pidos y predecibles. No registran informaciÃ³n sobre las llamadas.

ğŸ§  Pregunta 3
Â¿QuÃ© tipo de doble de prueba se utiliza para validar que un componente modifica el estado de otro objeto de forma adecuada, manteniendo la lÃ³gica original?

A. Fake.
B. Spy.
C. Dummy.
D. Mock.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Los spies delegan las llamadas al objeto real y, ademÃ¡s, "espÃ­an" quÃ© mÃ©todos se invocan y con quÃ© argumentos.

ğŸ§  Pregunta 4
En el contexto de DevOps, Â¿en quÃ© etapa del pipeline se recomienda ejecutar tests unitarios ligeros con stubs?

A. Pre-commit hooks.
B. Build stage.
C. Gate de integraciÃ³n.
D. Despliegue en producciÃ³n.

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: Los tests unitarios ligeros con stubs permiten una retroalimentaciÃ³n rÃ¡pida antes de que los cambios se integren.

ğŸ§  Pregunta 5
Â¿QuÃ© ventaja ofrece la escuela Mockist en comparaciÃ³n con la escuela Classical?

A. Mayor confianza en la cohesiÃ³n del sistema.
B. DetecciÃ³n temprana de rupturas de interfaz.
C. Mayor tiempo de ejecuciÃ³n.
D. Mayor complejidad de mantenimiento.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La escuela Mockist prioriza la velocidad y el aislamiento, lo que permite detectar cambios en las interfaces de forma inmediata.

ğŸ§  Pregunta 6
Â¿QuÃ© tipo de doble de prueba implementa una versiÃ³n simplificada pero funcional de una dependencia real?

A. Stub.
B. Mock.
C. Fake.
D. Spy.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Los fakes conservan parte de la lÃ³gica de producciÃ³n, lo que permite realizar tests mÃ¡s cercanos a la realidad sin necesidad de desplegar servicios completos.

ğŸ§  Pregunta 7
Â¿CuÃ¡l es el principal beneficio de utilizar mocks en las pruebas unitarias dentro de un pipeline de CI/CD?

A. Asegurar la fidelidad de la implementaciÃ³n de las dependencias externas.
B. Acelerar el feedback loop al eliminar la necesidad de interactuar con sistemas reales.
C. Garantizar que las pruebas reflejen el comportamiento exacto del entorno de producciÃ³n.
D. Reducir la complejidad de la configuraciÃ³n de los entornos de prueba.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Al simular las dependencias externas, los tests con mocks se ejecutan rÃ¡pidamente y de forma aislada, proporcionando retroalimentaciÃ³n inmediata.

ğŸ§  Pregunta 8
Â¿QuÃ© permite verificar la propiedad side_effect de un mock?

A. El nÃºmero de veces que se llamÃ³ al mock.
B. Los argumentos con los que se llamÃ³ al mock.
C. Simular excepciones, retardos o devoluciones dinÃ¡micas.
D. El valor de retorno del mock.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: side_effect en los mocks permite definir comportamientos mÃ¡s complejos que un simple valor de retorno, como lanzar excepciones o variar las respuestas en cada llamada.

ğŸ§  Pregunta 9
Â¿CuÃ¡l es el propÃ³sito principal de un dummy en las pruebas?

A. Verificar las interacciones con otras dependencias.
B. Proveer datos de prueba especÃ­ficos para diferentes escenarios.
C. Cumplir con la firma de un mÃ©todo sin ser realmente utilizado.
D. Simular el comportamiento de un sistema externo de manera realista.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Los dummies son objetos sin funcionalidad que se pasan Ãºnicamente para completar la lista de parÃ¡metros de un mÃ©todo.

ğŸ§  Pregunta 10
En la escuela Classical de testing, Â¿cuÃ¡l es la principal caracterÃ­stica de las pruebas?

A. Aislamiento estricto de cada unidad de cÃ³digo mediante mocks.
B. EjecuciÃ³n rÃ¡pida y en milisegundos.
C. IntegraciÃ³n real de mÃºltiples componentes en sus versiones reales.
D. VerificaciÃ³n detallada de los contratos de interacciÃ³n.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La escuela Classical enfatiza la prueba del sistema con la mayor cantidad posible de componentes reales para asegurar la integridad.

ğŸ§  Pregunta 11
Â¿CuÃ¡l es una desventaja clave de la escuela Mockist de testing?

A. Mayor tiempo de ejecuciÃ³n de las pruebas.
B. Complejidad en la configuraciÃ³n de los entornos de prueba.
C. Posibilidad de falsos negativos en la integraciÃ³n.
D. Dificultad para detectar rupturas en las interfaces.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Al depender de simulaciones, las pruebas Mockist pueden no detectar problemas que surgen en la interacciÃ³n con sistemas reales.

ğŸ§  Pregunta 12
Â¿QuÃ© utilidad tiene la parametrizaciÃ³n de tests en pytest?

A. Aislar completamente cada test para evitar dependencias.
B. Ejecutar los tests en paralelo para reducir el tiempo total.
C. Probar mÃºltiples escenarios con un Ãºnico bloque de cÃ³digo.
D. Generar informes de cobertura detallados automÃ¡ticamente.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La parametrizaciÃ³n permite ejecutar el mismo test con diferentes conjuntos de datos o configuraciones, aumentando la cobertura sin duplicar cÃ³digo.

ğŸ§  Pregunta 13
Â¿QuÃ© problema ayuda a resolver la tÃ©cnica autospec al crear mocks?

A. La lentitud en la creaciÃ³n de mocks complejos.
B. La dificultad para verificar el nÃºmero exacto de llamadas.
C. La desincronizaciÃ³n silenciosa cuando cambian las firmas de los mÃ©todos reales.
D. La falta de soporte para simular mÃ©todos asÃ­ncronos.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: autospec crea mocks que respetan la firma de la implementaciÃ³n real, detectando llamadas con parÃ¡metros invÃ¡lidos.

ğŸ§  Pregunta 14
Â¿Para quÃ© se utiliza la propiedad call_args_list de un mock?

A. Para verificar si el mock fue llamado al menos una vez.
B. Para obtener una lista de todas las llamadas realizadas al mock, con sus argumentos.
C. Para simular una secuencia de valores de retorno diferentes.
D. Para especificar los argumentos esperados en la Ãºltima llamada al mock.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: call_args_list almacena un registro de todas las llamadas al mock, permitiendo inspeccionar el orden y los argumentos de cada una.

ğŸ§  Pregunta 15
Â¿CuÃ¡l es la diferencia principal entre @pytest.mark.skip y @pytest.mark.xfail?

A. skip se usa para marcar tests que fallan, mientras que xfail se usa para los que pasan inesperadamente.
B. Los tests skip no se ejecutan y no se informan, mientras que los xfail se ejecutan y su resultado se informa.
C. Los tests skip no se ejecutan pero se registran en el informe, mientras que los xfail se ejecutan y un fallo se considera esperado.
D. skip se aplica a nivel de funciÃ³n, mientras que xfail se aplica a nivel de clase o mÃ³dulo.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: skip se usa para pruebas que no son relevantes en ciertas condiciones, mientras que xfail se usa para pruebas que se espera que fallen (por un bug conocido, por ejemplo).

ğŸ§  Pregunta 16
Â¿CuÃ¡l de las siguientes NO es una buena prÃ¡ctica al utilizar mocks y stubs en DevOps?

A. Limitar la complejidad de los mocks para evitar simular toda la lÃ³gica.
B. Asegurar que los tests sean no deterministas para cubrir una mayor variedad de escenarios.
C. Documentar claramente el comportamiento simulado de los mocks y stubs.
D. Revisar periÃ³dicamente la alineaciÃ³n de los mocks con las dependencias reales.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Los tests deben ser deterministas para ser confiables y reproducibles. Depender de datos aleatorios o relojes del sistema introduce variabilidad.

ğŸ§  Pregunta 17
En un pipeline de CI/CD, Â¿quÃ© beneficio aporta la integraciÃ³n de herramientas de cobertura como coverage.py con pytest?

A. Permite visualizar el rendimiento de los tests a lo largo del tiempo.
B. Asegura que un porcentaje mÃ­nimo del cÃ³digo estÃ© cubierto por las pruebas.
C. Facilita la creaciÃ³n y gestiÃ³n de mocks y stubs complejos.
D. Automatiza la ejecuciÃ³n de pruebas en diferentes entornos.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Las herramientas de cobertura miden quÃ© partes del cÃ³digo se ejecutan durante las pruebas, permitiendo establecer umbrales mÃ­nimos de cobertura.

ğŸ§  Pregunta 18
Â¿QuÃ© tÃ©cnica de patching en Python permite sustituir un objeto o funciÃ³n solo dentro de un bloque de cÃ³digo especÃ­fico?

A. Decorador @patch.
B. Context manager with patch(...).
C. Fixture con monkeypatch.setattr.
D. create_autospec.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El context manager with patch(...) limita el alcance del parche al bloque de cÃ³digo dentro del with.

ğŸ§  Pregunta 19
Â¿CuÃ¡l es el principal objetivo de utilizar mocks con lÃ³gica dinÃ¡mica implementada a travÃ©s de side_effect en un pipeline de CI/CD?

A. Reducir el tiempo de ejecuciÃ³n de las pruebas unitarias.
B. Simplificar la configuraciÃ³n de los entornos de prueba.
C. Simular comportamientos de dependencias externas de forma realista, incluyendo errores y respuestas secuenciales.
D. Aumentar la cobertura de cÃ³digo sin necesidad de escribir mÃ¡s tests.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: side_effect permite simular escenarios complejos como errores transitorios, paginaciÃ³n o validaciones dinÃ¡micas, aumentando la fiabilidad de las pruebas.

ğŸ§  Pregunta 20
Â¿QuÃ© mÃ©trica DORA podrÃ­a verse afectada positivamente por una estrategia de pruebas bien implementada que incluya el uso efectivo de mocks y stubs?

A. Frecuencia de despliegue.
B. Tiempo de entrega de cambios.
C. Tiempo medio de recuperaciÃ³n de incidentes.
D. Tasa de cambio de fallos.

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: Una buena estrategia de pruebas ayuda a detectar errores tempranamente, lo que deberÃ­a reducir la cantidad de fallos que llegan a producciÃ³n.

ğŸ§  Pregunta 21
Â¿QuÃ© diferencia fundamental existe entre un stub y un mock en cuanto a su uso en las pruebas?

A. Los stubs verifican el comportamiento, mientras que los mocks solo proveen datos.
B. Los mocks verifican las interacciones, mientras que los stubs solo proveen datos predefinidos.
C. Los stubs son mÃ¡s complejos de implementar que los mocks.
D. Los mocks se utilizan en pruebas de integraciÃ³n, mientras que los stubs en pruebas unitarias.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Los mocks se centran en verificar cÃ³mo se interactÃºa con las dependencias, mientras que los stubs simplemente proporcionan respuestas controladas.

ğŸ§  Pregunta 22
Â¿En quÃ© situaciÃ³n serÃ­a mÃ¡s apropiado utilizar un fake en lugar de un mock o un stub?

A. Cuando la dependencia externa es muy compleja y se necesita simular su comportamiento exacto.
B. Cuando solo se necesita proveer una respuesta predefinida sin importar cÃ³mo se interactÃºe con la dependencia.
C. Cuando se quiere verificar que se llama a la dependencia con argumentos especÃ­ficos.
D. Cuando se necesita una implementaciÃ³n simplificada pero funcional de la dependencia para pruebas de integraciÃ³n ligeras.

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: Los fakes son Ãºtiles cuando se necesita mantener cierta lÃ³gica de la dependencia para que las pruebas sean mÃ¡s realistas sin la sobrecarga de la implementaciÃ³n completa.

ğŸ§  Pregunta 23
Â¿QuÃ© ventaja ofrece el uso de mocks en las pruebas unitarias en tÃ©rminos de aislamiento?

A. Asegura que las pruebas se ejecuten en el mismo entorno que producciÃ³n.
B. Permite probar la unidad de cÃ³digo sin depender del estado o comportamiento de sus dependencias externas.
C. Reduce el tiempo necesario para configurar los datos de prueba.
D. Facilita la identificaciÃ³n de cuellos de botella en el rendimiento.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Los mocks aÃ­slan la unidad bajo prueba al simular el comportamiento de sus dependencias, haciendo que la prueba sea mÃ¡s enfocada y menos susceptible a fallos en otros componentes.

ğŸ§  Pregunta 24
Â¿CuÃ¡l de las siguientes describe mejor el propÃ³sito de un spy en las pruebas?

A. Reemplazar una dependencia con una implementaciÃ³n controlada y simplificada.
B. Verificar las interacciones con una dependencia y su estado despuÃ©s de la interacciÃ³n.
C. Proveer datos predefinidos a la unidad bajo prueba.
D. Actuar como un marcador de posiciÃ³n sin ninguna funcionalidad real.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Un spy envuelve un objeto real, permitiendo observar cÃ³mo se interactÃºa con Ã©l y verificar su estado despuÃ©s de la interacciÃ³n.

ğŸ§  Pregunta 25
En el contexto de un pipeline de CI/CD, Â¿cuÃ¡l es el beneficio de ejecutar pruebas unitarias con mocks en las etapas tempranas?

A. Permite detectar problemas de integraciÃ³n con servicios externos antes.
B. Asegura que el cÃ³digo cumpla con los estÃ¡ndares de rendimiento de producciÃ³n.
C. Proporciona una retroalimentaciÃ³n rÃ¡pida a los desarrolladores sobre la salud del cÃ³digo tras cada commit.
D. Valida el despliegue correcto de la aplicaciÃ³n en diferentes entornos.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La rapidez de ejecuciÃ³n de las pruebas unitarias con mocks facilita un feedback loop veloz, crucial para la integraciÃ³n continua.

ğŸ§  Pregunta 26
Â¿CuÃ¡l es una limitaciÃ³n potencial del uso extensivo de mocks en las pruebas unitarias?

A. Puede hacer que las pruebas sean mÃ¡s lentas de ejecutar.
B. Puede llevar a pruebas que no reflejan con precisiÃ³n el comportamiento en un entorno real.
C. Dificulta la verificaciÃ³n de las interacciones entre diferentes componentes del sistema.
D. Requiere una configuraciÃ³n mÃ¡s compleja de los entornos de prueba.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Si los mocks no se configuran correctamente para simular el comportamiento real de las dependencias, las pruebas pueden pasar sin que el cÃ³digo funcione correctamente en un entorno integrado.

ğŸ§  Pregunta 27
Â¿QuÃ© funcionalidad de pytest permite ejecutar el mismo test con diferentes entradas y salidas esperadas?

A. Fixtures.
B. Marks (@pytest.mark).
C. ParametrizaciÃ³n (@pytest.mark.parametrize).
D. Hooks.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La parametrizaciÃ³n es una caracterÃ­stica clave de pytest para ejecutar un test mÃºltiples veces con diferentes conjuntos de datos.

ğŸ§  Pregunta 28
Â¿CÃ³mo ayuda autospec a mejorar la mantenibilidad de las pruebas que utilizan mocks?

A. Automatiza la creaciÃ³n de mocks basados en la documentaciÃ³n de las dependencias.
B. Asegura que los mocks creados coincidan con la firma de las dependencias reales, evitando errores silenciosos.
C. Permite generar mocks con comportamientos aleatorios para probar la robustez del sistema.
D. Facilita la refactorizaciÃ³n del cÃ³digo al proporcionar informaciÃ³n sobre el uso de las dependencias.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Al verificar la compatibilidad de la firma, autospec ayuda a que las pruebas fallen si la interfaz de la dependencia cambia, alertando sobre la necesidad de actualizar los mocks.

ğŸ§  Pregunta 29
Â¿QuÃ© informaciÃ³n se puede inspeccionar utilizando la propiedad call_args_list de un mock?

A. El nÃºmero total de veces que se llamÃ³ al mock.
B. Los argumentos de la Ãºltima llamada al mock.
C. Una lista de todas las llamadas al mock, incluyendo los argumentos posicionales y de palabra clave de cada una.
D. Si el mock lanzÃ³ alguna excepciÃ³n durante su ejecuciÃ³n.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: call_args_list proporciona un historial detallado de cada llamada al mock, con todos los argumentos utilizados.

ğŸ§  Pregunta 30
Â¿En quÃ© escenario serÃ­a mÃ¡s apropiado utilizar el marcador @pytest.mark.xfail en un flujo de CI/CD?

A. Para marcar tests que siempre fallan y deben ignorarse.
B. Para indicar tests que no son relevantes para la funcionalidad actual.
C. Para seÃ±alar tests que se espera que fallen debido a un bug conocido o una funcionalidad incompleta, sin detener el pipeline.
D. Para marcar tests que se ejecutan muy lentamente y deben omitirse en builds rÃ¡pidos.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: @pytest.mark.xfail permite que el pipeline continÃºe incluso si estos tests fallan, pero informa sobre el estado esperado de fallo.

ğŸ§  Pregunta 31
Â¿CuÃ¡l es una buena prÃ¡ctica para gestionar la complejidad de los mocks en las pruebas?

A. Simular todos los posibles comportamientos de la dependencia para asegurar una cobertura completa.
B. Utilizar mocks solo para las dependencias mÃ¡s crÃ­ticas y utilizar objetos reales para las demÃ¡s.
C. Mantener los mocks simples y enfocados en el comportamiento necesario para la prueba especÃ­fica, utilizando fakes o integraciones para escenarios mÃ¡s complejos.
D. Generar mocks automÃ¡ticamente a partir de las definiciones de las interfaces de las dependencias.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Mocks complejos pueden volverse difÃ­ciles de mantener y pueden no reflejar con precisiÃ³n el comportamiento real. Para escenarios complejos, a menudo es mejor usar fakes o realizar pruebas de integraciÃ³n.

ğŸ§  Pregunta 32
Â¿CÃ³mo contribuye una estrategia de pruebas bien definida con mocks y stubs a la filosofÃ­a "Shift-Left" en DevOps?

A. Permite ejecutar pruebas mÃ¡s exhaustivas en las etapas finales del ciclo de desarrollo.
B. Facilita la detecciÃ³n temprana de errores al permitir pruebas rÃ¡pidas y aisladas en las etapas iniciales.
C. Reduce la necesidad de pruebas de integraciÃ³n y de extremo a extremo.
D. Automatiza la generaciÃ³n de documentaciÃ³n de las interfaces de las dependencias.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Al permitir pruebas unitarias rÃ¡pidas y aisladas, los mocks y stubs son fundamentales para la detecciÃ³n temprana de errores, moviendo las pruebas hacia la izquierda del ciclo de desarrollo.

ğŸ§  Pregunta 33
Â¿QuÃ© ventaja ofrece la tÃ©cnica de "patching" en las pruebas con mocks?

A. Permite modificar el comportamiento de objetos o funciones en tiempo de ejecuciÃ³n para simular dependencias.
B. Facilita la creaciÃ³n de mocks que cumplen automÃ¡ticamente con la interfaz de las dependencias.
C. Permite verificar el nÃºmero exacto de llamadas realizadas a una dependencia.
D. Simplifica la configuraciÃ³n de los entornos de prueba al eliminar la necesidad de dependencias reales.

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: Patching permite reemplazar temporalmente objetos o funciones con mocks dentro del alcance de una prueba.

ğŸ§  Pregunta 34
Â¿CuÃ¡l es el beneficio de utilizar fixtures en pytest para la creaciÃ³n de mocks y stubs?

A. Permite definir la configuraciÃ³n de los mocks y stubs de forma declarativa y reutilizable entre tests.
B. Asegura que los mocks y stubs se creen en un orden especÃ­fico antes de cada test.
C. Facilita la ejecuciÃ³n de los mismos tests con diferentes implementaciones de mocks y stubs.
D. Permite la generaciÃ³n automÃ¡tica de mocks y stubs basados en las dependencias del cÃ³digo bajo prueba.

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: Las fixtures en pytest proporcionan una forma elegante y reutilizable de configurar el estado necesario para las pruebas, incluyendo la creaciÃ³n y configuraciÃ³n de mocks y stubs.

ğŸ§  Pregunta 35
Â¿QuÃ© informaciÃ³n proporciona una herramienta de cobertura de cÃ³digo integrada con la ejecuciÃ³n de pruebas que utilizan mocks y stubs?

A. El rendimiento de las pruebas en tÃ©rminos de tiempo de ejecuciÃ³n.
B. La cantidad de cÃ³digo fuente que fue ejecutado por las pruebas.
C. El nÃºmero de interacciones verificadas con los mocks.
D. La complejidad ciclomÃ¡tica del cÃ³digo probado.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Las herramientas de cobertura miden quÃ© lÃ­neas, ramas o funciones del cÃ³digo se ejecutan durante las pruebas, ayudando a identificar Ã¡reas no probadas.

ğŸ§  Pregunta 36
Â¿CÃ³mo puede la lÃ³gica dinÃ¡mica en los mocks, implementada con side_effect, simular errores transitorios en un pipeline de CI/CD?

A. Lanzando una excepciÃ³n solo despuÃ©s de un cierto nÃºmero de llamadas exitosas.
B. Devolviendo un valor de error especÃ­fico en cada llamada al mock.
C. Lanzando una excepciÃ³n en las primeras llamadas y luego devolviendo un valor exitoso para probar la lÃ³gica de reintento.
D. Modificando los argumentos de las llamadas posteriores al mock.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Simular errores transitorios permite probar la resiliencia del sistema ante fallos temporales de las dependencias.

ğŸ§  Pregunta 37
Â¿CuÃ¡l es la principal ventaja de utilizar autospec en relaciÃ³n con el Principio de InversiÃ³n de Dependencias (DIP)?

A. Reduce el acoplamiento al asegurar que el cÃ³digo dependa de abstracciones (interfaces) y que los mocks respeten esas interfaces.
B. Facilita la creaciÃ³n de mocks que pueden ser inyectados en diferentes partes del sistema.
C. Asegura que las dependencias concretas sean fÃ¡cilmente reemplazables en tiempo de ejecuciÃ³n.
D. Permite la creaciÃ³n automÃ¡tica de interfaces a partir de las implementaciones concretas.

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: autospec ayuda a mantener la coherencia con las interfaces reales, promoviendo el DIP al asegurar que las dependencias se simulen correctamente segÃºn esas interfaces.

ğŸ§  Pregunta 38
Â¿QuÃ© tipo de verificaciÃ³n avanzada se puede realizar utilizando el historial de llamadas de un mock (call_args_list)?

A. Verificar que una funciÃ³n fue llamada al menos una vez.
B. Asegurar que la Ãºltima llamada se realizÃ³ con argumentos especÃ­ficos.
C. Validar el orden exacto de las llamadas a diferentes mÃ©todos del mock.
D. Comprobar si alguna llamada al mock lanzÃ³ una excepciÃ³n.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: call_args_list permite inspeccionar la secuencia completa de llamadas, lo que es crucial para validar flujos de control complejos.

ğŸ§  Pregunta 39
Â¿CuÃ¡l es la principal razÃ³n para gestionar las marcas skip y xfail en un flujo de CI/CD?

A. Para eliminar permanentemente los tests que fallan o son irrelevantes.
B. Para evitar que tests con problemas conocidos o dependencias no disponibles bloqueen el pipeline completo, manteniendo la visibilidad sobre su estado.
C. Para priorizar la ejecuciÃ³n de los tests mÃ¡s importantes en cada build.
D. Para generar informes de pruebas mÃ¡s concisos y fÃ¡ciles de entender.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La gestiÃ³n adecuada de skip y xfail permite mantener un pipeline funcional sin ignorar problemas conocidos o dependencias faltantes.

ğŸ§  Pregunta 40
Â¿CuÃ¡l es una recomendaciÃ³n clave para el mantenimiento de mocks y stubs a lo largo del tiempo en un entorno DevOps?

A. Refactorizar los mocks y stubs cada vez que se refactoriza el cÃ³digo bajo prueba.
B. Eliminar todos los mocks y stubs tan pronto como las dependencias reales estÃ©n disponibles en los entornos de prueba.
C. Revisar periÃ³dicamente los mocks y stubs para asegurar su alineaciÃ³n con las interfaces de las dependencias reales y documentar su propÃ³sito.
D. Generar automÃ¡ticamente los mocks y stubs a partir de la documentaciÃ³n de las APIs para reducir el esfuerzo manual.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El mantenimiento regular es crucial para asegurar que los mocks y stubs sigan siendo precisos y Ãºtiles a medida que evoluciona el sistema.

ğŸ§  Pregunta 41
Â¿QuÃ© tipo de doble de prueba es el mÃ¡s simple y se utiliza principalmente para cumplir con las firmas de mÃ©todos sin tener ningÃºn comportamiento real?

A. Stub.
B. Mock.
C. Fake.
D. Dummy.

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: Los dummies son objetos sin funcionalidad que se pasan solo para satisfacer los requisitos de parÃ¡metros.

ğŸ§  Pregunta 42
En un pipeline de CI/CD, Â¿quÃ© ventaja especÃ­fica ofrece la rÃ¡pida ejecuciÃ³n de pruebas unitarias con mocks?

A. Permite realizar pruebas de rendimiento en cada commit.
B. Facilita la obtenciÃ³n de feedback inmediato sobre la integraciÃ³n del cÃ³digo.
C. Asegura que la cobertura de cÃ³digo aumente con cada nueva funcionalidad.
D. Permite la detecciÃ³n temprana de errores lÃ³gicos y de interfaz.

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: La velocidad de las pruebas unitarias con mocks permite a los desarrolladores identificar y corregir problemas rÃ¡pidamente durante el desarrollo.

ğŸ§  Pregunta 43
Â¿QuÃ© caracterÃ­stica de los mocks permite simular diferentes resultados o efectos secundarios en llamadas sucesivas?

A. return_value.
B. assert_called_with().
C. side_effect.
D. call_count.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: side_effect permite definir una secuencia de valores de retorno, excepciones o incluso funciones que se ejecutarÃ¡n en cada llamada al mock.

ğŸ§  Pregunta 44
Â¿CuÃ¡l es el enfoque principal de las pruebas de integraciÃ³n segÃºn la escuela Classical de testing?

A. Aislar cada componente individualmente utilizando mocks.
B. Verificar las interacciones precisas entre componentes utilizando mocks detallados.
C. Probar la interacciÃ³n entre varios componentes reales para asegurar su correcta colaboraciÃ³n.
D. Utilizar implementaciones simplificadas (fakes) de las dependencias externas.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La escuela Classical se centra en probar las integraciones reales para detectar problemas que podrÃ­an no surgir en pruebas aisladas.

ğŸ§  Pregunta 45
Â¿QuÃ© riesgo principal se asocia con el uso excesivo de mocks que no estÃ¡n bien alineados con el comportamiento real de las dependencias?

A. Aumento significativo en el tiempo de ejecuciÃ³n de las pruebas.
B. Dificultad para refactorizar el cÃ³digo debido a las dependencias rÃ­gidas en los mocks.
C. Falsos positivos en las pruebas, donde el cÃ³digo parece funcionar correctamente con los mocks pero falla con las dependencias reales.
D. Mayor complejidad en la configuraciÃ³n y mantenimiento de los entornos de prueba.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Si los mocks no reflejan con precisiÃ³n el comportamiento de las dependencias reales, las pruebas pueden pasar sin detectar problemas que ocurrirÃ­an en un entorno integrado.

ğŸ§  Pregunta 46
Â¿CÃ³mo facilita la parametrizaciÃ³n de tests en pytest la creaciÃ³n de pruebas mÃ¡s robustas?

A. Permite ejecutar pruebas en paralelo en diferentes entornos.
B. Reduce la cantidad de cÃ³digo de prueba necesario para cubrir mÃºltiples escenarios.
C. Asegura que todas las dependencias externas sean mockeadas de manera consistente.
D. Genera automÃ¡ticamente informes de cobertura detallados.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Al permitir probar mÃºltiples entradas y salidas esperadas con el mismo cÃ³digo de prueba, la parametrizaciÃ³n aumenta la cobertura y reduce la redundancia.

ğŸ§  Pregunta 47
Â¿QuÃ© beneficio especÃ­fico aporta autospec al trabajar con mocks en un entorno donde las interfaces de las dependencias cambian con frecuencia?

A. Automatiza la actualizaciÃ³n de los mocks cada vez que cambia la interfaz.
B. Genera alertas en tiempo de compilaciÃ³n si los mocks no coinciden con la interfaz.
C. Ayuda a detectar en tiempo de prueba si las llamadas a los mocks son incompatibles con la interfaz real.
D. Permite crear mocks con comportamientos predefinidos basados en la documentaciÃ³n de la interfaz.

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: autospec ayuda a mantener las pruebas actualizadas al verificar que las interacciones con los mocks sean consistentes con la interfaz real de las dependencias.

ğŸ§  Pregunta 48
Â¿Para quÃ© se utiliza la funciÃ³n call() del mÃ³dulo unittest.mock?

A. Para verificar si un mock fue llamado al menos una vez.
B. Para crear un objeto que representa una llamada especÃ­fica a un mock, Ãºtil para comparar con call_args_list.
C. Para simular la llamada a un mÃ©todo de un mock con argumentos especÃ­ficos.
D. Para obtener el nÃºmero total de veces que se llamÃ³ a un mock con argumentos especÃ­ficos.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: call() se utiliza para crear objetos que representan llamadas especÃ­ficas, lo que facilita la verificaciÃ³n del historial de llamadas de un mock.

ğŸ§  Pregunta 49
Â¿CuÃ¡l es una estrategia recomendada para el mantenimiento de las marcas @pytest.mark.skip y @pytest.mark.xfail en un proyecto a largo plazo?

A. Eliminar todas las marcas tan pronto como el problema subyacente se resuelva.
B. Revisar periÃ³dicamente las marcas para determinar si todavÃ­a son necesarias y actualizarlas o eliminarlas segÃºn sea apropiado.
C. Mantener todas las marcas indefinidamente para tener un registro histÃ³rico de los problemas.
D. Automatizar la adiciÃ³n de marcas basadas en los informes de errores del sistema.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La revisiÃ³n periÃ³dica asegura que las marcas sigan siendo relevantes y que los tests se habiliten nuevamente cuando las condiciones lo permitan.

ğŸ§  Pregunta 50
En el contexto de DevOps, Â¿cÃ³mo contribuye el uso efectivo de mocks y stubs a la entrega continua de software?

A. Permite automatizar el despliegue de software en mÃºltiples entornos.
B. Facilita la integraciÃ³n continua al proporcionar pruebas rÃ¡pidas y confiables que se ejecutan en cada commit.
C. Asegura que el software cumpla con los requisitos de rendimiento en producciÃ³n.
D. Permite la monitorizaciÃ³n en tiempo real del estado de la aplicaciÃ³n desplegada.

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Al hacer que las pruebas sean rÃ¡pidas y aisladas, los mocks y stubs son esenciales para un flujo de integraciÃ³n continua eficiente y confiable.