ğŸ§  Pregunta 1

Â¿CuÃ¡l es el principal desafÃ­o que surge al utilizar mÃºltiples ramas de cÃ³digo fuente y que los patrones presentados buscan mitigar?

A. La dificultad de realizar un seguimiento de los cambios individuales.

B. La necesidad de elegir un sistema de control de versiones adecuado.

C. La complejidad de fusionar las ramas de nuevo en un todo coherente.

D. La ineficiencia en la creaciÃ³n de nuevas ramas para cada tarea.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El artÃ­culo destaca que, si bien la creaciÃ³n de ramas es sencilla, la fusiÃ³n posterior puede generar complicaciones y consumir mucho tiempo de los equipos.

ğŸ§  Pregunta 2

SegÃºn el artÃ­culo, Â¿cuÃ¡l es el objetivo central de los patrones para la gestiÃ³n de ramas de cÃ³digo fuente?

A. Optimizar el rendimiento de los sistemas de control de versiones.

B. Facilitar la colaboraciÃ³n entre diseÃ±adores y desarrolladores.

C. Integrar el trabajo de mÃºltiples desarrolladores y organizar la ruta hacia las versiones de producciÃ³n.

D. Reducir la cantidad de cÃ³digo fuente necesario para un proyecto.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El autor enfatiza que los patrones buscan ayudar a los equipos a trabajar juntos de manera efectiva y a tener un camino claro para llevar el software a producciÃ³n.

ğŸ§  Pregunta 3

Â¿CÃ³mo define Martin Fowler el tÃ©rmino "rama" en el contexto de este artÃ­culo?

A. Una copia aislada del cÃ³digo base utilizada por un desarrollador individual.

B. Una etiqueta utilizada para marcar un punto especÃ­fico en la historia del cÃ³digo.

C. Una secuencia particular de commits en el cÃ³digo base.

D. Una bifurcaciÃ³n del repositorio principal para experimentar con nuevas funcionalidades.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: Fowler define una rama como una lÃ­nea de tiempo especÃ­fica de cambios registrados (commits) en el cÃ³digo.

ğŸ§  Pregunta 4

Â¿QuÃ© problema principal busca resolver la prÃ¡ctica de la "ramificaciÃ³n del cÃ³digo fuente"?

A. Evitar la pÃ©rdida de cambios realizados por los desarrolladores.

B. Permitir que mÃºltiples desarrolladores trabajen en el mismo cÃ³digo base simultÃ¡neamente sin interferir entre sÃ­.

C. Facilitar la auditorÃ­a de los cambios realizados en el cÃ³digo a lo largo del tiempo.

D. Optimizar el espacio de almacenamiento requerido por el sistema de control de versiones.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La ramificaciÃ³n permite el trabajo en paralelo al proporcionar copias aisladas del cÃ³digo para cada desarrollador.

ğŸ§  Pregunta 5

Â¿QuÃ© se entiende por un "conflicto semÃ¡ntico" en el contexto de la fusiÃ³n de ramas?

A. Un conflicto donde el sistema de control de versiones no puede combinar automÃ¡ticamente cambios en el mismo archivo.

B. Un conflicto donde el cÃ³digo se fusiona sin problemas textuales, pero el sistema resultante no funciona correctamente.

C. Un conflicto causado por diferentes estilos de codificaciÃ³n entre los desarrolladores.

D. Un conflicto que surge al intentar fusionar ramas con un historial de commits muy diferente.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Los conflictos semÃ¡nticos son problemas lÃ³gicos que no son detectados por las herramientas de fusiÃ³n textual.

ğŸ§  Pregunta 6

Â¿CuÃ¡l es la funciÃ³n principal de la "mainline" (lÃ­nea principal) en un flujo de trabajo de gestiÃ³n de ramas?

A. Servir como una rama aislada para el desarrollo de nuevas funcionalidades importantes.

B. Actuar como el estado actual y compartido del cÃ³digo del producto.

C. Almacenar las versiones histÃ³ricas del cÃ³digo base para futuras referencias.

D. Facilitar la creaciÃ³n de ramas de lanzamiento para diferentes versiones del producto.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La mainline representa la versiÃ³n actual del proyecto en la que se basa el trabajo del equipo.

ğŸ§  Pregunta 7

Â¿QuÃ© significa mantener una "healthy branch" (rama saludable)?

A. Asegurar que la rama tenga la menor cantidad de commits posible.

B. Garantizar que la rama se compile con Ã©xito y el software se ejecute con pocos o ningÃºn error en cada commit.

C. Limitar el nÃºmero de desarrolladores que pueden realizar commits en la rama.

D. Realizar revisiones de cÃ³digo exhaustivas antes de permitir cualquier commit en la rama.

âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Una rama saludable se caracteriza por pasar las pruebas automatizadas en cada commit, asegurando su estabilidad.

ğŸ§  Pregunta 8

Â¿QuÃ© se entiende por "self testing code" (cÃ³digo con autoevaluaciÃ³n) y por quÃ© es crucial para mantener una "healthy branch"?

A. CÃ³digo que incluye documentaciÃ³n detallada para facilitar su comprensiÃ³n.

B. CÃ³digo que contiene mecanismos para detectar y reportar errores en tiempo de ejecuciÃ³n.

C. CÃ³digo acompaÃ±ado de una suite completa de pruebas automatizadas para verificar su correcto funcionamiento.

D. CÃ³digo que se adhiere estrictamente a los estÃ¡ndares de codificaciÃ³n del equipo.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El cÃ³digo con autoevaluaciÃ³n permite verificar automÃ¡ticamente la ausencia de errores mediante pruebas.

ğŸ§  Pregunta 9

Â¿QuÃ© es una "commit suite" y cuÃ¡l es su objetivo principal en el contexto de una "healthy branch"?

A. Un conjunto de herramientas utilizadas para gestionar los commits en un sistema de control de versiones.

B. Una secuencia de commits relacionados que implementan una funcionalidad especÃ­fica.

C. Una suite de pruebas automatizadas que se ejecuta con cada commit para asegurar la salud de la rama.

D. Un registro detallado de todos los commits realizados en una rama, incluyendo el autor y la fecha.

âœ… Correcta: C
ğŸ§  Pregunta 21

Â¿CuÃ¡l es la tensiÃ³n que se menciona en el artÃ­culo con respecto a las ramas de desarrollo personal y la prÃ¡ctica de mantenerlas saludables?
A. La necesidad de elegir entre usar Git o Mercurial como sistema de control de versiones.

B. El equilibrio entre realizar commits frecuentes para guardar el progreso y asegurarse de que cada commit sea funcional.

C. La dificultad de coordinar el trabajo entre desarrolladores que prefieren diferentes estilos de codificaciÃ³n.

D. El conflicto entre la necesidad de realizar pruebas unitarias rÃ¡pidas y pruebas de integraciÃ³n mÃ¡s exhaustivas.
âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Existe una tensiÃ³n entre la conveniencia de hacer commits frecuentes como puntos de control y el deseo de mantener la rama en un estado siempre funcional.

ğŸ§  Pregunta 22

Â¿QuÃ© se implica cuando el artÃ­culo menciona que una "mainline saludable" allana el camino hacia la producciÃ³n?
A. Que el cÃ³digo en la mainline siempre estÃ¡ listo para ser desplegado directamente a los usuarios finales.

B. Que se requiere un esfuerzo mÃ­nimo para estabilizar una versiÃ³n de lanzamiento a partir de la mainline.

C. Que el proceso de despliegue a producciÃ³n puede automatizarse completamente.

D. Que los errores crÃ­ticos se detectan y corrigen automÃ¡ticamente en la mainline.
âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Una mainline estable significa que la base de cÃ³digo para un lanzamiento es sÃ³lida y requiere poca preparaciÃ³n adicional.

ğŸ§  Pregunta 23

Â¿QuÃ© se considera una inversiÃ³n significativa pero crucial para lograr y mantener una "mainline saludable"?
A. La implementaciÃ³n de un sistema de gestiÃ³n de proyectos Ã¡gil.

B. La adopciÃ³n de revisiones de cÃ³digo obligatorias para todos los commits.

C. La construcciÃ³n de "self testing code" con una "commit suite" rÃ¡pida.

D. La capacitaciÃ³n exhaustiva de todos los desarrolladores en el uso del sistema de control de versiones.
âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: La capacidad de verificar rÃ¡pidamente la integridad del cÃ³digo con pruebas automatizadas es fundamental para una mainline saludable.

ğŸ§  Pregunta 24

Â¿QuÃ© se sugiere como una forma de resolver la tensiÃ³n entre los commits frecuentes y la salud de una rama de desarrollo personal?
A. Realizar pruebas exhaustivas solo antes de fusionar con la mainline.

B. Utilizar ramas separadas para diferentes tipos de cambios (funcionales vs. correcciones).

C. Eliminar (squash) los commits no saludables al finalizar el trabajo inmediato.

D. Limitar el tamaÃ±o de los commits individuales para reducir el riesgo de introducir errores.
âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El "squashing" permite tener puntos de control frecuentes sin comprometer la limpieza y salud del historial de la rama a largo plazo.

ğŸ§  Pregunta 25

Â¿CuÃ¡l es el beneficio principal de saber que cualquier error surgido al integrar una rama personal saludable a la mainline probablemente se deba a problemas de integraciÃ³n?
A. Permite delegar la responsabilidad de la depuraciÃ³n a otros miembros del equipo.

B. Simplifica significativamente el proceso de diagnÃ³stico y correcciÃ³n de errores.

C. Reduce la necesidad de realizar pruebas de regresiÃ³n despuÃ©s de la integraciÃ³n.

D. Acelera el proceso de lanzamiento al evitar la introducciÃ³n de nuevos errores.
âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: Aislar la fuente potencial de los errores facilita la identificaciÃ³n y soluciÃ³n de los problemas durante la integraciÃ³n.

ğŸ§  Pregunta 26

SegÃºn el artÃ­culo, Â¿quÃ© factor contextual influye significativamente en el flujo de trabajo de desarrollo de software y en la elecciÃ³n de patrones de branching?
A. El tamaÃ±o del cÃ³digo base del proyecto.

B. La experiencia tÃ©cnica de los miembros del equipo.

C. La estructura social del equipo y las demÃ¡s prÃ¡cticas que Ã©ste sigue.

D. El tipo de licencia de software utilizado para el proyecto.
âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El contexto del equipo, incluyendo su organizaciÃ³n y prÃ¡cticas, es un factor clave en la aplicaciÃ³n de los patrones.

ğŸ§  Pregunta 27

Â¿Por quÃ© el autor menciona la historia del ingeniero de compilaciones a principios de los 2000?
A. Para ilustrar la eficiencia de las prÃ¡cticas de construcciÃ³n de software en el pasado.

B. Para destacar los desafÃ­os de la integraciÃ³n de cÃ³digo antes de la adopciÃ³n generalizada de la mainline.

C. Para comparar diferentes sistemas de control de versiones utilizados en esa Ã©poca.

D. Para enfatizar la importancia de la comunicaciÃ³n interpersonal en los equipos de desarrollo.
âœ… Correcta: B

ğŸ§¾ ExplicaciÃ³n: La anÃ©cdota sirve como un contraste con los beneficios de tener una mainline bien establecida.

ğŸ§  Pregunta 28

Â¿QuÃ© se entiende por "diff debugging" y cÃ³mo se relaciona con mantener saludables las ramas de desarrollo personal?
A. Una tÃ©cnica para comparar diferentes versiones de cÃ³digo y encontrar la causa de los errores, facilitada por un cÃ³digo base limpio y funcional.

B. El proceso de depurar el cÃ³digo directamente en el entorno de producciÃ³n comparando el comportamiento con el entorno de desarrollo.

C. Una metodologÃ­a para identificar y corregir errores comparando los registros de diferentes ramas del repositorio.

D. La prÃ¡ctica de solicitar a otro desarrollador que revise las diferencias en el cÃ³digo para encontrar posibles errores.
âœ… Correcta: A

ğŸ§¾ ExplicaciÃ³n: Mantener una rama personal saludable facilita la identificaciÃ³n de la causa de los errores al comparar versiones, ya que se reduce la posibilidad de que los errores provengan del propio trabajo reciente.

ğŸ§  Pregunta 29

Â¿CuÃ¡l es la implicaciÃ³n de que los sistemas de control de versiones registren cada cambio como un commit?
A. Asegura que todos los desarrolladores sigan los mismos estÃ¡ndares de codificaciÃ³n.

B. Simplifica el proceso de reversiÃ³n a versiones anteriores del cÃ³digo base.

C. Facilita la fusiÃ³n de cambios al proporcionar un historial detallado de las modificaciones.

D. Reduce la posibilidad de conflictos al limitar la ediciÃ³n simultÃ¡nea del mismo archivo.
âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: El registro de cada cambio como un commit proporciona la informaciÃ³n necesaria para que el sistema de control de versiones intente fusionar las ramas de manera inteligente.

ğŸ§  Pregunta 30

Â¿QuÃ© se menciona como un problema comÃºn que puede surgir incluso cuando el sistema de control de versiones puede fusionar el texto del cÃ³digo sin conflictos?
A. Problemas de rendimiento debido a la gran cantidad de commits fusionados.

B. Incompatibilidad de licencias entre el cÃ³digo de diferentes ramas.

C. Conflictos semÃ¡nticos donde el sistema integrado no funciona correctamente a pesar de la fusiÃ³n exitosa.

D. Dificultad para rastrear la autorÃ­a de los cambios despuÃ©s de la fusiÃ³n.
âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: Los conflictos semÃ¡nticos son aquellos donde la lÃ³gica del cÃ³digo se rompe aunque la fusiÃ³n textual sea exitosa.

ğŸ§¾ ExplicaciÃ³n: La commit suite es un conjunto de pruebas rÃ¡pidas que validan la integridad del cÃ³digo en cada commit.

ğŸ§  Pregunta 10

SegÃºn el artÃ­culo, Â¿cuÃ¡l es uno de los beneficios clave de mantener una "mainline" saludable?

A. Reduce la necesidad de realizar pruebas exhaustivas en las ramas de desarrollo personal.

B. Permite a los desarrolladores trabajar en paralelo sin necesidad de fusionar su cÃ³digo.

C. Facilita la creaciÃ³n rÃ¡pida de candidatos para producciÃ³n con poco trabajo de estabilizaciÃ³n.

D. Elimina la posibilidad de conflictos semÃ¡nticos durante la integraciÃ³n de ramas.

âœ… Correcta: C

ğŸ§¾ ExplicaciÃ³n: Una mainline estable permite generar versiones de lanzamiento de manera mÃ¡s eficiente.

ğŸ§  Pregunta 1
Â¿CuÃ¡l es la recomendaciÃ³n principal de Martin Fowler respecto al uso de ramas en proyectos de desarrollo?

A. Crear muchas ramas largas para cada funcionalidad
B. Usar ramas solo en producciÃ³n
C. Integrar ramas con frecuencia para mantener una lÃ­nea principal saludable
D. Evitar las ramas y trabajar directamente en el cÃ³digo compartido

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Fowler enfatiza que las ramas deben integrarse con frecuencia, enfocÃ¡ndose en mantener una lÃ­nea principal estable y fÃ¡cil de desplegar.

ğŸ§  Pregunta 2
Â¿QuÃ© define Martin Fowler como una rama (branch)?

A. Un archivo de configuraciÃ³n para la versiÃ³n
B. Una copia del cÃ³digo con cambios temporales
C. Una secuencia particular de commits en el cÃ³digo base
D. Una carpeta local aislada

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: SegÃºn Fowler, una rama es una secuencia especÃ­fica de commits, con su head siendo el commit mÃ¡s reciente.

ğŸ§  Pregunta 3
Â¿QuÃ© tipo de conflicto puede ocurrir aunque no haya errores de fusiÃ³n textual?

A. Conflicto de versiones
B. Conflicto semÃ¡ntico
C. Conflicto de etiquetas
D. Conflicto de tags

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Los conflictos semÃ¡nticos ocurren cuando el cÃ³digo se fusiona correctamente a nivel textual, pero falla al compilar o ejecutar debido a cambios incompatibles en lÃ³gica.

ğŸ§  Pregunta 4
Â¿QuÃ© nombre se le da a la rama central compartida que representa el estado actual del producto?

A. Feature
B. Develop
C. Mainline
D. Tag

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La mainline (lÃ­nea principal) es la rama especial compartida que refleja el estado actual y base del producto.

ğŸ§  Pregunta 5
Â¿QuÃ© prÃ¡ctica permite mantener una â€œrama saludableâ€?

A. Desactivar pruebas automÃ¡ticas
B. Fusionar cambios sin revisiÃ³n
C. Ejecutar pruebas automatizadas con cada commit
D. Hacer commits directamente en producciÃ³n

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Mantener una rama saludable implica que cada commit dispare pruebas automatizadas para asegurar que el cÃ³digo sigue funcionando correctamente.

ğŸ§  Pregunta 6
Â¿QuÃ© es una commit suite segÃºn el artÃ­culo?

A. Un conjunto de ramas de trabajo
B. Un conjunto rÃ¡pido de pruebas ejecutadas en cada commit
C. Un historial de merges exitosos
D. Una colecciÃ³n de archivos de configuraciÃ³n

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La commit suite es un conjunto de pruebas automatizadas que se ejecuta rÃ¡pidamente tras cada commit para validar el estado del cÃ³digo.

ğŸ§  Pregunta 7
Â¿QuÃ© recomendaciÃ³n hace Fowler respecto a commits no saludables en ramas personales?

A. Mantenerlos como historial de errores
B. Borrarlos si fallan
C. Hacer squash de commits no saludables antes de fusionar
D. Dejarlos visibles para revisiÃ³n futura

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Para mantener limpias las ramas personales, Fowler recomienda hacer squash de commits no saludables una vez terminado el trabajo.

ğŸ§  Pregunta 8
Â¿CuÃ¡l es el beneficio principal de tener una mainline saludable?

A. Mayor complejidad en integraciÃ³n
B. Mayor nÃºmero de ramas
C. Iniciar nuevas tareas sin lidiar con errores anteriores
D. ReducciÃ³n en el nÃºmero de commits

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Si la mainline estÃ¡ en buen estado, los desarrolladores pueden comenzar nuevas tareas sin ser bloqueados por defectos existentes.

ğŸ§  Pregunta 9
Â¿QuÃ© concepto se propone como alternativa mÃ¡s neutral al tÃ©rmino "rama"?

A. Codeline
B. Fork
C. Snapshot
D. Version stream

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: Fowler sugiere el tÃ©rmino codeline como una forma mÃ¡s general y menos ambigua para referirse a secuencias de versiones del cÃ³digo.

ğŸ§  Pregunta 10
Â¿Por quÃ© es problemÃ¡tico que cada desarrollador tenga su propia versiÃ³n local de "master" en Git?

A. No permite crear tags
B. Confunde el control de versiones
C. Genera mÃºltiples ramas con el mismo nombre pero diferentes contenidos
D. Impide el uso de merge

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Aunque todos usen la rama "master", cada clon de Git mantiene su propia versiÃ³n, lo que genera ramas separadas con el mismo nombre.

ğŸ§  Pregunta 11
Â¿CuÃ¡l es el mayor riesgo de tener muchas ramas activas sin una integraciÃ³n frecuente?

A. Aumenta el consumo de memoria del sistema
B. Se pierde la trazabilidad de los commits
C. Se incrementa la posibilidad de conflictos complejos al fusionar
D. Las pruebas automatizadas dejan de funcionar

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Cuando varias ramas permanecen mucho tiempo sin integrarse, es mÃ¡s probable que los cambios diverjan tanto que la fusiÃ³n requiera una intervenciÃ³n humana compleja, especialmente por conflictos semÃ¡nticos difÃ­ciles de detectar automÃ¡ticamente.

ğŸ§  Pregunta 12
Â¿QuÃ© representa el head o tip de una rama en el control de versiones?

A. El commit inicial donde se creÃ³ la rama
B. La rama base desde donde se originÃ³
C. El commit mÃ¡s reciente de la secuencia
D. El nombre simbÃ³lico de la rama

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: En Git y en otros sistemas de control de versiones, el head o tip representa el Ãºltimo commit en una rama, es decir, el punto mÃ¡s avanzado en esa lÃ­nea de desarrollo.

ğŸ§  Pregunta 13
Â¿CuÃ¡l es el objetivo principal de tener una mainline (lÃ­nea principal) saludable?

A. Permitir que cada desarrollador tenga su rama privada sin supervisiÃ³n
B. Garantizar que siempre haya una base estable desde la cual trabajar o desplegar
C. Eliminar la necesidad de hacer pruebas
D. Impedir que se creen ramas secundarias

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Una mainline saludable actÃºa como una base sÃ³lida y confiable del cÃ³digo. Permite que cualquier desarrollador extraiga una versiÃ³n funcional y tambiÃ©n facilita lanzar nuevas versiones a producciÃ³n sin necesidad de estabilizaciÃ³n adicional.

ğŸ§  Pregunta 14
Â¿QuÃ© tipo de conflicto ocurre cuando dos desarrolladores modifican la misma funciÃ³n, pero el sistema no detecta errores al fusionar el texto?

A. Conflicto de etiquetas
B. Conflicto semÃ¡ntico
C. Conflicto sintÃ¡ctico
D. Conflicto de compilaciÃ³n

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El conflicto semÃ¡ntico ocurre cuando las modificaciones no generan errores de sintaxis ni de fusiÃ³n textual, pero el comportamiento del sistema cambia o se rompe porque las intenciones de los desarrolladores eran distintas.

ğŸ§  Pregunta 15
Â¿Por quÃ© Martin Fowler recomienda tener una commit suite rÃ¡pida y efectiva?

A. Para reducir el nÃºmero de ramas necesarias
B. Para verificar que cada commit mantiene la estabilidad del sistema
C. Para evitar usar sistemas de integraciÃ³n continua
D. Para controlar las versiones en paralelo

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La commit suite es un conjunto de pruebas automatizadas que se ejecuta con cada commit. Su funciÃ³n es proporcionar una validaciÃ³n rÃ¡pida de que el cÃ³digo sigue funcionando y no introduce regresiones.

ğŸ§  Pregunta 16
Â¿QuÃ© estrategia sugiere Fowler para gestionar commits intermedios que podrÃ­an no compilar en ramas personales?

A. Eliminar todos los commits antiguos
B. Dejar los commits con errores como referencia
C. Usar squash para consolidarlos una vez finalizada la funcionalidad
D. Subirlos directamente a mainline

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Para evitar que errores transitorios queden registrados, Fowler recomienda hacer squash de los commits no saludables antes de compartir la rama. Esto mantiene el historial limpio y evita confusiones al integrarse con la mainline.

ğŸ§  Pregunta 17
Â¿CuÃ¡l es el principal desafÃ­o al fusionar ramas en sistemas distribuidos como Git?

A. Sincronizar los archivos .gitignore
B. Resolver correctamente los conflictos semÃ¡nticos
C. Subir las ramas al servidor central
D. Mantener el historial visual limpio

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Aunque los conflictos textuales se pueden resolver automÃ¡ticamente en muchos casos, los conflictos semÃ¡nticos (que afectan el comportamiento) no pueden detectarse automÃ¡ticamente y requieren anÃ¡lisis y resoluciÃ³n manual.

ğŸ§  Pregunta 18
Â¿Por quÃ© Martin Fowler considera Ãºtil el tÃ©rmino codeline?

A. Porque se usa Ãºnicamente en Git
B. Porque reemplaza completamente al concepto de rama
C. Porque evita confusiones entre diferentes sistemas de control de versiones
D. Porque describe ramas con commits invÃ¡lidos

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El tÃ©rmino codeline es mÃ¡s genÃ©rico y evita malentendidos entre herramientas como Git, Mercurial o Subversion, que manejan el concepto de "rama" de formas distintas.

ğŸ§  Pregunta 19
Â¿QuÃ© caracterÃ­stica hace que la rama mainline sea diferente de otras ramas?

A. No se permite hacer commits en ella
B. Es una copia temporal de otra rama
C. Es el punto de referencia comÃºn y compartido por todo el equipo
D. Tiene un nombre fijo en todos los repositorios

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La mainline es la rama compartida donde se concentra el trabajo consolidado del equipo. Representa el estado actual del producto y debe mantenerse estable.

ğŸ§  Pregunta 20
Â¿CuÃ¡l es el impacto de una lÃ­nea principal no saludable segÃºn Fowler?

A. Permite mÃ¡s experimentaciÃ³n
B. Mejora la visibilidad de errores
C. Ralentiza el inicio de nuevas tareas y entorpece la integraciÃ³n
D. Aumenta la velocidad de integraciÃ³n

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Una mainline con errores obliga a los desarrolladores a perder tiempo solucionando problemas antes de poder trabajar, lo que entorpece el desarrollo Ã¡gil y la entrega continua.

ğŸ§  Pregunta 21
SegÃºn Martin Fowler, Â¿cuÃ¡l es la principal dificultad asociada al uso de ramas en el desarrollo de software?

A. Crear ramas con nombres descriptivos
B. Eliminar ramas obsoletas del repositorio
C. La complejidad de fusionarlas correctamente
D. La imposibilidad de trabajar sin conexiÃ³n

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Fowler seÃ±ala que ramificar es fÃ¡cil, pero fusionar es la parte difÃ­cil, especialmente cuando aparecen conflictos semÃ¡nticos que no son detectados automÃ¡ticamente.

ğŸ§  Pregunta 22
Â¿QuÃ© ocurre cuando dos desarrolladores cambian el nombre de una misma variable a valores distintos en sus ramas?

A. El sistema de control de versiones elige un nombre automÃ¡ticamente
B. Se genera un conflicto semÃ¡ntico
C. Se genera un conflicto textual que debe resolverse manualmente
D. Las ramas se sincronizan sin problemas

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: En este caso, se produce un conflicto textual, ya que el mismo fragmento de cÃ³digo ha sido modificado de forma distinta en ambas ramas. El sistema de control de versiones detecta esta colisiÃ³n y solicita intervenciÃ³n humana.

ğŸ§  Pregunta 23
Â¿QuÃ© es un conflicto semÃ¡ntico segÃºn Fowler?

A. Cuando un archivo tiene mÃºltiples versiones
B. Cuando el cÃ³digo compila, pero falla en ejecuciÃ³n debido a cambios lÃ³gicos incompatibles
C. Cuando una rama no tiene permisos de escritura
D. Cuando los commits no se muestran en el historial

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Un conflicto semÃ¡ntico ocurre cuando las fusiones no fallan sintÃ¡cticamente, pero el sistema no funciona correctamente debido a diferencias lÃ³gicas en los cambios combinados.

ğŸ§  Pregunta 24
Â¿CuÃ¡l es el rol de un repositorio central en una estrategia basada en mainline?

A. Actuar como backup
B. Gestionar los permisos de los usuarios
C. Servir como fuente Ãºnica de verdad para la lÃ­nea principal
D. Aislar los cambios individuales de cada desarrollador

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El repositorio central actÃºa como el punto de referencia para la mainline, donde se consolidan los cambios y se garantiza que el equipo trabaje con una versiÃ³n estable y actualizada del proyecto.

ğŸ§  Pregunta 25
Â¿QuÃ© prÃ¡ctica se recomienda para mantener la mainline saludable?

A. Permitir commits sin validaciÃ³n
B. Usar herramientas de integraciÃ³n continua con pruebas automatizadas
C. Fusionar cambios directamente desde cualquier rama
D. Aceptar commits con errores temporales

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Mantener la mainline saludable implica ejecutar pruebas automatizadas en cada commit. Esto ayuda a detectar errores rÃ¡pidamente y asegurar que el cÃ³digo base se mantenga funcional.

ğŸ§  Pregunta 26
Â¿QuÃ© ventaja brinda el uso de self-testing code en un equipo de desarrollo?

A. Acelera la escritura de nuevas funcionalidades
B. Elimina la necesidad de code reviews
C. Garantiza que los errores se detecten inmediatamente despuÃ©s del commit
D. Permite evitar el uso de ramas

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El self-testing code permite que el cÃ³digo se valide automÃ¡ticamente con pruebas. Esto da confianza de que los cambios no han roto funcionalidades existentes, lo cual es esencial para mantener la rama saludable.

ğŸ§  Pregunta 27
Â¿QuÃ© significa "congelar" una rama?

A. Hacer que solo se puedan leer los archivos
B. Crear una etiqueta en el Ãºltimo commit
C. Suspender temporalmente los commits hasta resolver un problema crÃ­tico
D. Eliminar la posibilidad de hacer squash

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Congelar una rama es una prÃ¡ctica temporal en la que no se permiten nuevos commits, salvo aquellos que corrigen fallos crÃ­ticos, con el objetivo de restaurar su salud.

ğŸ§  Pregunta 28
Â¿QuÃ© describe mejor el objetivo de la commit suite?

A. Recolectar estadÃ­sticas sobre el repositorio
B. Ejecutar pruebas unitarias bÃ¡sicas de forma rÃ¡pida en cada commit
C. Generar informes de documentaciÃ³n tÃ©cnica
D. Automatizar la creaciÃ³n de ramas

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La commit suite es un conjunto de pruebas diseÃ±adas para ejecutarse rÃ¡pidamente tras cada commit y proporcionar una validaciÃ³n inmediata del estado funcional del cÃ³digo.

ğŸ§  Pregunta 29
Â¿QuÃ© ventaja ofrece mantener saludable una rama de desarrollo personal antes de integrarla a la mainline?

A. Evita usar comandos como merge o rebase
B. Acelera el proceso de integraciÃ³n al descartar errores propios
C. Elimina la necesidad de squash
D. Permite subir directamente a producciÃ³n

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Si la rama personal ya es saludable, cualquier error tras fusionarla con la mainline proviene de la integraciÃ³n, no del cÃ³digo propio, lo que facilita identificar y resolver problemas rÃ¡pidamente.

ğŸ§  Pregunta 30
Â¿CuÃ¡l es una consecuencia de permitir commits fallidos en la mainline?

A. Mayor innovaciÃ³n en el equipo
B. Menor dependencia de las herramientas de CI
C. Dificulta que otros desarrolladores comiencen nuevas tareas
D. Se evita la necesidad de revertir cambios

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Si la mainline contiene errores, otros desarrolladores tendrÃ¡n problemas al intentar basarse en ella para nuevas tareas, ya que heredarÃ­an un entorno defectuoso.

ğŸ§  Pregunta 31
SegÃºn Fowler, Â¿quÃ© problema se busca evitar al dar a cada desarrollador su propia copia del cÃ³digo base?

A. Tener mÃºltiples copias del mismo archivo
B. Que los cambios a medio hacer de un desarrollador interfieran con otros
C. Que se pierdan los commits antiguos
D. La duplicaciÃ³n de variables en el repositorio

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Dar a cada desarrollador su propia copia evita que cambios incompletos de uno afecten el trabajo del otro, como una compilaciÃ³n fallida debido a cÃ³digo en progreso.

ğŸ§  Pregunta 32
Â¿QuÃ© ventaja clave ofrecen los sistemas de control de versiones modernos segÃºn Fowler?

A. Permiten eliminar ramas antiguas automÃ¡ticamente
B. Registran cada cambio y facilitan la fusiÃ³n
C. Resuelven todos los conflictos semÃ¡nticos sin intervenciÃ³n humana
D. Eliminen la necesidad de branches locales

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Los sistemas modernos como Git registran los cambios como commits, lo que hace posible rastrear versiones y facilita la fusiÃ³n del trabajo de varios desarrolladores.

ğŸ§  Pregunta 33
Â¿CuÃ¡l es la definiciÃ³n mÃ¡s Ãºtil de branch en el contexto del artÃ­culo?

A. Una copia local del repositorio
B. Una etiqueta que identifica un cambio importante
C. Una secuencia de commits que representa una lÃ­nea de trabajo
D. Un fork del repositorio original

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Fowler define una rama como una secuencia especÃ­fica de commits. Esta definiciÃ³n es mÃ¡s general y Ãºtil que la que varÃ­a segÃºn el sistema de control de versiones.

ğŸ§  Pregunta 34
Â¿Por quÃ© el tÃ©rmino codeline puede ser preferido sobre branch?

A. Porque es exclusivo de Git
B. Porque representa cualquier conjunto de versiones, sin importar su origen
C. Porque es mÃ¡s tÃ©cnico y especializado
D. Porque es compatible solo con Subversion

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El tÃ©rmino codeline evita confusiones entre herramientas y se refiere a cualquier secuencia de versiones del cÃ³digo base, incluso si no existe una rama explÃ­cita.

ğŸ§  Pregunta 35
Â¿QuÃ© significa que cada desarrollador tenga su propia codeline?

A. Que puede modificar el sistema sin pruebas
B. Que tiene un entorno controlado y separado mientras desarrolla
C. Que no necesita hacer commits
D. Que todos trabajan en la misma copia de master

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Cada desarrollador, al modificar su copia local del cÃ³digo, crea una codeline independiente que puede integrar mÃ¡s adelante, lo que permite desarrollar sin interferencias.

ğŸ§  Pregunta 36
Â¿CuÃ¡l es una situaciÃ³n donde un sistema de control de versiones no puede detectar un conflicto?

A. Cuando hay cambios en el mismo archivo
B. Cuando dos ramas cambian el mismo nombre de variable
C. Cuando los cambios afectan la lÃ³gica del programa, pero no el texto
D. Cuando se cambian comentarios

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Este es un conflicto semÃ¡ntico, donde el texto puede fusionarse correctamente, pero la lÃ³gica o funcionalidad del sistema se ve comprometida.

ğŸ§  Pregunta 37
Â¿QuÃ© representa el grÃ¡fico de â€œsplit-and-mergeâ€ en el artÃ­culo?

A. CÃ³mo se reinician los commits de una rama
B. CÃ³mo se etiquetan versiones
C. El proceso de ramificar una codeline y luego fusionarla
D. El historial de errores de compilaciÃ³n

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La figura muestra cÃ³mo una rama puede dividirse y luego sus commits combinarse nuevamente a la rama original mediante una fusiÃ³n.

ğŸ§  Pregunta 38
Â¿QuÃ© sucede si Scarlett clona su repositorio local a su laptop?

A. Se sobrescribe el master
B. Se pierde el historial
C. Se crea una nueva codeline del master local
D. Se borra el master del repositorio remoto

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Al clonar localmente, incluso desde su propio repositorio, se genera una nueva codeline basada en la copia existente, con su propio estado y commits.

ğŸ§  Pregunta 39
Â¿Por quÃ© la fusiÃ³n puede fallar incluso si no hay conflictos visibles?

A. Porque el sistema tiene un bug
B. Porque los archivos estÃ¡n corruptos
C. Porque existen conflictos semÃ¡nticos no detectados por el sistema
D. Porque no hay suficiente memoria

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: La ausencia de errores en la fusiÃ³n textual no garantiza que el sistema funcione correctamente, ya que pueden persistir conflictos en la lÃ³gica del cÃ³digo.

ğŸ§  Pregunta 40
Â¿CuÃ¡l es una estrategia para mitigar los problemas de integraciÃ³n compleja?

A. Esperar hasta tener muchas funcionalidades listas antes de integrar
B. Trabajar siempre directamente sobre la mainline
C. Integrar cambios con frecuencia
D. Desactivar los tests para evitar errores

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Integrar frecuentemente reduce la complejidad de las fusiones y minimiza la posibilidad de conflictos complejos o semÃ¡nticos acumulados.

ğŸ§  Pregunta 41
Â¿QuÃ© problema seÃ±ala Fowler respecto a las compilaciones diarias?

A. Que eran demasiado rÃ¡pidas
B. Que requerÃ­an herramientas costosas
C. Que no siempre eran exitosas ni Ãºtiles
D. Que solo podÃ­an realizarse en servidores Linux

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Fowler critica la visiÃ³n romÃ¡ntica de las compilaciones diarias y aclara que en muchos equipos estas compilaciones fallaban durante semanas, lo que impedÃ­a una integraciÃ³n real.

ğŸ§  Pregunta 42
Â¿CuÃ¡l es la diferencia entre pruebas unitarias y la commit suite?

A. No hay diferencia, son exactamente lo mismo
B. La commit suite solo incluye pruebas manuales
C. La commit suite puede incluir mÃ¡s pruebas rÃ¡pidas ademÃ¡s de las unitarias
D. La commit suite se ejecuta solo al final del sprint

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Aunque comÃºnmente contiene pruebas unitarias, la commit suite puede incluir otras pruebas automatizadas rÃ¡pidas para validar el cÃ³digo en cada commit.

ğŸ§  Pregunta 43
Â¿QuÃ© acciÃ³n se considera prioritaria cuando una rama pierde su salud?

A. Crear una nueva rama y dejar la defectuosa
B. Congelar los commits y solucionar los errores antes de continuar
C. Desplegarla de todas maneras
D. Eliminar el historial de cambios

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Cuando una rama falla en las pruebas o no compila, se recomienda congelarla y enfocar todos los esfuerzos en restaurar su estabilidad antes de seguir desarrollando.

ğŸ§  Pregunta 44
Â¿Por quÃ© mantener una mainline saludable acelera el desarrollo?

A. Reduce el nÃºmero de commits
B. Permite evitar las pruebas manuales
C. Facilita comenzar nuevas tareas sin lidiar con errores del pasado
D. Aumenta la cantidad de ramas en el proyecto

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Si la mainline estÃ¡ limpia y estable, los desarrolladores pueden trabajar de forma continua sin tener que perder tiempo corrigiendo errores heredados.

ğŸ§  Pregunta 45
Â¿QuÃ© permite hacer una buena commit suite en pocos minutos?

A. Eliminar la necesidad de revisiÃ³n de cÃ³digo
B. Validar rÃ¡pidamente si el cÃ³digo introducido rompiÃ³ algo
C. Detectar errores de diseÃ±o arquitectÃ³nico
D. Aumentar la cobertura de comentarios

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Al validar automÃ¡ticamente el cÃ³digo con una suite rÃ¡pida, el equipo recibe feedback inmediato y puede actuar rÃ¡pidamente ante errores.

ğŸ§  Pregunta 46
Â¿QuÃ© problema comÃºn enfrentan los desarrolladores al clonar repositorios en Git segÃºn Fowler?

A. Tienen acceso directo a producciÃ³n
B. El repositorio local sobrescribe el remoto
C. Terminan trabajando en ramas "master" diferentes
D. Se pierden los archivos locales

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Aunque trabajen en la misma rama master, cada clon tiene su propia copia y commits independientes, lo que significa que estÃ¡n en ramas distintas bajo la definiciÃ³n de Fowler.

ğŸ§  Pregunta 47
Â¿CuÃ¡l es una forma de evitar dejar commits defectuosos en el historial de una rama personal?

A. Usar git cherry-pick
B. Evitar hacer commits hasta terminar
C. Hacer squash antes de fusionar
D. Borrar el repositorio y empezar de nuevo

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Hacer squash permite combinar mÃºltiples commits en uno solo, dejando solo los estados funcionales y eliminando los pasos intermedios defectuosos.

ğŸ§  Pregunta 48
Â¿QuÃ© recomienda Fowler para mitigar la lentitud en pruebas exhaustivas?

A. Ejecutarlas solo al final del proyecto
B. Dividirlas en etapas en una pipeline de despliegue
C. Ejecutarlas en paralelo con otras tareas manuales
D. Ignorarlas si el cÃ³digo parece funcionar

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Fowler sugiere dividir las pruebas en etapas progresivas (pipeline), con una primera etapa rÃ¡pida (commit suite) y otras mÃ¡s lentas ejecutadas con menor frecuencia.

ğŸ§  Pregunta 49
Â¿QuÃ© permite que los equipos puedan lanzar desde mainline directamente a producciÃ³n?

A. Que la mainline se mantenga siempre saludable y con cÃ³digo confiable
B. Que las ramas de desarrollo se eliminen
C. Que se reduzca el uso de pruebas
D. Que se desactive el control de versiones

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: Si la mainline se mantiene limpia y verificada en todo momento, el equipo puede lanzar directamente sin una fase larga de estabilizaciÃ³n.

ğŸ§  Pregunta 50
Â¿Por quÃ© los commits frecuentes en ramas personales pueden entrar en conflicto con la salud de la rama?

A. Porque ocupan mucho espacio
B. Porque podrÃ­an incluir cambios que aÃºn no compilan
C. Porque dificultan la visualizaciÃ³n de los tags
D. Porque incrementan el nÃºmero de forks

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Aunque los commits frecuentes son Ãºtiles como puntos de control, podrÃ­an dejar en el historial estados defectuosos. Por eso Fowler recomienda hacer squash al finalizar.


ğŸ§  Pregunta 61
Â¿QuÃ© problema puede surgir incluso cuando una fusiÃ³n de ramas no genera conflictos visibles?

A. La historia de Git se corrompe
B. El proyecto no puede ser desplegado en la nube
C. El sistema presenta errores de ejecuciÃ³n debido a cambios lÃ³gicos incompatibles
D. Los tags se sobrescriben

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Los conflictos semÃ¡nticos no siempre son detectados por el sistema de control de versiones. Aunque el cÃ³digo fusione y compile, puede fallar en su comportamiento lÃ³gico en tiempo de ejecuciÃ³n.

ğŸ§  Pregunta 62
Â¿Por quÃ© los conflictos de integraciÃ³n en el cÃ³digo no se pueden resolver siempre de forma automÃ¡tica?

A. Porque los archivos son demasiado grandes
B. Porque el control de versiones solo puede detectar conflictos de texto, no de significado
C. Porque Git necesita permisos especiales
D. Porque Mercurial no soporta conflictos

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: El sistema puede detectar conflictos de texto, pero no puede entender si el cÃ³digo sigue teniendo sentido funcionalmente. Resolver conflictos semÃ¡nticos requiere anÃ¡lisis humano.

ğŸ§  Pregunta 63
Â¿QuÃ© seÃ±ala Kent Beck con su frase "dar a cada individuo la ilusiÃ³n de tiempo congelado"?

A. Que cada desarrollador trabaja de forma aislada creyendo que sus cambios no afectarÃ¡n a otros
B. Que se congela el repositorio en cada commit
C. Que el sistema borra cambios antiguos automÃ¡ticamente
D. Que los desarrolladores deben sincronizar en vivo todos los cambios

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: Cada desarrollador trabaja como si fuera el Ãºnico modificando el sistema, pero eventualmente los cambios deben ser reconciliados, pagando el costo de integrar.

ğŸ§  Pregunta 64
Â¿QuÃ© debe hacer un equipo ante un conflicto semÃ¡ntico despuÃ©s de fusionar ramas?

A. Revertir siempre la fusiÃ³n
B. Ejecutar solo pruebas de compilaciÃ³n
C. Resolver manualmente el conflicto con intervenciÃ³n humana y posible modificaciÃ³n de cÃ³digo
D. Ignorar los errores hasta un prÃ³ximo sprint

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Un conflicto semÃ¡ntico necesita ser revisado manualmente. Puede requerir modificaciones que combinen los cambios de distintas ramas respetando la lÃ³gica funcional.

ğŸ§  Pregunta 65
Â¿QuÃ© representa el "deployment pipeline" que menciona Martin Fowler?

A. Un proceso de despliegue manual
B. Una serie de etapas de prueba automatizada tras cada commit
C. Un mecanismo para crear ramas nuevas
D. Un sistema para realizar merge de branches

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Un deployment pipeline automatiza el proceso de validaciÃ³n de cÃ³digo en distintas fases, desde la commit suite rÃ¡pida hasta pruebas mÃ¡s largas como integraciÃ³n, performance o seguridad.

ğŸ§  Pregunta 66
Â¿CuÃ¡l es el propÃ³sito de ejecutar la primera etapa de pruebas (commit suite) en menos de 10 minutos?

A. Validar cambios rÃ¡pidamente para permitir una integraciÃ³n continua efectiva
B. Aumentar la cobertura de documentaciÃ³n
C. Reducir el nÃºmero de ramas en el proyecto
D. Evitar la necesidad de hacer squash

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: Ejecutar la commit suite en pocos minutos permite obtener feedback inmediato sobre la calidad del cÃ³digo, facilitando integraciones rÃ¡pidas y frecuentes.

ğŸ§  Pregunta 67
Â¿QuÃ© deben hacer los equipos si sus pruebas de performance tardan varias horas en ejecutarse?

A. Eliminar esas pruebas
B. Ejecutarlas sÃ³lo una vez al mes
C. Mantenerlas en una etapa posterior del pipeline, despuÃ©s de la commit suite
D. Integrarlas directamente en el commit inicial

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Pruebas costosas como las de performance deben ejecutarse en etapas posteriores del pipeline para no bloquear el flujo de commits rÃ¡pidos.

ğŸ§  Pregunta 68
Â¿CuÃ¡l es una seÃ±al de que un equipo ha logrado una mainline saludable y confiable?

A. Necesitan mÃºltiples ramas para estabilizar el cÃ³digo antes de lanzar
B. Pueden lanzar a producciÃ³n directamente desde la lÃ­nea principal
C. Crean un backup antes de cada commit
D. Solo lanzan versiones mayores cada aÃ±o

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Cuando la mainline se mantiene siempre estable, el equipo puede lanzar directamente a producciÃ³n, minimizando la necesidad de grandes fases de estabilizaciÃ³n.

ğŸ§  Pregunta 69
Â¿QuÃ© se busca al aplicar pruebas automÃ¡ticas en cada commit?

A. Detectar errores de despliegue
B. Asegurar que los cambios no rompan funcionalidades existentes
C. Evitar la creaciÃ³n de nuevas ramas
D. Reducir la cantidad de pull requests

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Las pruebas automÃ¡ticas verifican que cada cambio nuevo no introduzca errores que afecten el funcionamiento ya establecido del sistema.

ğŸ§  Pregunta 70
Â¿CuÃ¡l es la mayor ventaja de eliminar los commits no saludables antes de fusionar a la mainline?

A. Mejora la estÃ©tica del historial de Git
B. Disminuye el tamaÃ±o del repositorio
C. Asegura que solo cÃ³digo funcional llegue a la lÃ­nea principal, reduciendo errores de integraciÃ³n
D. Facilita crear forks desde cualquier commit

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Consolidar commits defectuosos antes de integrar mantiene la mainline estable y funcional, haciendo mÃ¡s fÃ¡cil y segura la integraciÃ³n continua del equipo.

ğŸ§  Pregunta 71
SegÃºn Fowler, Â¿quÃ© facilita que los equipos puedan ver cÃ³mo evoluciona el proyecto a lo largo del tiempo?

A. El sistema de permisos de GitHub
B. El rastreo de cambios en los sistemas de control de versiones
C. La creaciÃ³n de ramas por cada funcionalidad
D. El uso de pipelines manuales de validaciÃ³n

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Los sistemas modernos de control de versiones no solo permiten gestionar versiones, sino tambiÃ©n seguir la evoluciÃ³n del proyecto gracias al historial de cambios registrados.

ğŸ§  Pregunta 72
Â¿QuÃ© aspecto del control de versiones es clave para permitir la fusiÃ³n de cambios entre ramas?

A. La existencia de mÃºltiples forks
B. El registro detallado de cada commit
C. El uso de sistemas de archivos distribuidos
D. La creaciÃ³n de etiquetas semanales

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Registrar cada cambio como un commit facilita el proceso de fusiÃ³n, ya que se puede reconstruir cÃ³mo se llegÃ³ a cada versiÃ³n y reconciliar diferencias mÃ¡s fÃ¡cilmente.

ğŸ§  Pregunta 73
Cuando Scarlett resetea su master local a origin/master, Â¿quÃ© sucede con su trabajo anterior segÃºn la lectura?

A. Se pierde para siempre
B. Se convierte en una nueva codeline etiquetada
C. Se fusiona automÃ¡ticamente
D. Se borra del historial global

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Al etiquetar antes de resetear, Scarlett preserva su trabajo como una codeline aparte, que puede ser revisitada o fusionada mÃ¡s adelante si es necesario.

ğŸ§  Pregunta 74
Â¿Por quÃ© Martin Fowler considera que el branching crea una "ilusiÃ³n" en el desarrollo de software?

A. Porque hace que los conflictos no existan
B. Porque oculta la necesidad de hacer pruebas
C. Porque da la apariencia de que cada desarrollador trabaja solo en el sistema
D. Porque elimina los conflictos semÃ¡nticos

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: El branching da a cada desarrollador la ilusiÃ³n de trabajar aislado sin interferir en el sistema general, pero eventualmente todos deben reconciliar sus cambios.

ğŸ§  Pregunta 75
Â¿QuÃ© describe mejor un "semantic conflict" (conflicto semÃ¡ntico) en el artÃ­culo?

A. Un error de permisos en el repositorio
B. Un conflicto detectado en la estructura del Ã¡rbol Git
C. Un fallo lÃ³gico que no se detecta durante la fusiÃ³n textual
D. Un problema en el etiquetado de versiones

âœ… Correcta: C
ğŸ§¾ ExplicaciÃ³n: Los conflictos semÃ¡nticos ocurren cuando, aunque la fusiÃ³n textual no falle, el sistema no compila o no funciona como deberÃ­a debido a diferencias en la lÃ³gica.

ğŸ§  Pregunta 76
Â¿QuÃ© aspecto del control de versiones ayuda a determinar en quÃ© momento deben fusionarse los cambios?

A. El sistema de etiquetas y releases
B. El historial de forks
C. La visualizaciÃ³n de ramas en un Ã¡rbol
D. El rastreo de cambios individuales en cada commit

âœ… Correcta: D
ğŸ§¾ ExplicaciÃ³n: El registro detallado de cambios en los commits permite identificar puntos comunes y divergentes para decidir cuÃ¡ndo y cÃ³mo hacer una fusiÃ³n.

ğŸ§  Pregunta 77
En la analogÃ­a de la caÃ­da desde un edificio que menciona Fowler, Â¿quÃ© representa la â€œcaÃ­daâ€ en el desarrollo con ramas?

A. El trabajo de codificaciÃ³n sin integraciÃ³n
B. El testing de unidades
C. El commit inicial de la rama
D. El despliegue de una nueva versiÃ³n

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: La caÃ­da representa el tiempo en que los desarrolladores trabajan de manera aislada en sus ramas; el "aterrizaje" representa la dificultad y el costo de fusionarlo todo correctamente.

ğŸ§  Pregunta 78
Â¿QuÃ© efecto tiene clonar un repositorio respecto a las codelines?

A. No afecta las codelines existentes
B. Crea una nueva codeline independiente basada en el estado clonado
C. Fusiona automÃ¡ticamente ramas remotas
D. Elimina las ramas locales

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Cada clon crea efectivamente una nueva codeline, aunque trabaje sobre la misma rama "master", porque los commits son independientes hasta que se fusionan explÃ­citamente.

ğŸ§  Pregunta 79
Â¿QuÃ© factor complica aÃºn mÃ¡s los conflictos de fusiÃ³n en sistemas distribuidos como Git?

A. Que cada clon tiene su propio conjunto de ramas y commits
B. Que no se puede trabajar sin conexiÃ³n
C. Que Git no soporta mÃºltiples usuarios
D. Que los forks son inmutables

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: En sistemas como Git, cada desarrollador tiene un clon con su propio historial, por lo que las fusiones implican unir mÃºltiples codelines independientes.

ğŸ§  Pregunta 80
Â¿CuÃ¡l es una desventaja de ejecutar todas las pruebas exhaustivas en cada commit segÃºn la lectura?

A. Aumenta la probabilidad de conflictos
B. Hace que la integraciÃ³n continua sea lenta y reduce la agilidad
C. Obliga a fusionar inmediatamente
D. Elimina la necesidad de ramas personales

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Si las pruebas son demasiado lentas, cada commit tarda mucho en validarse, lo cual frena el flujo de trabajo y dificulta una integraciÃ³n rÃ¡pida y continua.

ğŸ§  Pregunta 81
En Git, Â¿quÃ© sucede tÃ©cnicamente cuando haces un git clone de un repositorio remoto?

A. Se crea una nueva rama remota sincronizada automÃ¡ticamente
B. Se crea una copia local del repositorio incluyendo todo su historial y ramas
C. Solo se clona el Ãºltimo commit de la rama principal
D. Se genera un branch separado para cada commit

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: git clone crea una copia local completa, incluyendo todos los commits, ramas, y referencias remotas, permitiendo desarrollar de forma independiente al repositorio original.

ğŸ§  Pregunta 82
Â¿QuÃ© problema genera principalmente un conflicto semÃ¡ntico tras una fusiÃ³n en Git?

A. La incapacidad de hacer pull requests
B. El cÃ³digo compila exitosamente, pero falla en tiempo de ejecuciÃ³n debido a cambios incompatibles en la lÃ³gica
C. Un error automÃ¡tico de Git que impide push
D. Un merge automÃ¡tico fallido que detiene el CI

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Un conflicto semÃ¡ntico ocurre cuando el sistema no puede detectar que los cambios lÃ³gicos realizados rompen funcionalidades, porque la fusiÃ³n textual no produce errores visibles.

ğŸ§  Pregunta 83
Â¿CuÃ¡l es el rol tÃ©cnico de la commit suite dentro de un deployment pipeline?

A. Generar ramas automÃ¡ticas para cada cambio
B. Ejecutar pruebas rÃ¡pidas que validan la integridad bÃ¡sica del sistema tras cada commit
C. Sincronizar automÃ¡ticamente los repositorios remotos
D. Eliminar ramas obsoletas

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: La commit suite es la primera capa de defensa, una colecciÃ³n de pruebas unitarias y de integraciÃ³n rÃ¡pida que aseguran que el sistema no se rompe tras cada commit individual.

ğŸ§  Pregunta 84
Â¿QuÃ© diferencia tÃ©cnica principal existe entre un conflicto textual y un conflicto semÃ¡ntico en control de versiones?

A. El conflicto textual ocurre durante la fusiÃ³n; el semÃ¡ntico puede no aparecer hasta ejecuciÃ³n
B. El conflicto semÃ¡ntico es siempre solucionable automÃ¡ticamente
C. El conflicto textual solo afecta archivos binarios
D. El conflicto textual nunca requiere intervenciÃ³n manual

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: El conflicto textual impide completar un merge sin intervenciÃ³n; el semÃ¡ntico puede pasar desapercibido hasta que el cÃ³digo se ejecuta y revela errores lÃ³gicos.

ğŸ§  Pregunta 85
En un modelo basado en mainline, Â¿cuÃ¡l es la acciÃ³n correcta antes de integrar una nueva funcionalidad?

A. Crear una nueva release branch para cada pequeÃ±o cambio
B. Rebasear o fusionar frecuentemente la mainline en la rama personal de desarrollo
C. Eliminar los commits intermedios mediante un git reset
D. Hacer squash de la mainline antes de hacer pull

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Mantener la rama personal actualizada frecuentemente con la mainline evita grandes conflictos al integrar, reduciendo la divergencia.

ğŸ§  Pregunta 86
Â¿QuÃ© ventaja tÃ©cnica proporciona el uso de self-testing code en ramas personales?

A. Permite hacer cherry-pick automÃ¡tico entre commits
B. Garantiza que el cÃ³digo se valida a travÃ©s de pruebas automatizadas antes de integrarlo a mainline
C. Evita la necesidad de crear feature branches
D. Sincroniza automÃ¡ticamente cambios entre branches

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Self-testing code implica escribir pruebas junto al cÃ³digo de producciÃ³n, asegurando que cualquier fallo se detecte de inmediato antes de afectar la mainline.

ğŸ§  Pregunta 87
Â¿Por quÃ© mantener una mainline saludable tÃ©cnicamente permite lanzar a producciÃ³n en cualquier momento?

A. Porque todos los cambios estÃ¡n aprobados automÃ¡ticamente por pull requests
B. Porque el tip de mainline siempre contiene una versiÃ³n estable, probada y lista para despliegue
C. Porque se eliminan las pruebas manuales
D. Porque Git sincroniza automÃ¡ticamente los cambios cada hora

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Una mainline saludable implica que cada commit mantiene el sistema funcional, lo que permite generar builds de producciÃ³n confiables sin estabilizaciones extensas.

ğŸ§  Pregunta 88
Â¿QuÃ© mecanismo utiliza Git para registrar cambios individuales y facilitar la reconstrucciÃ³n de la historia del proyecto?

A. Tags y versiones
B. Commits inmutables encadenados por referencias SHA-1/SHA-256
C. Branches volÃ¡tiles
D. Clones parciales

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Git registra cada cambio como un commit referenciado por un hash Ãºnico (SHA-1 en versiones tradicionales, SHA-256 en nuevas), lo que garantiza la integridad del historial.

ğŸ§  Pregunta 89
Â¿CuÃ¡l es un patrÃ³n tÃ©cnico para mantener un historial limpio y entendible en ramas personales antes de integrarse a mainline?

A. Aplicar git merge --no-ff a cada commit
B. Usar git squash para consolidar commits no saludables antes de hacer merge
C. Realizar forks independientes de mainline
D. Cambiar el nombre de los commits antiguos manualmente

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Hacer squash permite combinar mÃºltiples commits de trabajo en uno solo funcional y saludable, limpiando el historial antes de integrarlo a la mainline.

ğŸ§  Pregunta 90
En el contexto de la lectura, Â¿cuÃ¡l es el propÃ³sito tÃ©cnico de usar pipelines separados en la integraciÃ³n continua?

A. Reducir el nÃºmero de forks activos
B. Aislar rÃ¡pidamente los errores segÃºn el tipo de prueba y evitar detener todo el flujo de integraciÃ³n
C. Consolidar ramas automÃ¡ticamente al pasar pruebas
D. Obligar a los desarrolladores a trabajar en master

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Separar las etapas de pruebas en el pipeline (por ejemplo, commit suite primero, luego integraciÃ³n, luego performance) permite detectar errores temprano y optimizar el tiempo de feedback.

ğŸ§  Pregunta 91
Â¿CuÃ¡l es el rol tÃ©cnico del origin/master en un flujo de trabajo con Git?

A. Es la copia local mÃ¡s reciente de la rama master remota
B. Es una etiqueta creada al momento del primer commit
C. Es la rama protegida contra push forzado
D. Es una rama secundaria creada automÃ¡ticamente al hacer merge

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: origin/master es la referencia local que apunta al Ãºltimo estado conocido de la rama master en el repositorio remoto; se actualiza cuando haces git fetch o git pull.

ğŸ§  Pregunta 92
Â¿QuÃ© ventaja tÃ©cnica proporciona realizar integraciones frecuentes de la mainline en las ramas personales?

A. Minimiza el riesgo de conflictos complejos al momento de hacer merge final
B. Permite borrar ramas antiguas automÃ¡ticamente
C. Acelera el proceso de rebase
D. Elimina la necesidad de testing

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: Integrar frecuentemente evita que los cambios divergentes acumulen conflictos, haciendo que el proceso de fusiÃ³n final sea mucho mÃ¡s sencillo y predecible.

ğŸ§  Pregunta 93
Â¿QuÃ© diferencia tÃ©cnica existe entre un merge conflict textual y un conflict semÃ¡ntico?

A. El textual ocurre en archivos binarios; el semÃ¡ntico, en texto plano
B. El textual es detectado por Git; el semÃ¡ntico requiere pruebas o ejecuciÃ³n para ser descubierto
C. El textual es ignorado por Git; el semÃ¡ntico bloquea la fusiÃ³n
D. No existe diferencia; ambos son sinÃ³nimos

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Un conflicto textual ocurre cuando Git no puede combinar automÃ¡ticamente los cambios. Un conflicto semÃ¡ntico pasa desapercibido hasta la ejecuciÃ³n del cÃ³digo.

ğŸ§  Pregunta 94
Â¿CuÃ¡l serÃ­a una prÃ¡ctica tÃ©cnica adecuada despuÃ©s de detectar un conflicto semÃ¡ntico tras un merge?

A. Forzar el push ignorando el error
B. Analizar, corregir manualmente y agregar pruebas especÃ­ficas que validen el nuevo comportamiento
C. Eliminar el commit anterior y rehacer el merge
D. Crear una nueva rama desde master

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Los conflictos semÃ¡nticos requieren que los desarrolladores analicen el problema, resuelvan las inconsistencias lÃ³gicas y aÃ±adan pruebas para garantizar que el nuevo comportamiento sea vÃ¡lido.

ğŸ§  Pregunta 95
En una prÃ¡ctica DevOps moderna, Â¿quÃ© caracterÃ­sticas debe tener una commit suite ideal?

A. Ejecutarse en menos de 10 minutos y cubrir los componentes crÃ­ticos de negocio
B. Ejecutar todas las pruebas de integraciÃ³n y performance completas
C. Solo validar los cambios de frontend
D. Ignorar pruebas lentas y enfocarse en mÃ©tricas de infraestructura

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: Una buena commit suite debe ser rÃ¡pida (menos de 10 minutos) y validar de manera eficaz los componentes mÃ¡s crÃ­ticos para permitir una integraciÃ³n continua fluida.

ğŸ§  Pregunta 96
Â¿Por quÃ© realizar squash de commits antes de integrar una rama personal a la mainline?

A. Para reducir el nÃºmero de forks creados en GitHub
B. Para consolidar cambios intermedios en un solo commit funcional y limpiar el historial
C. Para aumentar el nÃºmero de merges en el repositorio
D. Para evitar conflictos de sincronizaciÃ³n de pull requests

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Squashear une varios commits pequeÃ±os e inestables en uno solo bien probado, asegurando que el historial de la mainline sea claro, funcional y fÃ¡cil de entender.

ğŸ§  Pregunta 97
Â¿QuÃ© significa mantener una lÃ­nea principal saludable en tÃ©rminos de control de calidad?

A. Que no haya ramas en conflicto
B. Que cada commit pase todas las pruebas de validaciÃ³n automÃ¡tica antes de ser aceptado
C. Que se tenga siempre la Ãºltima versiÃ³n de las dependencias
D. Que los cambios se apliquen de manera masiva cada semana

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Una lÃ­nea principal saludable significa que cada cambio integrado ha sido validado automÃ¡ticamente, garantizando la estabilidad funcional continua del producto.

ğŸ§  Pregunta 98
Â¿QuÃ© estrategia tÃ©cnica puede reducir el impacto del tiempo de ejecuciÃ³n de pruebas de performance muy largas?

A. Dividir las pruebas de performance en pipelines separados y ejecutarlas fuera de la commit suite
B. Ejecutarlas todas en la commit suite inicial
C. Ejecutarlas Ãºnicamente en ramas de hotfix
D. Ignorar las pruebas de performance si las pruebas unitarias pasan

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: Las pruebas costosas deben ejecutarse en etapas separadas de la pipeline para no bloquear el ciclo de feedback rÃ¡pido necesario en integraciÃ³n continua.

ğŸ§  Pregunta 99
Â¿Por quÃ© es importante construir software que pase automÃ¡ticamente su commit suite antes de fusionarlo en mainline?

A. Para evitar la proliferaciÃ³n de ramas
B. Para garantizar que cada commit aÃ±adido a la lÃ­nea principal mantiene el sistema estable y desplegable
C. Para disminuir el tamaÃ±o de los artefactos
D. Para permitir crear forks pÃºblicos

âœ… Correcta: B
ğŸ§¾ ExplicaciÃ³n: Si cada commit que llega a mainline es seguro y funcional, el equipo puede garantizar entregas rÃ¡pidas y confiables sin necesitar largos ciclos de estabilizaciÃ³n posteriores.

ğŸ§  Pregunta 100
Â¿CuÃ¡l serÃ­a un sÃ­ntoma tÃ©cnico de un equipo que no mantiene su mainline saludable?

A. Necesidad constante de â€œfreezarâ€ (congelar) branches antes de releases
B. Aumento de la velocidad de despliegue
C. DisminuciÃ³n del nÃºmero de pull requests
D. ReducciÃ³n de conflictos semÃ¡nticos

âœ… Correcta: A
ğŸ§¾ ExplicaciÃ³n: Si el equipo necesita constantemente congelar ramas o hacer "code freezes" largos antes de lanzar, es un claro indicio de que su mainline no se mantiene estable de forma continua.