üß† Pregunta 96

Un equipo de desarrollo ha estado trabajando en una rama de caracter√≠stica durante varias semanas, generando numerosos commits que documentan los pasos incrementales de su trabajo Antes de fusionar esta rama a la principal, consideran utilizar el rebase interactivo

a) Describe dos comandos espec√≠ficos de git rebase -i que podr√≠an utilizar para simplificar y aclarar el historial de su rama de caracter√≠stica antes de la fusi√≥n Explica el prop√≥sito de cada comando (1 punto)
b) Discute una ventaja y una posible desventaja de aplicar extensivamente el rebase interactivo en ramas de caracter√≠sticas de larga duraci√≥n en un entorno colaborativo (1 punto)

A. pick para mantener commits y drop para eliminarlos
B. squash para combinar commits y reword para modificar mensajes
C. edit para detener el rebase y exec para ejecutar comandos
D. merge para fusionar con otra rama y next para continuar

‚úÖ Correcta: B

üßæ Explicaci√≥n: squash permite combinar varios commits en uno solo, creando un historial m√°s limpio reword permite modificar los mensajes de los commits para mayor claridad La ventaja es un historial simplificado, la desventaja es el riesgo de reescribir historia compartida.

üß† Pregunta 97

En un proyecto, se ha decidido utilizar la estrategia de merge sin Fast-Forward (--no-ff) para todas las fusiones de ramas de caracter√≠sticas a la rama principal

a) Explica la principal raz√≥n para adoptar esta estrategia de merge, incluso en casos donde un Fast-Forward ser√≠a posible ¬øQu√© informaci√≥n importante se preserva en el historial del proyecto (1 punto)
b) Si posteriormente se necesita revertir completamente la funcionalidad introducida por una rama de caracter√≠stica fusionada con --no-ff, ¬øc√≥mo facilitar√≠a esta estrategia el proceso de reversi√≥n en comparaci√≥n con un Fast-Forward merge (1 punto)

A. Permite una reversi√≥n m√°s granular de commits individuales
B. Crea un punto expl√≠cito en el historial para la fusi√≥n de la caracter√≠stica, facilitando la reversi√≥n completa
C. Evita la creaci√≥n de commits de merge innecesarios
D. Resuelve autom√°ticamente los conflictos durante la fusi√≥n

‚úÖ Correcta: B

üßæ Explicaci√≥n: --no-ff fuerza la creaci√≥n de un commit de merge, que representa la integraci√≥n completa de la caracter√≠stica Esto facilita la reversi√≥n de toda la funcionalidad con un solo comando git revert al commit de merge.

üß† Pregunta 98

Un equipo descubre una regresi√≥n en la rama principal y sospecha que fue introducida por uno de los muchos commits recientes Deciden utilizar git bisect para identificar la causa

a) Describe los primeros tres comandos esenciales que el equipo ejecutar√≠a para iniciar y configurar la sesi√≥n de git bisect Explica el prop√≥sito de cada comando en este contexto (1 punto)
b) Una vez que git bisect a√≠sla un commit sospechoso, ¬øqu√© otra herramienta de diagn√≥stico de Git ser√≠a √∫til para examinar los cambios espec√≠ficos introducidos por ese commit en los archivos afectados (Menciona el comando y explica brevemente c√≥mo ayudar√≠a en el diagn√≥stico) (1 punto)

A. git start, git bad, git good
B. git bisect start, git bisect bad, git bisect good
C. git find, git error, git ok
D. git trace, git fail, git pass

‚úÖ Correcta: B

üßæ Explicaci√≥n: git bisect start inicia el proceso de b√∫squeda binaria git bisect bad marca el commit actual (donde se encuentra el error) git bisect good marca un commit anterior conocido como libre de errores git show <commit_sospechoso> permite ver los cambios introducidos por ese commit.

üß† Pregunta 99

Un desarrollador, mientras experimentaba, realiz√≥ varias operaciones de git reset --hard a diferentes commits en su rama local Ahora desea volver al estado exacto en el que se encontraba su rama hace dos horas

a) ¬øQu√© comando de Git le permitir√≠a al desarrollador ver un historial de los cambios en la punta de su rama local (HEAD) a lo largo del tiempo, incluyendo los resets (Menciona el comando) (0 5 punto)
b) Bas√°ndose en la salida de este comando, ¬øc√≥mo podr√≠a el desarrollador identificar el estado de su rama de hace dos horas y volver a ese punto (Describe brevemente la estrategia) (0 5 punto)

A. git log --all --graph
B. git history
C. git reflog
D. git log -g

‚úÖ Correcta: C

üßæ Explicaci√≥n: git reflog muestra un historial de los movimientos de HEAD El desarrollador buscar√≠a en la salida la entrada correspondiente a hace dos horas y utilizar√≠a git reset --hard <reflog_entry_hash> para volver a ese estado.

üß† Pregunta 100

Un proyecto necesita incluir el c√≥digo de una biblioteca externa que se mantiene en un repositorio separado El equipo est√° debatiendo si utilizar subm√≥dulos o subtrees para integrar esta biblioteca

a) Menciona una diferencia clave en c√≥mo Git gestiona la inclusi√≥n del repositorio externo utilizando subm√≥dulos en comparaci√≥n con subtrees (0 5 punto)
b) Describe un escenario donde el uso de subtrees podr√≠a ser preferible a los subm√≥dulos para la gesti√≥n de esta dependencia externa (0 5 punto)

A. Los subm√≥dulos copian el c√≥digo, los subtrees enlazan al repositorio
B. Los subm√≥dulos mantienen una referencia a un commit espec√≠fico, los subtrees integran el c√≥digo directamente
C. Los subm√≥dulos son m√°s f√°ciles de actualizar, los subtrees son m√°s f√°ciles de clonar
D. Los subm√≥dulos no afectan el historial principal, los subtrees s√≠

‚úÖ Correcta: B

üßæ Explicaci√≥n: Los subm√≥dulos enlazan a un commit espec√≠fico de un repositorio externo, mientras que los subtrees copian el c√≥digo del repositorio externo directamente al proyecto principal Un escenario preferible para subtrees es cuando se anticipan modificaciones locales a la biblioteca que deben formar parte del historial del proyecto principal.